/*
 * Copyright (C) 2017 HaiYang Li
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package com.landawn.abacus.util;

import java.math.RoundingMode;

import com.landawn.abacus.annotation.Beta;
import com.landawn.abacus.annotation.SuppressFBWarnings;

/**
 * @implSpec classes/interfaces implemented in abacus-extra are not for daily use case. It's not going to handle {@code null} scenarios like what handled in abacus-common. It's developer's responsibility to handle {@code null} scenarios. // TODO
 *
 *
 */
@Beta
public sealed class Arrays permits Arrays.f {

    static final char CHAR_0 = (char) 0;
    static final byte BYTE_0 = (byte) 0;
    static final byte BYTE_1 = (byte) 1;
    static final short SHORT_0 = (short) 0;
    private static final String ARRAY_PRINT_SEPARATOR = IOUtil.LINE_SEPARATOR;

    private Arrays() {
        // utility class.
    }

    /**
     * Maps each element of the input array to a new type using the provided mapping function.
     * 
     * @param <T> the type of elements in the input array
     * @param <R> the type of elements in the result array
     * @param <E> the type of exception that the mapping function may throw
     * @param a the input array to map
     * @param func the mapping function to apply to each element
     * @param targetElementType the class of the target element type
     * @return a new array containing the mapped elements, or null if input is null
     * @throws E if the mapping function throws an exception
     * 
     * @example
     * <pre>
     * String[] strings = {"1", "2", "3"};
     * Integer[] ints = Arrays.map(strings, Integer::valueOf, Integer.class);
     * // Result: [1, 2, 3]
     * </pre>
     */
    public static <T, R, E extends Exception> R[] map(final T[] a, final Throwables.Function<? super T, ? extends R, E> func, final Class<R> targetElementType)
            throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final R[] c = N.newArray(targetElementType, len);

        for (int i = 0; i < len; i++) {
            c[i] = func.apply(a[i]);
        }

        return c;
    }

    /**
     * Maps each element of the input array to a boolean value using the provided function.
     *
     * @param <T> the type of elements in the input array
     * @param <E> the type of exception that the mapping function may throw
     * @param a the input array to map
     * @param func the function that maps each element to a boolean
     * @return a boolean array containing the mapped values, or null if input is null
     * @throws E if the mapping function throws an exception
     *
     * @example
     * <pre>
     * String[] words = {"hello", "hi", "world"};
     * boolean[] longWords = Arrays.mapToBoolean(words, s -> s.length() > 3);
     * // Result: [true, false, true]
     * </pre>
     */
    public static <T, E extends Exception> boolean[] mapToBoolean(final T[] a, final Throwables.ToBooleanFunction<? super T, E> func) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final boolean[] c = new boolean[len];

        for (int i = 0; i < len; i++) {
            c[i] = func.applyAsBoolean(a[i]);
        }

        return c;
    }

    /**
     * Maps each element of the input array to a char value using the provided function.
     *
     * @param <T> the type of elements in the input array
     * @param <E> the type of exception that the mapping function may throw
     * @param a the input array to map
     * @param func the function that maps each element to a char
     * @return a char array containing the mapped values, or null if input is null
     * @throws E if the mapping function throws an exception
     *
     * @example
     * <pre>
     * String[] words = {"apple", "banana", "cherry"};
     * char[] firstChars = Arrays.mapToChar(words, s -> s.charAt(0));
     * // Result: ['a', 'b', 'c']
     * </pre>
     */
    public static <T, E extends Exception> char[] mapToChar(final T[] a, final Throwables.ToCharFunction<? super T, E> func) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final char[] c = new char[len];

        for (int i = 0; i < len; i++) {
            c[i] = func.applyAsChar(a[i]);
        }

        return c;
    }

    /**
     * Maps each element of the input array to a byte value using the provided function.
     *
     * @param <T> the type of elements in the input array
     * @param <E> the type of exception that the mapping function may throw
     * @param a the input array to map
     * @param func the function that maps each element to a byte
     * @return a byte array containing the mapped values, or null if input is null
     * @throws E if the mapping function throws an exception
     */
    public static <T, E extends Exception> byte[] mapToByte(final T[] a, final Throwables.ToByteFunction<? super T, E> func) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final byte[] c = new byte[len];

        for (int i = 0; i < len; i++) {
            c[i] = func.applyAsByte(a[i]);
        }

        return c;
    }

    /**
     * Maps each element of the input array to a short value using the provided function.
     *
     * @param <T> the type of elements in the input array
     * @param <E> the type of exception that the mapping function may throw
     * @param a the input array to map
     * @param func the function that maps each element to a short
     * @return a short array containing the mapped values, or null if input is null
     * @throws E if the mapping function throws an exception
     */
    public static <T, E extends Exception> short[] mapToShort(final T[] a, final Throwables.ToShortFunction<? super T, E> func) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final short[] c = new short[len];

        for (int i = 0; i < len; i++) {
            c[i] = func.applyAsShort(a[i]);
        }

        return c;
    }

    /**
     * Maps each element of the input array to an int value using the provided function.
     *
     * @param <T> the type of elements in the input array
     * @param <E> the type of exception that the mapping function may throw
     * @param a the input array to map
     * @param func the function that maps each element to an int
     * @return an int array containing the mapped values, or null if input is null
     * @throws E if the mapping function throws an exception
     *
     * @example
     * <pre>
     * String[] numbers = {"10", "20", "30"};
     * int[] ints = Arrays.mapToInt(numbers, Integer::parseInt);
     * // Result: [10, 20, 30]
     * </pre>
     */
    public static <T, E extends Exception> int[] mapToInt(final T[] a, final Throwables.ToIntFunction<? super T, E> func) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[] c = new int[len];

        for (int i = 0; i < len; i++) {
            c[i] = func.applyAsInt(a[i]);
        }

        return c;
    }

    /**
     * Maps each element of the input array to a long value using the provided function.
     *
     * @param <T> the type of elements in the input array
     * @param <E> the type of exception that the mapping function may throw
     * @param a the input array to map
     * @param func the function that maps each element to a long
     * @return a long array containing the mapped values, or null if input is null
     * @throws E if the mapping function throws an exception
     */
    public static <T, E extends Exception> long[] mapToLong(final T[] a, final Throwables.ToLongFunction<? super T, E> func) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[] c = new long[len];

        for (int i = 0; i < len; i++) {
            c[i] = func.applyAsLong(a[i]);
        }

        return c;
    }

    /**
     * Maps each element of the input array to a float value using the provided function.
     *
     * @param <T> the type of elements in the input array
     * @param <E> the type of exception that the mapping function may throw
     * @param a the input array to map
     * @param func the function that maps each element to a float
     * @return a float array containing the mapped values, or null if input is null
     * @throws E if the mapping function throws an exception
     */
    public static <T, E extends Exception> float[] mapToFloat(final T[] a, final Throwables.ToFloatFunction<? super T, E> func) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[] c = new float[len];

        for (int i = 0; i < len; i++) {
            c[i] = func.applyAsFloat(a[i]);
        }

        return c;
    }

    /**
     * Maps each element of the input array to a double value using the provided function.
     *
     * @param <T> the type of elements in the input array
     * @param <E> the type of exception that the mapping function may throw
     * @param a the input array to map
     * @param func the function that maps each element to a double
     * @return a double array containing the mapped values, or null if input is null
     * @throws E if the mapping function throws an exception
     */
    public static <T, E extends Exception> double[] mapToDouble(final T[] a, final Throwables.ToDoubleFunction<? super T, E> func) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[] c = new double[len];

        for (int i = 0; i < len; i++) {
            c[i] = func.applyAsDouble(a[i]);
        }

        return c;
    }

    /**
     * Maps each boolean element to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the boolean array to map
     * @param mapper the function that maps each boolean to an object
     * @param targetElementType the class of the target element type
     * @return an object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     *
     * @example
     * <pre>
     * boolean[] flags = {true, false, true};
     * String[] strings = Arrays.mapToObj(flags, b -> b ? "YES" : "NO", String.class);
     * // Result: ["YES", "NO", "YES"]
     * </pre>
     */
    public static <T, E extends Exception> T[] mapToObj(final boolean[] a, final Throwables.BooleanFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[] result = N.newArray(targetElementType, len);

        for (int i = 0; i < len; i++) {
            result[i] = mapper.apply(a[i]);
        }

        return result;
    }

    /**
     * Maps each boolean element in a 2D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 2D boolean array to map
     * @param mapper the function that maps each boolean to an object
     * @param targetElementType the class of the target element type
     * @return a 2D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][] mapToObj(final boolean[][] a, final Throwables.BooleanFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each boolean element in a 3D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 3D boolean array to map
     * @param mapper the function that maps each boolean to an object
     * @param targetElementType the class of the target element type
     * @return a 3D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][][] mapToObj(final boolean[][][] a, final Throwables.BooleanFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each char element to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the char array to map
     * @param mapper the function that maps each char to an object
     * @param targetElementType the class of the target element type
     * @return an object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[] mapToObj(final char[] a, final Throwables.CharFunction<? extends T, E> mapper, final Class<T> targetElementType)
            throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[] result = N.newArray(targetElementType, len);

        for (int i = 0; i < len; i++) {
            result[i] = mapper.apply(a[i]);
        }

        return result;
    }

    /**
     * Maps each char element in a 2D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 2D char array to map
     * @param mapper the function that maps each char to an object
     * @param targetElementType the class of the target element type
     * @return a 2D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][] mapToObj(final char[][] a, final Throwables.CharFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each char element in a 3D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 3D char array to map
     * @param mapper the function that maps each char to an object
     * @param targetElementType the class of the target element type
     * @return a 3D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][][] mapToObj(final char[][][] a, final Throwables.CharFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each byte element to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the byte array to map
     * @param mapper the function that maps each byte to an object
     * @param targetElementType the class of the target element type
     * @return an object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[] mapToObj(final byte[] a, final Throwables.ByteFunction<? extends T, E> mapper, final Class<T> targetElementType)
            throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[] result = N.newArray(targetElementType, len);

        for (int i = 0; i < len; i++) {
            result[i] = mapper.apply(a[i]);
        }

        return result;
    }

    /**
     * Maps each byte element in a 2D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 2D byte array to map
     * @param mapper the function that maps each byte to an object
     * @param targetElementType the class of the target element type
     * @return a 2D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][] mapToObj(final byte[][] a, final Throwables.ByteFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each byte element in a 3D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 3D byte array to map
     * @param mapper the function that maps each byte to an object
     * @param targetElementType the class of the target element type
     * @return a 3D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][][] mapToObj(final byte[][][] a, final Throwables.ByteFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each short element to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the short array to map
     * @param mapper the function that maps each short to an object
     * @param targetElementType the class of the target element type
     * @return an object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[] mapToObj(final short[] a, final Throwables.ShortFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[] result = N.newArray(targetElementType, len);

        for (int i = 0; i < len; i++) {
            result[i] = mapper.apply(a[i]);
        }

        return result;
    }

    /**
     * Maps each short element in a 2D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 2D short array to map
     * @param mapper the function that maps each short to an object
     * @param targetElementType the class of the target element type
     * @return a 2D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][] mapToObj(final short[][] a, final Throwables.ShortFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each short element in a 3D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 3D short array to map
     * @param mapper the function that maps each short to an object
     * @param targetElementType the class of the target element type
     * @return a 3D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][][] mapToObj(final short[][][] a, final Throwables.ShortFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each int element to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the int array to map
     * @param mapper the function that maps each int to an object
     * @param targetElementType the class of the target element type
     * @return an object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     *
     * @example
     * <pre>
     * int[] numbers = {1, 2, 3};
     * String[] strings = Arrays.mapToObj(numbers, i -> "Number: " + i, String.class);
     * // Result: ["Number: 1", "Number: 2", "Number: 3"]
     * </pre>
     */
    public static <T, E extends Exception> T[] mapToObj(final int[] a, final Throwables.IntFunction<? extends T, E> mapper, final Class<T> targetElementType)
            throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[] result = N.newArray(targetElementType, len);

        for (int i = 0; i < len; i++) {
            result[i] = mapper.apply(a[i]);
        }

        return result;
    }

    /**
     * Maps each int element in a 2D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 2D int array to map
     * @param mapper the function that maps each int to an object
     * @param targetElementType the class of the target element type
     * @return a 2D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][] mapToObj(final int[][] a, final Throwables.IntFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each int element in a 3D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 3D int array to map
     * @param mapper the function that maps each int to an object
     * @param targetElementType the class of the target element type
     * @return a 3D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][][] mapToObj(final int[][][] a, final Throwables.IntFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each long element to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the long array to map
     * @param mapper the function that maps each long to an object
     * @param targetElementType the class of the target element type
     * @return an object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[] mapToObj(final long[] a, final Throwables.LongFunction<? extends T, E> mapper, final Class<T> targetElementType)
            throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[] result = N.newArray(targetElementType, len);

        for (int i = 0; i < len; i++) {
            result[i] = mapper.apply(a[i]);
        }

        return result;
    }

    /**
     * Maps each long element in a 2D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 2D long array to map
     * @param mapper the function that maps each long to an object
     * @param targetElementType the class of the target element type
     * @return a 2D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][] mapToObj(final long[][] a, final Throwables.LongFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each long element in a 3D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 3D long array to map
     * @param mapper the function that maps each long to an object
     * @param targetElementType the class of the target element type
     * @return a 3D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][][] mapToObj(final long[][][] a, final Throwables.LongFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each float element to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the float array to map
     * @param mapper the function that maps each float to an object
     * @param targetElementType the class of the target element type
     * @return an object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[] mapToObj(final float[] a, final Throwables.FloatFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[] result = N.newArray(targetElementType, len);

        for (int i = 0; i < len; i++) {
            result[i] = mapper.apply(a[i]);
        }

        return result;
    }

    /**
     * Maps each float element in a 2D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 2D float array to map
     * @param mapper the function that maps each float to an object
     * @param targetElementType the class of the target element type
     * @return a 2D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][] mapToObj(final float[][] a, final Throwables.FloatFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps each float element in a 3D array to an object using the provided mapper function.
     *
     * @param <T> the type of elements in the result array
     * @param <E> the type of exception that the mapper may throw
     * @param a the 3D float array to map
     * @param mapper the function that maps each float to an object
     * @param targetElementType the class of the target element type
     * @return a 3D object array containing the mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][][] mapToObj(final float[][][] a, final Throwables.FloatFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps a double array to an object array using the provided mapper function.
     * Each element in the input array is transformed using the mapper function.
     *
     * <p>Example usage:
     * <pre>{@code
     * double[] doubles = {1.5, 2.5, 3.5};
     * String[] strings = mapToObj(doubles, d -> String.format("%.1f", d), String.class);
     * // Result: {"1.5", "2.5", "3.5"}
     * }</pre>
     *
     * @param <T> the type of elements in the resulting array
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input double array
     * @param mapper the function to transform each double element
     * @param targetElementType the class of the target element type
     * @return an array of type T with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[] mapToObj(final double[] a, final Throwables.DoubleFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[] result = N.newArray(targetElementType, len);

        for (int i = 0; i < len; i++) {
            result[i] = mapper.apply(a[i]);
        }

        return result;
    }

    /**
     * Maps a 2D double array to a 2D object array using the provided mapper function.
     * Each element in the input array is transformed using the mapper function.
     *
     * <p>Example usage:
     * <pre>{@code
     * double[][] doubles = {{1.5, 2.5}, {3.5, 4.5}};
     * String[][] strings = mapToObj(doubles, d -> String.format("%.1f", d), String.class);
     * // Result: {{"1.5", "2.5"}, {"3.5", "4.5"}}
     * }</pre>
     *
     * @param <T> the type of elements in the resulting array
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 2D double array
     * @param mapper the function to transform each double element
     * @param targetElementType the class of the target element type
     * @return a 2D array of type T with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][] mapToObj(final double[][] a, final Throwables.DoubleFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps a 3D double array to a 3D object array using the provided mapper function.
     * Each element in the input array is transformed using the mapper function.
     *
     * <p>Example usage:
     * <pre>{@code
     * double[][][] doubles = {{{1.1, 2.2}}, {{3.3, 4.4}}};
     * Integer[][][] integers = mapToObj(doubles, d -> (int) d, Integer.class);
     * // Result: {{{1, 2}}, {{3, 4}}}
     * }</pre>
     *
     * @param <T> the type of elements in the resulting array
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 3D double array
     * @param mapper the function to transform each double element
     * @param targetElementType the class of the target element type
     * @return a 3D array of type T with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <T, E extends Exception> T[][][] mapToObj(final double[][][] a, final Throwables.DoubleFunction<? extends T, E> mapper,
            final Class<T> targetElementType) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final T[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), len);

        for (int i = 0; i < len; i++) {
            result[i] = mapToObj(a[i], mapper, targetElementType);
        }

        return result;
    }

    /**
     * Maps a 1D int array to a 1D long array using the provided mapper function.
     * Each int element is transformed to a long value.
     *
     * <p>Example usage:
     * <pre>{@code
     * int[] ints = {1, 2, 3};
     * long[] longs = mapToLong(ints, i -> i * 1000000000L);
     * // Result: {1000000000L, 2000000000L, 3000000000L}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input int array
     * @param mapper the function to transform each int to long
     * @return a long array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> long[] mapToLong(final int[] a, final Throwables.IntToLongFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[] result = new long[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsLong(a[i]);
        }

        return result;
    }

    /**
     * Maps a 2D int array to a 2D long array using the provided mapper function.
     * Each int element is transformed to a long value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 2D int array
     * @param mapper the function to transform each int to long
     * @return a 2D long array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> long[][] mapToLong(final int[][] a, final Throwables.IntToLongFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][] result = new long[len][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToLong(a[i], mapper);
        }

        return result;
    }

    /**
     * Maps a 3D int array to a 3D long array using the provided mapper function.
     * Each int element is transformed to a long value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 3D int array
     * @param mapper the function to transform each int to long
     * @return a 3D long array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> long[][][] mapToLong(final int[][][] a, final Throwables.IntToLongFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][][] result = new long[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToLong(a[i], mapper);
        }

        return result;
    }

    /**
     * Maps a 1D int array to a 1D double array using the provided mapper function.
     * Each int element is transformed to a double value.
     *
     * <p>Example usage:
     * <pre>{@code
     * int[] ints = {1, 2, 3};
     * double[] doubles = mapToDouble(ints, i -> i / 2.0);
     * // Result: {0.5, 1.0, 1.5}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input int array
     * @param mapper the function to transform each int to double
     * @return a double array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> double[] mapToDouble(final int[] a, final Throwables.IntToDoubleFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[] result = new double[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsDouble(a[i]);
        }

        return result;
    }

    /**
     * Maps a 2D int array to a 2D double array using the provided mapper function.
     * Each int element is transformed to a double value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 2D int array
     * @param mapper the function to transform each int to double
     * @return a 2D double array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> double[][] mapToDouble(final int[][] a, final Throwables.IntToDoubleFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][] result = new double[len][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToDouble(a[i], mapper);
        }

        return result;
    }

    /**
     * Maps a 3D int array to a 3D double array using the provided mapper function.
     * Each int element is transformed to a double value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 3D int array
     * @param mapper the function to transform each int to double
     * @return a 3D double array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> double[][][] mapToDouble(final int[][][] a, final Throwables.IntToDoubleFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][][] result = new double[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToDouble(a[i], mapper);
        }

        return result;
    }

    /**
     * Maps a 1D long array to a 1D int array using the provided mapper function.
     * Each long element is transformed to an int value.
     *
     * <p>Example usage:
     * <pre>{@code
     * long[] longs = {1000L, 2000L, 3000L};
     * int[] ints = mapToInt(longs, l -> (int)(l / 1000));
     * // Result: {1, 2, 3}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input long array
     * @param mapper the function to transform each long to int
     * @return an int array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> int[] mapToInt(final long[] a, final Throwables.LongToIntFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsInt(a[i]);
        }

        return result;
    }

    /**
     * Maps a 2D long array to a 2D int array using the provided mapper function.
     * Each long element is transformed to an int value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 2D long array
     * @param mapper the function to transform each long to int
     * @return a 2D int array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> int[][] mapToInt(final long[][] a, final Throwables.LongToIntFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][] result = new int[len][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToInt(a[i], mapper);
        }

        return result;
    }

    /**
     * Maps a 3D long array to a 3D int array using the provided mapper function.
     * Each long element is transformed to an int value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 3D long array
     * @param mapper the function to transform each long to int
     * @return a 3D int array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> int[][][] mapToInt(final long[][][] a, final Throwables.LongToIntFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][][] result = new int[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToInt(a[i], mapper);
        }

        return result;
    }

    /**
     * Maps a 1D long array to a 1D double array using the provided mapper function.
     * Each long element is transformed to a double value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input long array
     * @param mapper the function to transform each long to double
     * @return a double array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> double[] mapToDouble(final long[] a, final Throwables.LongToDoubleFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[] result = new double[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsDouble(a[i]);
        }

        return result;
    }

    /**
     * Maps a 2D long array to a 2D double array using the provided mapper function.
     * Each long element is transformed to a double value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 2D long array
     * @param mapper the function to transform each long to double
     * @return a 2D double array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> double[][] mapToDouble(final long[][] a, final Throwables.LongToDoubleFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][] result = new double[len][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToDouble(a[i], mapper);
        }

        return result;
    }

    /**
     * Maps a 3D long array to a 3D double array using the provided mapper function.
     * Each long element is transformed to a double value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 3D long array
     * @param mapper the function to transform each long to double
     * @return a 3D double array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> double[][][] mapToDouble(final long[][][] a, final Throwables.LongToDoubleFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][][] result = new double[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToDouble(a[i], mapper);
        }

        return result;
    }

    /**
     * Maps a 1D double array to a 1D int array using the provided mapper function.
     * Each double element is transformed to an int value.
     *
     * <p>Example usage:
     * <pre>{@code
     * double[] doubles = {1.7, 2.3, 3.9};
     * int[] ints = mapToInt(doubles, d -> (int) Math.round(d));
     * // Result: {2, 2, 4}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input double array
     * @param mapper the function to transform each double to int
     * @return an int array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> int[] mapToInt(final double[] a, final Throwables.DoubleToIntFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsInt(a[i]);
        }

        return result;
    }

    /**
     * Maps a 2D double array to a 2D int array using the provided mapper function.
     * Each double element is transformed to an int value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 2D double array
     * @param mapper the function to transform each double to int
     * @return a 2D int array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> int[][] mapToInt(final double[][] a, final Throwables.DoubleToIntFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][] result = new int[len][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToInt(a[i], mapper);
        }

        return result;
    }

    /**
     * Maps a 3D double array to a 3D int array using the provided mapper function.
     * Each double element is transformed to an int value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 3D double array
     * @param mapper the function to transform each double to int
     * @return a 3D int array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> int[][][] mapToInt(final double[][][] a, final Throwables.DoubleToIntFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][][] result = new int[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToInt(a[i], mapper);
        }

        return result;
    }

    /**
     * Maps a 1D double array to a 1D long array using the provided mapper function.
     * Each double element is transformed to a long value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input double array
     * @param mapper the function to transform each double to long
     * @return a long array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> long[] mapToLong(final double[] a, final Throwables.DoubleToLongFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[] result = new long[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsLong(a[i]);
        }

        return result;
    }

    /**
     * Maps a 2D double array to a 2D long array using the provided mapper function.
     * Each double element is transformed to a long value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 2D double array
     * @param mapper the function to transform each double to long
     * @return a 2D long array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> long[][] mapToLong(final double[][] a, final Throwables.DoubleToLongFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][] result = new long[len][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToLong(a[i], mapper);
        }

        return result;
    }

    /**
     * Maps a 3D double array to a 3D long array using the provided mapper function.
     * Each double element is transformed to a long value.
     *
     * @param <E> the type of exception that may be thrown by the mapper
     * @param a the input 3D double array
     * @param mapper the function to transform each double to long
     * @return a 3D long array with mapped values, or null if input is null
     * @throws E if the mapper function throws an exception
     */
    public static <E extends Exception> long[][][] mapToLong(final double[][][] a, final Throwables.DoubleToLongFunction<E> mapper) throws E {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][][] result = new long[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = mapToLong(a[i], mapper);
        }

        return result;
    }

    /**
     * Prints a 1D object array to the console and returns the printed string.
     * Handles null arrays and empty arrays appropriately.
     *
     * <p>Example usage:
     * <pre>{@code
     * Object[] arr = {"Hello", "World", 123};
     * String output = println(arr);
     * // Prints and returns: [Hello, World, 123]
     * }</pre>
     *
     * @param a the object array to print
     * @return the string representation that was printed
     */
    public static String println(final Object[] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            return N.println(N.toString(a));
        }
    }

    /**
     * Prints a 2D object array to the console with proper formatting and returns the printed string.
     * Uses the internal formatter for 2D arrays.
     *
     * @param a the 2D object array to print
     * @return the string representation that was printed
     */
    public static String println(final Object[][] a) {
        return ff.println(a);
    }

    /**
     * Prints a 3D object array to the console with proper formatting and returns the printed string.
     * Uses the internal formatter for 3D arrays.
     *
     * @param a the 3D object array to print
     * @return the string representation that was printed
     */
    public static String println(final Object[][][] a) {
        return fff.println(a);
    }

    /**
     * Updates all elements in a boolean array using the provided unary operator.
     * Each element is replaced with the result of applying the operator.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[] arr = {true, false, true};
     * updateAll(arr, b -> !b);
     * // arr is now: {false, true, false}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the operator
     * @param a the boolean array to update
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final boolean[] a, final Throwables.BooleanUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsBoolean(a[i]);
        }
    }

    /**
     * Updates all elements in a 2D boolean array using the provided unary operator.
     * Each element in every sub-array is replaced with the result of applying the operator.
     *
     * @param <E> the type of exception that may be thrown by the operator
     * @param a the 2D boolean array to update
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final boolean[][] a, final Throwables.BooleanUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final boolean[] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Updates all elements in a 3D boolean array using the provided unary operator.
     * Each element in every sub-array is replaced with the result of applying the operator.
     *
     * @param <E> the type of exception that may be thrown by the operator
     * @param a the 3D boolean array to update
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final boolean[][][] a, final Throwables.BooleanUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final boolean[][] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Replaces all elements in a boolean array that match the predicate with a new value.
     * Elements that don't match the predicate remain unchanged.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[] arr = {true, false, true, false};
     * replaceIf(arr, b -> b == true, false);
     * // arr is now: {false, false, false, false}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the predicate
     * @param a the boolean array to modify
     * @param predicate the condition to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final boolean[] a, final Throwables.BooleanPredicate<E> predicate, final boolean newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
            }
        }
    }

    /**
     * Replaces all elements in a 2D boolean array that match the predicate with a new value.
     * Elements that don't match the predicate remain unchanged.
     *
     * @param <E> the type of exception that may be thrown by the predicate
     * @param a the 2D boolean array to modify
     * @param predicate the condition to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final boolean[][] a, final Throwables.BooleanPredicate<E> predicate, final boolean newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final boolean[] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Replaces all elements in a 3D boolean array that match the predicate with a new value.
     * Elements that don't match the predicate remain unchanged.
     *
     * @param <E> the type of exception that may be thrown by the predicate
     * @param a the 3D boolean array to modify
     * @param predicate the condition to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final boolean[][][] a, final Throwables.BooleanPredicate<E> predicate, final boolean newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final boolean[][] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Reshapes a one-dimensional boolean array into a two-dimensional boolean array with the specified number of columns.
     * The last row may have fewer elements if the total elements don't divide evenly.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[] arr = {true, false, true, false, true};
     * boolean[][] reshaped = reshape(arr, 2);
     * // Result: {{true, false}, {true, false}, {true}}
     * }</pre>
     *
     * @param a the one-dimensional boolean array to reshape
     * @param cols the number of columns for the reshaped array
     * @return a two-dimensional boolean array with the specified number of columns
     * @throws IllegalArgumentException if the number of columns is less than or equal to zero
     */
    public static boolean[][] reshape(final boolean[] a, final int cols) throws IllegalArgumentException {
        checkMForReshape(cols);

        if (N.isEmpty(a)) {
            return new boolean[0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, cols, RoundingMode.CEILING);
        final boolean[][] c = new boolean[n][];

        for (int i = 0, from = 0; i < n; i++, from += cols) {
            c[i] = N.copyOfRange(a, from, from + N.min(len - from, cols));
        }

        return c;
    }

    /**
     * Reshapes a one-dimensional boolean array into a three-dimensional boolean array with the specified number of rows and columns.
     * The array is divided into blocks of size rows  cols.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[] arr = {true, false, true, false, true, false};
     * boolean[][][] reshaped = reshape(arr, 2, 2);
     * // Result: {{{true, false}, {true, false}}, {{true, false}}}
     * }</pre>
     *
     * @param a the one-dimensional boolean array to reshape
     * @param rows the number of rows for the reshaped subarray
     * @param cols the number of columns for the reshaped subarray
     * @return a three-dimensional boolean array with the specified number of rows and columns
     * @throws IllegalArgumentException if the number of rows or columns is less than or equal to zero
     */
    public static boolean[][][] reshape(final boolean[] a, final int rows, final int cols) throws IllegalArgumentException {
        checkMAndLForReshape(rows, cols);

        if (N.isEmpty(a)) {
            return new boolean[0][0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, rows * cols, RoundingMode.CEILING);
        final boolean[][][] c = new boolean[n][][];

        for (int i = 0, from = 0; i < n; i++) {
            c[i] = new boolean[N.min(rows, Numbers.divide(len - from, cols, RoundingMode.CEILING))][];

            for (int j = 0, y = c[i].length; j < y; j++, from += cols) {
                c[i][j] = N.copyOfRange(a, from, from + N.min(len - from, cols));
            }
        }

        return c;
    }

    /**
     * Flattens a 2D boolean array into a 1D boolean array.
     * All elements from all sub-arrays are combined into a single array.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[][] arr = {{true, false}, {true}, {false, true}};
     * boolean[] flattened = flatten(arr);
     * // Result: {true, false, true, false, true}
     * }</pre>
     *
     * @param a the 2D boolean array to flatten
     * @return a 1D boolean array containing all elements, or empty array if input is null/empty
     */
    public static boolean[] flatten(final boolean[][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_BOOLEAN_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final boolean[] c = new boolean[count];
        int from = 0;

        for (final boolean[] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            N.copy(element, 0, c, from, element.length);

            from += element.length;
        }

        return c;
    }

    /**
     * Flattens a 3D boolean array into a 1D boolean array.
     * All elements from all sub-arrays are combined into a single array.
     *
     * @param a the 3D boolean array to flatten
     * @return a 1D boolean array containing all elements, or empty array if input is null/empty
     */
    public static boolean[] flatten(final boolean[][][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_BOOLEAN_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final boolean[] c = new boolean[count];
        int from = 0;

        for (final boolean[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final boolean[] booleans : element) {
                if (N.isEmpty(booleans)) {
                    continue;
                }

                N.copy(booleans, 0, c, from, booleans.length);

                from += booleans.length;
            }
        }

        return c;
    }

    /**
     * Flattens a 2D boolean array, applies an operation to the flattened array, then sets the values back.
     * This is useful for operations that need to be applied to all elements regardless of structure.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[][] arr = {{true, false}, {false, true}};
     * flatOp(arr, t -> Arrays.sort(t)); // Sorts all elements
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the operation
     * @param a the 2D boolean array to operate on
     * @param op the operation to apply to the flattened array
     * @throws E if the operation throws an exception
     */
    public static <E extends Exception> void flatOp(final boolean[][] a, final Throwables.Consumer<? super boolean[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final boolean[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final boolean[] e : a) {
            if (N.notEmpty(e)) {
                N.copy(tmp, idx, e, 0, e.length);
                idx += e.length;
            }
        }
    }

    /**
     * Flattens a 3D boolean array, applies an operation to the flattened array, then sets the values back.
     * This is useful for operations that need to be applied to all elements regardless of structure.
     *
     * @param <E> the type of exception that may be thrown by the operation
     * @param a the 3D boolean array to operate on
     * @param op the operation to apply to the flattened array
     * @throws E if the operation throws an exception
     */
    public static <E extends Exception> void flatOp(final boolean[][][] a, final Throwables.Consumer<? super boolean[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final boolean[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final boolean[][] e : a) {
            if (N.notEmpty(e)) {
                for (final boolean[] ee : e) {
                    if (N.notEmpty(ee)) {
                        N.copy(tmp, idx, ee, 0, ee.length);
                        idx += ee.length;
                    }
                }
            }
        }
    }

    /**
     * Combines two boolean arrays element-wise using the provided zip function.
     * The result array length is the minimum of the two input array lengths.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[] a = {true, false, true};
     * boolean[] b = {false, false, true};
     * boolean[] result = zip(a, b, (x, y) -> x && y);
     * // Result: {false, false, true}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first boolean array
     * @param b the second boolean array
     * @param zipFunction the function to combine elements from both arrays
     * @return a new boolean array containing the combined elements
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[] zip(final boolean[] a, final boolean[] b, final Throwables.BooleanBiFunction<Boolean, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final boolean[] result = new boolean[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        return result;
    }

    /**
     * Combines two boolean arrays element-wise using the provided zip function, with default values for missing elements.
     * When arrays have different lengths, the default values are used for the shorter array.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[] a = {true, false, true};
     * boolean[] b = {false, true};
     * boolean[] result = zip(a, b, false, true, (x, y) -> x || y);
     * // Result: {true, true, true} (third element: true || true)
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first boolean array
     * @param b the second boolean array
     * @param valueForNoneA the default value to use when array a is shorter
     * @param valueForNoneB the default value to use when array b is shorter
     * @param zipFunction the function to combine elements from both arrays
     * @return a new boolean array with length equal to the maximum of the input arrays
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[] zip(final boolean[] a, final boolean[] b, final boolean valueForNoneA, final boolean valueForNoneB,
            final Throwables.BooleanBiFunction<Boolean, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return zip(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Internal helper method for zip operation with specified result length.
     * Combines two boolean arrays using the provided function and default values.
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param len the desired length of the result array
     * @param a the first boolean array
     * @param b the second boolean array
     * @param valueForNoneA the default value for array a
     * @param valueForNoneB the default value for array b
     * @param zipFunction the combining function
     * @return a new boolean array of the specified length
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> boolean[] zip(final int len, final boolean[] a, final boolean[] b, final boolean valueForNoneA,
            final boolean valueForNoneB, final Throwables.BooleanBiFunction<Boolean, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final boolean[] result = new boolean[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zipFunction.apply(valueForNoneA, b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zipFunction.apply(a[i], valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zipFunction.apply(valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Combines three boolean arrays element-wise using the provided zip function.
     * The result array length is the minimum of the three input array lengths.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[] a = {true, false, true};
     * boolean[] b = {false, true, false};
     * boolean[] c = {true, true, false};
     * boolean[] result = zip(a, b, c, (x, y, z) -> x && y && z);
     * // Result: {false, false, false}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first boolean array
     * @param b the second boolean array
     * @param c the third boolean array
     * @param zipFunction the function to combine elements from all three arrays
     * @return a new boolean array containing the combined elements
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[] zip(final boolean[] a, final boolean[] b, final boolean[] c,
            final Throwables.BooleanTriFunction<Boolean, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final boolean[] result = new boolean[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Combines three boolean arrays element-wise using the provided zip function, with default values for missing elements.
     * When arrays have different lengths, the default values are used for the shorter arrays.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[] a = {true, false};
     * boolean[] b = {false};
     * boolean[] c = {true, true, false};
     * boolean[] result = zip(a, b, c, false, true, false, (x, y, z) -> x || y || z);
     * // Result: {true, true, false}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first boolean array
     * @param b the second boolean array
     * @param c the third boolean array
     * @param valueForNoneA the default value to use when array a is shorter
     * @param valueForNoneB the default value to use when array b is shorter
     * @param valueForNoneC the default value to use when array c is shorter
     * @param zipFunction the function to combine elements from all three arrays
     * @return a new boolean array with length equal to the maximum of the input arrays
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[] zip(final boolean[] a, final boolean[] b, final boolean[] c, final boolean valueForNoneA,
            final boolean valueForNoneB, final boolean valueForNoneC, final Throwables.BooleanTriFunction<Boolean, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return zip(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
    }

    /**
     * Internal helper method for zip operation with three arrays and specified result length.
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param len the desired length of the result array
     * @param a the first boolean array
     * @param b the second boolean array
     * @param c the third boolean array
     * @param valueForNoneA the default value for array a
     * @param valueForNoneB the default value for array b
     * @param valueForNoneC the default value for array c
     * @param zipFunction the combining function
     * @return a new boolean array of the specified length
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> boolean[] zip(final int len, final boolean[] a, final boolean[] b, final boolean[] c, final boolean valueForNoneA,
            final boolean valueForNoneB, final boolean valueForNoneC, final Throwables.BooleanTriFunction<Boolean, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final boolean[] result = new boolean[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Combines two 2D boolean arrays element-wise using the provided zip function.
     * The result array dimensions are the minimum of the two input array dimensions.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[][] a = {{true, false}, {false, true}};
     * boolean[][] b = {{false, true}, {true, false}};
     * boolean[][] result = zip(a, b, (x, y) -> x && y);
     * // Result: {{false, false}, {false, false}}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first 2D boolean array
     * @param b the second 2D boolean array
     * @param zipFunction the function to combine elements from both arrays
     * @return a new 2D boolean array containing the combined elements
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[][] zip(final boolean[][] a, final boolean[][] b, final Throwables.BooleanBiFunction<Boolean, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final boolean[][] result = new boolean[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines two 2D boolean arrays element-wise using the provided zip function, with default values for missing elements.
     * When arrays have different dimensions, the default values are used for the shorter arrays.
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first 2D boolean array
     * @param b the second 2D boolean array
     * @param valueForNoneA the default value to use when array a is shorter
     * @param valueForNoneB the default value to use when array b is shorter
     * @param zipFunction the function to combine elements from both arrays
     * @return a new 2D boolean array with dimensions equal to the maximum of the input arrays
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[][] zip(final boolean[][] a, final boolean[][] b, final boolean valueForNoneA, final boolean valueForNoneB,
            final Throwables.BooleanBiFunction<Boolean, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Internal helper method for 2D zip operation with specified dimensions.
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param len the desired number of rows in the result
     * @param rowLen the desired number of columns in each row
     * @param a the first 2D boolean array
     * @param b the second 2D boolean array
     * @param valueForNoneA the default value for array a
     * @param valueForNoneB the default value for array b
     * @param zipFunction the combining function
     * @return a new 2D boolean array of the specified dimensions
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> boolean[][] zip(final int len, final int rowLen, final boolean[][] a, final boolean[][] b, final boolean valueForNoneA,
            final boolean valueForNoneB, final Throwables.BooleanBiFunction<Boolean, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final boolean[][] result = new boolean[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zip(rowLen, null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zip(rowLen, a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zip(rowLen, null, null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines three 2D boolean arrays element-wise using the provided zip function.
     * The result array dimensions are the minimum of the three input array dimensions.
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first 2D boolean array
     * @param b the second 2D boolean array
     * @param c the third 2D boolean array
     * @param zipFunction the function to combine elements from all three arrays
     * @return a new 2D boolean array containing the combined elements
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[][] zip(final boolean[][] a, final boolean[][] b, final boolean[][] c,
            final Throwables.BooleanTriFunction<Boolean, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final boolean[][] result = new boolean[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines three 2D boolean arrays element-wise using the provided zip function, with default values for missing elements.
     * When arrays have different dimensions, the default values are used for the shorter arrays.
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first 2D boolean array
     * @param b the second 2D boolean array
     * @param c the third 2D boolean array
     * @param valueForNoneA the default value to use when array a is shorter
     * @param valueForNoneB the default value to use when array b is shorter
     * @param valueForNoneC the default value to use when array c is shorter
     * @param zipFunction the function to combine elements from all three arrays
     * @return a new 2D boolean array with dimensions equal to the maximum of the input arrays
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[][] zip(final boolean[][] a, final boolean[][] b, final boolean[][] c, final boolean valueForNoneA,
            final boolean valueForNoneB, final boolean valueForNoneC, final Throwables.BooleanTriFunction<Boolean, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC, zipFunction);
    }

    /**
     * Internal helper method for 2D zip operation with three arrays and specified dimensions.
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param len the desired number of rows in the result
     * @param rowLen the desired number of columns in each row
     * @param a the first 2D boolean array
     * @param b the second 2D boolean array
     * @param c the third 2D boolean array
     * @param valueForNoneA the default value for array a
     * @param valueForNoneB the default value for array b
     * @param valueForNoneC the default value for array c
     * @param zipFunction the combining function
     * @return a new 2D boolean array of the specified dimensions
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> boolean[][] zip(final int len, final int rowLen, final boolean[][] a, final boolean[][] b, final boolean[][] c,
            final boolean valueForNoneA, final boolean valueForNoneB, final boolean valueForNoneC, final Throwables.BooleanTriFunction<Boolean, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final boolean[][] result = new boolean[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zip(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                        zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines two 3D boolean arrays element-wise using the provided zip function.
     * The result array dimensions are the minimum of the two input array dimensions.
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first 3D boolean array
     * @param b the second 3D boolean array
     * @param zipFunction the function to combine elements from both arrays
     * @return a new 3D boolean array containing the combined elements
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[][][] zip(final boolean[][][] a, final boolean[][][] b,
            final Throwables.BooleanBiFunction<Boolean, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final boolean[][][] result = new boolean[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines two 3D boolean arrays element-wise using the provided zip function, with default values for missing elements.
     * When arrays have different dimensions, the default values are used for the shorter arrays.
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first 3D boolean array
     * @param b the second 3D boolean array
     * @param valueForNoneA the default value to use when array a is shorter
     * @param valueForNoneB the default value to use when array b is shorter
     * @param zipFunction the function to combine elements from both arrays
     * @return a new 3D boolean array with dimensions equal to the maximum of the input arrays
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[][][] zip(final boolean[][][] a, final boolean[][][] b, final boolean valueForNoneA,
            final boolean valueForNoneB, final Throwables.BooleanBiFunction<Boolean, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final boolean[][][] result = new boolean[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = zip(a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = zip(null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = zip(a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines three 3D boolean arrays element-wise using the provided zip function.
     * The result array dimensions are the minimum of the three input array dimensions.
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first 3D boolean array
     * @param b the second 3D boolean array
     * @param c the third 3D boolean array
     * @param zipFunction the function to combine elements from all three arrays
     * @return a new 3D boolean array containing the combined elements
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[][][] zip(final boolean[][][] a, final boolean[][][] b, final boolean[][][] c,
            final Throwables.BooleanTriFunction<Boolean, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final boolean[][][] result = new boolean[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines three 3D boolean arrays element-wise using the provided zip function, with default values for missing elements.
     * When arrays have different dimensions, the default values are used for the shorter arrays.
     *
     * @param <E> the type of exception that may be thrown by the zip function
     * @param a the first 3D boolean array
     * @param b the second 3D boolean array
     * @param c the third 3D boolean array
     * @param valueForNoneA the default value to use when array a is shorter
     * @param valueForNoneB the default value to use when array b is shorter
     * @param valueForNoneC the default value to use when array c is shorter
     * @param zipFunction the function to combine elements from all three arrays
     * @return a new 3D boolean array with dimensions equal to the maximum of the input arrays
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> boolean[][][] zip(final boolean[][][] a, final boolean[][][] b, final boolean[][][] c, final boolean valueForNoneA,
            final boolean valueForNoneB, final boolean valueForNoneC, final Throwables.BooleanTriFunction<Boolean, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final boolean[][][] result = new boolean[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = zip(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = zip(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        return result;
    }

    /**
     * Calculates the total count of elements in a 2D boolean array.
     * Counts all elements across all sub-arrays, handling null sub-arrays gracefully.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[][] arr = {{true, false}, {true}, {false, true, false}};
     * long count = totalCountOfElements(arr);
     * // Result: 6
     * }</pre>
     *
     * @param a the 2D boolean array
     * @return the total number of elements across all sub-arrays
     */
    public static long totalCountOfElements(final boolean[][] a) {
        long count = 0;

        for (final boolean[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        return count;
    }

    /**
     * Calculates the total count of elements in a 3D boolean array.
     * Counts all elements across all sub-arrays at all levels, handling null arrays gracefully.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[][][] arr = {{{true, false}, {true}}, {{false}, {true, false}}};
     * long count = totalCountOfElements(arr);
     * // Result: 6
     * }</pre>
     *
     * @param a the 3D boolean array
     * @return the total number of elements across all sub-arrays
     */
    public static long totalCountOfElements(final boolean[][][] a) {
        long count = 0;

        for (final boolean[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final boolean[] booleans : element) {
                if (N.isEmpty(booleans)) {
                    continue;
                }

                count += booleans.length;
            }
        }

        return count;
    }

    /**
     * Finds the minimum length among all sub-arrays in a 2D boolean array.
     * Returns 0 if the input array is null or empty.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[][] arr = {{true, false, true}, {true}, {false, true}};
     * int minLen = minSubArrayLen(arr);
     * // Result: 1
     * }</pre>
     *
     * @param a the 2D boolean array
     * @return the minimum length of sub-arrays, or 0 if array is empty
     */
    public static int minSubArrayLen(final boolean[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int minLen = Integer.MAX_VALUE;

        for (final boolean[] ae : a) {
            minLen = N.min(minLen, ae == null ? 0 : ae.length);
        }

        return minLen;
    }

    /**
     * Finds the maximum length among all sub-arrays in a 2D boolean array.
     * Returns 0 if the input array is null or empty.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[][] arr = {{true, false, true}, {true}, {false, true}};
     * int maxLen = maxSubArrayLen(arr);
     * // Result: 3
     * }</pre>
     *
     * @param a the 2D boolean array
     * @return the maximum length of sub-arrays, or 0 if array is empty
     */
    public static int maxSubArrayLen(final boolean[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int maxLen = 0;

        for (final boolean[] ae : a) {
            maxLen = N.max(maxLen, ae == null ? 0 : ae.length);
        }

        return maxLen;
    }

    /**
     * Prints a 1D boolean array to the console and returns the printed string.
     * Handles null arrays and empty arrays appropriately.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[] arr = {true, false, true};
     * String output = println(arr);
     * // Prints and returns: [true, false, true]
     * }</pre>
     *
     * @param a the boolean array to print
     * @return the string representation that was printed
     */
    public static String println(final boolean[] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            return N.println(N.toString(a));
        }
    }

    /**
     * Prints a 2D boolean array to the console with proper formatting and returns the printed string.
     * Each sub-array is printed on a separate line with appropriate indentation.
     *
     * <p>Example usage:
     * <pre>{@code
     * boolean[][] arr = {{true, false}, {false, true}};
     * String output = println(arr);
     * // Prints: [[true, false],
     * //          [false, true]]
     * }</pre>
     *
     * @param a the 2D boolean array to print
     * @return the string representation that was printed
     */
    public static String println(final boolean[][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final boolean[] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(", ");
                            }

                            sb.append(ai[j]);
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Prints a 3D boolean array to the console with proper formatting and returns the printed string.
     * The array is formatted with multiple levels of indentation for readability.
     *
     * @param a the 3D boolean array to print
     * @return the string representation that was printed
     */
    public static String println(final boolean[][][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final boolean[][] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(',').append(IOUtil.LINE_SEPARATOR).append("  ");
                            }

                            if (ai[j] == null) {
                                sb.append("null");
                            } else if (ai[j].length == 0) {
                                sb.append("[]");
                            } else {
                                final boolean[] aij = ai[j];
                                sb.append('[');

                                for (int k = 0, aijLen = aij.length; k < aijLen; k++) {
                                    if (k > 0) {
                                        sb.append(", ");
                                    }

                                    sb.append(aij[k]);
                                }

                                sb.append(']');
                            }
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            N.println(str);

            return str;
        }
    }

    /**
     * Updates every element in the specified character array by applying a given operator.
     * This method modifies the array in-place.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[] array = {'a', 'b', 'c'};
     * N.updateAll(array, c -> (char) (c + 1));
     * // array becomes {'b', 'c', 'd'}
     * }</pre>
     *
     * @param <E> The type of exception that the operator may throw.
     * @param a The character array to update. The update is performed in-place.
     * @param operator The unary operator to apply to each element.
     * @throws E if the operator throws an exception.
     */
    public static <E extends Exception> void updateAll(final char[] a, final Throwables.CharUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsChar(a[i]);
        }
    }

    /**
     * Recursively updates every element in the 2D character array by applying a given operator.
     * The method iterates through each sub-array and applies the operator to every character.
     * The operation is performed in-place.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] array = {{'a', 'b'}, {'c'}};
     * N.updateAll(array, c -> Character.toUpperCase(c));
     * // array becomes {{'A', 'B'}, {'C'}}
     * }</pre>
     *
     * @param <E> The type of exception that the operator may throw.
     * @param a The 2D character array to update. The update is performed in-place.
     * @param operator The unary operator to apply to each element.
     * @throws E if the operator throws an exception.
     */
    public static <E extends Exception> void updateAll(final char[][] a, final Throwables.CharUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final char[] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Recursively updates every element in the 3D character array by applying a given operator.
     * It traverses the nested structure and applies the operator to each character.
     * The operation is performed in-place.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][][] array = {{{'a'}}, {{'b', 'c'}}};
     * N.updateAll(array, c -> '*');
     * // array becomes {{{'*'}}, {{'*', '*'}}}
     * }</pre>
     *
     * @param <E> The type of exception that the operator may throw.
     * @param a The 3D character array to update. The update is performed in-place.
     * @param operator The unary operator to apply to each element.
     * @throws E if the operator throws an exception.
     */
    public static <E extends Exception> void updateAll(final char[][][] a, final Throwables.CharUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final char[][] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Replaces each element of a character array with a new value if the element satisfies
     * the given predicate. The operation is performed in-place.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[] array = {'a', 'b', 'c', 'a'};
     * N.replaceIf(array, c -> c == 'a', 'x');
     * // array becomes {'x', 'b', 'c', 'x'}
     * }</pre>
     *
     * @param <E> The type of exception that the predicate may throw.
     * @param a The character array to modify.
     * @param predicate The condition to test for each element.
     * @param newValue The value to be placed in the array if the predicate is true.
     * @throws E if the predicate throws an exception.
     */
    public static <E extends Exception> void replaceIf(final char[] a, final Throwables.CharPredicate<E> predicate, final char newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
            }
        }
    }

    /**
     * Recursively replaces each element of a 2D character array with a new value if the
     * element satisfies the given predicate. The operation is performed in-place.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] array = {{'a', 'b'}, {'c', 'A'}};
     * N.replaceIf(array, c -> Character.isUpperCase(c), 'U');
     * // array becomes {{'a', 'b'}, {'c', 'U'}}
     * }</pre>
     *
     * @param <E> The type of exception that the predicate may throw.
     * @param a The 2D character array to modify.
     * @param predicate The condition to test for each element.
     * @param newValue The value to be placed in the array if the predicate is true.
     * @throws E if the predicate throws an exception.
     */
    public static <E extends Exception> void replaceIf(final char[][] a, final Throwables.CharPredicate<E> predicate, final char newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final char[] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Recursively replaces each element of a 3D character array with a new value if the
     * element satisfies the given predicate. The operation is performed in-place.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][][] array = {{{'a'}}, {{'B', 'c'}}};
     * N.replaceIf(array, c -> Character.isUpperCase(c), 'X');
     * // array becomes {{{'a'}}, {{'X', 'c'}}}
     * }</pre>
     *
     * @param <E> The type of exception that the predicate may throw.
     * @param a The 3D character array to modify.
     * @param predicate The condition to test for each element.
     * @param newValue The value to be placed in the array if the predicate is true.
     * @throws E if the predicate throws an exception.
     */
    public static <E extends Exception> void replaceIf(final char[][][] a, final Throwables.CharPredicate<E> predicate, final char newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final char[][] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Reshapes a 1D character array into a 2D character array with a specified number of columns.
     * If the length of the input array is not a multiple of {@code cols}, the last sub-array
     * will be shorter.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[] array = {'a', 'b', 'c', 'd', 'e'};
     * char[][] reshaped = N.reshape(array, 2);
     * // reshaped is {{'a', 'b'}, {'c', 'd'}, {'e'}}
     * }</pre>
     *
     * @param a The 1D character array to reshape.
     * @param cols The number of columns in the new 2D array.
     * @return A new 2D character array.
     * @throws IllegalArgumentException if {@code cols} is not positive.
     */
    public static char[][] reshape(final char[] a, final int cols) throws IllegalArgumentException {
        checkMForReshape(cols);

        if (N.isEmpty(a)) {
            return new char[0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, cols, RoundingMode.CEILING);
        final char[][] c = new char[n][];

        for (int i = 0, from = 0; i < n; i++, from += cols) {
            c[i] = N.copyOfRange(a, from, from + N.min(len - from, cols));
        }

        return c;
    }

    /**
     * Reshapes a 1D character array into a 3D character array with specified dimensions.
     * If the input array's length is not a perfect multiple of {@code rows * cols},
     * the last sub-arrays may be shorter.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[] array = {'a', 'b', 'c', 'd', 'e', 'f', 'g'};
     * char[][][] reshaped = N.reshape(array, 2, 2);
     * // reshaped is {{{'a', 'b'}, {'c', 'd'}}, {{'e', 'f'}, {'g'}}}
     * }</pre>
     *
     * @param a The 1D character array to reshape.
     * @param rows The number of rows in each 2D sub-array.
     * @param cols The number of columns in each 2D sub-array.
     * @return A new 3D character array.
     * @throws IllegalArgumentException if {@code rows} or {@code cols} are not positive.
     */
    public static char[][][] reshape(final char[] a, final int rows, final int cols) throws IllegalArgumentException {
        checkMAndLForReshape(rows, cols);

        if (N.isEmpty(a)) {
            return new char[0][0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, rows * cols, RoundingMode.CEILING);
        final char[][][] c = new char[n][][];

        for (int i = 0, from = 0; i < n; i++) {
            c[i] = new char[N.min(rows, Numbers.divide(len - from, cols, RoundingMode.CEILING))][];

            for (int j = 0, y = c[i].length; j < y; j++, from += cols) {
                c[i][j] = N.copyOfRange(a, from, from + N.min(len - from, cols));
            }
        }

        return c;
    }

    /**
     * Flattens a 2D character array into a new 1D character array by concatenating
     * all its sub-arrays. Null or empty sub-arrays are skipped.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] array = {{'a', 'b'}, null, {'c'}};
     * char[] flattened = N.flatten(array);
     * // flattened is {'a', 'b', 'c'}
     * }</pre>
     *
     * @param a The 2D character array to flatten.
     * @return A new 1D character array containing all elements from the input array.
     */
    public static char[] flatten(final char[][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_CHAR_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final char[] c = new char[count];
        int from = 0;

        for (final char[] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            N.copy(element, 0, c, from, element.length);

            from += element.length;
        }

        return c;
    }

    /**
     * Flattens a 3D character array into a new 1D character array by concatenating
     * all its innermost sub-arrays.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][][] array = {{{'a'}, {'b'}}, {{'c', 'd'}}};
     * char[] flattened = N.flatten(array);
     * // flattened is {'a', 'b', 'c', 'd'}
     * }</pre>
     *
     * @param a The 3D character array to flatten.
     * @return A new 1D character array containing all elements from the input array.
     */
    public static char[] flatten(final char[][][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_CHAR_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final char[] c = new char[count];
        int from = 0;

        for (final char[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final char[] chars : element) {
                if (N.isEmpty(chars)) {
                    continue;
                }

                N.copy(chars, 0, c, from, chars.length);

                from += chars.length;
            }
        }

        return c;
    }

    /**
     * Flattens a 2D array, performs a specified operation on the resulting 1D array,
     * and then copies the modified elements back into the original 2D array.
     * This allows for applying 1D array operations (like sorting) across a 2D structure.
     * The operation is performed in-place on the original 2D array.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] array = {{'c', 'a'}, {'b'}};
     * N.flatOp(array, t -> N.sort(t));
     * // array becomes {{'a', 'b'}, {'c'}}
     * }</pre>
     *
     * @param <E> The type of exception that the operation may throw.
     * @param a The 2D character array to operate on.
     * @param op The consumer operation to apply to the flattened array.
     * @throws E if the operation throws an exception.
     */
    public static <E extends Exception> void flatOp(final char[][] a, final Throwables.Consumer<? super char[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final char[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final char[] e : a) {
            if (N.notEmpty(e)) {
                N.copy(tmp, idx, e, 0, e.length);
                idx += e.length;
            }
        }
    }

    /**
     * Flattens a 3D array, performs a specified operation on the resulting 1D array,
     * and then copies the modified elements back into the original 3D array.
     * This is useful for applying 1D array operations across a 3D structure.
     * The operation is performed in-place on the original 3D array.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][][] array = {{{'d', 'a'}}, {{'c'}, {'b'}}};
     * N.flatOp(array, t -> N.sort(t));
     * // array becomes {{{'a', 'b'}}, {{'c'}, {'d'}}}
     * }</pre>
     *
     * @param <E> The type of exception that the operation may throw.
     * @param a The 3D character array to operate on.
     * @param op The consumer operation to apply to the flattened array.
     * @throws E if the operation throws an exception.
     */
    public static <E extends Exception> void flatOp(final char[][][] a, final Throwables.Consumer<? super char[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final char[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final char[][] e : a) {
            if (N.notEmpty(e)) {
                for (final char[] ee : e) {
                    if (N.notEmpty(ee)) {
                        N.copy(tmp, idx, ee, 0, ee.length);
                        idx += ee.length;
                    }
                }
            }
        }
    }

    /**
     * Combines two character arrays into a new array by applying a binary function to
     * corresponding elements. The resulting array's length is the minimum of the two
     * input array lengths.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[] a = {'a', 'b', 'c'};
     * char[] b = {'x', 'y'};
     * char[] result = N.zip(a, b, (c1, c2) -> c1 > c2 ? c1 : c2);
     * // result is {'x', 'y'}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first character array.
     * @param b The second character array.
     * @param zipFunction The function to apply to each pair of elements.
     * @return A new character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[] zip(final char[] a, final char[] b, final Throwables.CharBiFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final char[] result = new char[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        return result;
    }

    /**
     * Combines two character arrays into a new array by applying a binary function to
     * corresponding elements. If the arrays have different lengths, the shorter one is
     * padded with default values. The result length is the maximum of the input lengths.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[] a = {'a', 'b', 'c'};
     * char[] b = {'x'};
     * char[] result = N.zip(a, b, ' ', ' ', (c1, c2) -> c1);
     * // result is {'a', 'b', 'c'}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first character array.
     * @param b The second character array.
     * @param valueForNoneA The default value to use if array {@code a} is shorter.
     * @param valueForNoneB The default value to use if array {@code b} is shorter.
     * @param zipFunction The function to apply to each pair of elements.
     * @return A new character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[] zip(final char[] a, final char[] b, final char valueForNoneA, final char valueForNoneB,
            final Throwables.CharBiFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return zip(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Private helper for zipping two character arrays with padding.
     *
     * @param <E> Exception type.
     * @param len Target length of the result array.
     * @param a First array.
     * @param b Second array.
     * @param valueForNoneA Default for first array.
     * @param valueForNoneB Default for second array.
     * @param zipFunction Combining function.
     * @return The zipped array.
     * @throws E on zip function error.
     */
    private static <E extends Exception> char[] zip(final int len, final char[] a, final char[] b, final char valueForNoneA, final char valueForNoneB,
            final Throwables.CharBiFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final char[] result = new char[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zipFunction.apply(valueForNoneA, b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zipFunction.apply(a[i], valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zipFunction.apply(valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Combines three character arrays into a new array by applying a function to
     * corresponding elements. The resulting array's length is the minimum of the
     * three input array lengths.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[] a = {'a', 'b', 'c'};
     * char[] b = {'x', 'y', 'z'};
     * char[] c = {'1', '2'};
     * char[] result = N.zip(a, b, c, (c1, c2, c3) -> c3);
     * // result is {'1', '2'}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first character array.
     * @param b The second character array.
     * @param c The third character array.
     * @param zipFunction The function to apply to each triplet of elements.
     * @return A new character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[] zip(final char[] a, final char[] b, final char[] c, final Throwables.CharTriFunction<Character, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final char[] result = new char[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Combines three character arrays into a new array by applying a function to corresponding
     * elements. If arrays have different lengths, shorter ones are padded with default values.
     * The result length is the maximum of the input lengths.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[] a = {'a'};
     * char[] b = {'x', 'y'};
     * char[] c = {'1', '2', '3'};
     * char[] result = N.zip(a, b, c, ' ', ' ', ' ', (c1, c2, c3) -> c3);
     * // result is {'1', '2', '3'}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first character array.
     * @param b The second character array.
     * @param c The third character array.
     * @param valueForNoneA Default value for array {@code a}.
     * @param valueForNoneB Default value for array {@code b}.
     * @param valueForNoneC Default value for array {@code c}.
     * @param zipFunction The function to apply to each triplet of elements.
     * @return A new character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[] zip(final char[] a, final char[] b, final char[] c, final char valueForNoneA, final char valueForNoneB,
            final char valueForNoneC, final Throwables.CharTriFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return zip(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
    }

    /**
     * Private helper for zipping three character arrays with padding.
     *
     * @param <E> Exception type.
     * @param len Target length.
     * @param a First array.
     * @param b Second array.
     * @param c Third array.
     * @param valueForNoneA Default for a.
     * @param valueForNoneB Default for b.
     * @param valueForNoneC Default for c.
     * @param zipFunction Combining function.
     * @return The zipped array.
     * @throws E on zip function error.
     */
    private static <E extends Exception> char[] zip(final int len, final char[] a, final char[] b, final char[] c, final char valueForNoneA,
            final char valueForNoneB, final char valueForNoneC, final Throwables.CharTriFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final char[] result = new char[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Combines two 2D character arrays into a new 2D array by zipping corresponding sub-arrays.
     * The resulting 2D array's length is the minimum of the two input array lengths.
     * Inner arrays are also zipped to their minimum length.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] a = {{'a', 'b'}, {'c'}};
     * char[][] b = {{'X', 'Y', 'Z'}};
     * char[][] result = N.zip(a, b, (c1, c2) -> c1);
     * // result is {{'a', 'b'}}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first 2D character array.
     * @param b The second 2D character array.
     * @param zipFunction The function to apply to each pair of elements.
     * @return A new 2D character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[][] zip(final char[][] a, final char[][] b, final Throwables.CharBiFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final char[][] result = new char[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines two 2D character arrays with padding. If the arrays or their sub-arrays have
     * different lengths, they are padded with default values. The result dimensions are
     * the maximum of the input dimensions.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] a = {{'a'}, {'b', 'c'}};
     * char[][] b = {{'X', 'Y'}};
     * char[][] result = N.zip(a, b, ' ', ' ', (c1, c2) -> c2);
     * // result is {{'X', 'Y'}, {'Y', ' '}}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first 2D character array.
     * @param b The second 2D character array.
     * @param valueForNoneA The default value for missing elements.
     * @param valueForNoneB The default value for missing elements.
     * @param zipFunction The function to apply to each pair of elements.
     * @return A new 2D character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[][] zip(final char[][] a, final char[][] b, final char valueForNoneA, final char valueForNoneB,
            final Throwables.CharBiFunction<Character, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Private helper for zipping two 2D character arrays with padding.
     *
     * @param <E> Exception type.
     * @param len Target length.
     * @param rowLen Target row length.
     * @param a First array.
     * @param b Second array.
     * @param valueForNoneA Default for a.
     * @param valueForNoneB Default for b.
     * @param zipFunction Combining function.
     * @return The zipped array.
     * @throws E on zip function error.
     */
    private static <E extends Exception> char[][] zip(final int len, final int rowLen, final char[][] a, final char[][] b, final char valueForNoneA,
            final char valueForNoneB, final Throwables.CharBiFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final char[][] result = new char[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zip(rowLen, null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zip(rowLen, a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zip(rowLen, null, null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines three 2D character arrays into a new 2D array by zipping corresponding sub-arrays.
     * The resulting array's length is the minimum of the three input array lengths.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] a = {{'a'}, {'b'}};
     * char[][] b = {{'x'}, {'y'}};
     * char[][] c = {{'1'}};
     * char[][] result = N.zip(a, b, c, (c1, c2, c3) -> c3);
     * // result is {{'1'}}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first 2D character array.
     * @param b The second 2D character array.
     * @param c The third 2D character array.
     * @param zipFunction The function to apply to each triplet of elements.
     * @return A new 2D character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[][] zip(final char[][] a, final char[][] b, final char[][] c,
            final Throwables.CharTriFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final char[][] result = new char[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines three 2D character arrays with padding. If the arrays or their sub-arrays have
     * different lengths, they are padded with default values. The result dimensions are
     * the maximum of the input dimensions.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] a = {{'a'}};
     * char[][] b = {{'x', 'y'}};
     * char[][] c = {{'1'}, {'2'}};
     * char[][] result = N.zip(a, b, c, ' ', ' ', ' ', (c1, c2, c3) -> c2);
     * // result is {{'x', 'y'}, {' ', ' '}}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first 2D character array.
     * @param b The second 2D character array.
     * @param c The third 2D character array.
     * @param valueForNoneA Default value for missing elements.
     * @param valueForNoneB Default value for missing elements.
     * @param valueForNoneC Default value for missing elements.
     * @param zipFunction The function to apply to each triplet of elements.
     * @return A new 2D character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[][] zip(final char[][] a, final char[][] b, final char[][] c, final char valueForNoneA, final char valueForNoneB,
            final char valueForNoneC, final Throwables.CharTriFunction<Character, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC, zipFunction);
    }

    /**
     * Private helper for zipping three 2D character arrays with padding.
     *
     * @param <E> Exception type.
     * @param len Target length.
     * @param rowLen Target row length.
     * @param a First array.
     * @param b Second array.
     * @param c Third array.
     * @param valueForNoneA Default for a.
     * @param valueForNoneB Default for b.
     * @param valueForNoneC Default for c.
     * @param zipFunction Combining function.
     * @return The zipped array.
     * @throws E on zip function error.
     */
    private static <E extends Exception> char[][] zip(final int len, final int rowLen, final char[][] a, final char[][] b, final char[][] c,
            final char valueForNoneA, final char valueForNoneB, final char valueForNoneC, final Throwables.CharTriFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final char[][] result = new char[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zip(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                        zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines two 3D character arrays into a new 3D array by zipping corresponding sub-arrays.
     * The operation is recursive, and the dimensions of the result are the minimum of the
     * corresponding input dimensions.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][][] a = {{{'a'}}};
     * char[][][] b = {{{'x'}, {'y'}}};
     * char[][][] result = N.zip(a, b, (c1, c2) -> c1);
     * // result is {{{'a'}}}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first 3D character array.
     * @param b The second 3D character array.
     * @param zipFunction The function to apply to each pair of elements.
     * @return A new 3D character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[][][] zip(final char[][][] a, final char[][][] b, final Throwables.CharBiFunction<Character, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final char[][][] result = new char[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines two 3D character arrays with padding. If arrays or their sub-arrays have
     * different lengths, they are padded with default values. The result dimensions are
     * the maximum of the corresponding input dimensions.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][][] a = {{{'a'}}};
     * char[][][] b = {{{'x'}, {'y'}}};
     * char[][][] result = N.zip(a, b, ' ', ' ', (c1, c2) -> c2);
     * // result is {{{'x'}, {'y'}}}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first 3D character array.
     * @param b The second 3D character array.
     * @param valueForNoneA The default value for missing elements.
     * @param valueForNoneB The default value for missing elements.
     * @param zipFunction The function to apply to each pair of elements.
     * @return A new 3D character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[][][] zip(final char[][][] a, final char[][][] b, final char valueForNoneA, final char valueForNoneB,
            final Throwables.CharBiFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final char[][][] result = new char[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = zip(a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = zip(null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = zip(a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines three 3D character arrays into a new 3D array by zipping corresponding sub-arrays.
     * The operation is recursive, and the dimensions of the result are the minimum of the
     * corresponding input dimensions.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][][] a = {{{'a', 'b'}}};
     * char[][][] b = {{{'x', 'y'}}};
     * char[][][] c = {{{'1'}}};
     * char[][][] result = N.zip(a, b, c, (c1, c2, c3) -> c3);
     * // result is {{{'1'}}}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first 3D character array.
     * @param b The second 3D character array.
     * @param c The third 3D character array.
     * @param zipFunction The function to apply to each triplet of elements.
     * @return A new 3D character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[][][] zip(final char[][][] a, final char[][][] b, final char[][][] c,
            final Throwables.CharTriFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final char[][][] result = new char[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines three 3D character arrays with padding. If arrays or their sub-arrays have
     * different lengths, they are padded with default values. The result dimensions are
     * the maximum of the corresponding input dimensions.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][][] a = {{{'a'}}};
     * char[][][] b = {{{'x'}, {'y'}}};
     * char[][][] c = {};
     * char[][][] result = N.zip(a, b, c, ' ', ' ', ' ', (c1, c2, c3) -> c2);
     * // result is {{{'x'}, {'y'}}}
     * }</pre>
     *
     * @param <E> The type of exception the zip function might throw.
     * @param a The first 3D character array.
     * @param b The second 3D character array.
     * @param c The third 3D character array.
     * @param valueForNoneA The default value for missing elements.
     * @param valueForNoneB The default value for missing elements.
     * @param valueForNoneC The default value for missing elements.
     * @param zipFunction The function to apply to each triplet of elements.
     * @return A new 3D character array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> char[][][] zip(final char[][][] a, final char[][][] b, final char[][][] c, final char valueForNoneA,
            final char valueForNoneB, final char valueForNoneC, final Throwables.CharTriFunction<Character, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final char[][][] result = new char[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = zip(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = zip(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        return result;
    }

    /**
     * Calculates the total number of characters in a 2D character array.
     * It safely handles null sub-arrays.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] array = {{'a', 'b'}, {'c'}, null};
     * long count = N.totalCountOfElements(array);
     * // count is 3
     * }</pre>
     *
     * @param a The 2D character array to count.
     * @return The total number of character elements in the array.
     */
    public static long totalCountOfElements(final char[][] a) {
        long count = 0;

        for (final char[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        return count;
    }

    /**
     * Calculates the total number of characters in a 3D character array.
     * It safely handles null or empty sub-arrays at any level.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][][] array = {{{'a'}, {'b', 'c'}}, null, {{{'d'}}}};
     * long count = N.totalCountOfElements(array);
     * // count is 4
     * }</pre>
     *
     * @param a The 3D character array to count.
     * @return The total number of character elements in the array.
     */
    public static long totalCountOfElements(final char[][][] a) {
        long count = 0;

        for (final char[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final char[] chars : element) {
                if (N.isEmpty(chars)) {
                    continue;
                }

                count += chars.length;
            }
        }

        return count;
    }

    /**
     * Finds the minimum length among all sub-arrays in a 2D character array.
     * A null sub-array is considered to have a length of 0.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] array = {{'a', 'b'}, {'c'}, null};
     * int minLen = N.minSubArrayLen(array);
     * // minLen is 0
     * }</pre>
     *
     * @param a The 2D character array to inspect.
     * @return The minimum length of any sub-array. Returns 0 if the input array is empty or null.
     */
    public static int minSubArrayLen(final char[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int minLen = Integer.MAX_VALUE;

        for (final char[] ae : a) {
            minLen = N.min(minLen, ae == null ? 0 : ae.length);
        }

        return minLen;
    }

    /**
     * Finds the maximum length among all sub-arrays in a 2D character array.
     * A null sub-array is considered to have a length of 0.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] array = {{'a'}, {'b', 'c', 'd'}, null};
     * int maxLen = N.maxSubArrayLen(array);
     * // maxLen is 4
     * }</pre>
     *
     * @param a The 2D character array to inspect.
     * @return The maximum length of any sub-array. Returns 0 if the input array is empty or null.
     */
    public static int maxSubArrayLen(final char[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int maxLen = 0;

        for (final char[] ae : a) {
            maxLen = N.max(maxLen, ae == null ? 0 : ae.length);
        }

        return maxLen;
    }

    /**
     * Prints a 1D character array to the console and returns its string representation.
     * This method handles null and empty arrays gracefully.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[] arr = {'H', 'e', 'l', 'l', 'o'};
     * String output = N.println(arr);
     * // Prints "[H, e, l, l, o]" to console and returns it.
     * }</pre>
     *
     * @param a The character array to print.
     * @return The string representation that was printed.
     */
    public static String println(final char[] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            return N.println(N.toString(a));
        }
    }

    /**
     * Prints a 2D character array to the console and returns its string representation.
     * Each sub-array is represented as a string, separated by commas.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][] arr = {{'a', 'b'}, {'c', 'd'}};
     * String output = N.println(arr);
     * // Prints "[[a, b], [c, d]]" to console and returns it.
     * }</pre>
     *
     * @param a The 2D character array to print.
     * @return The string representation that was printed.
     */
    public static String println(final char[][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final char[] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(", ");
                            }

                            sb.append(ai[j]);
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Prints a 3D character array to the console and returns its string representation.
     * The array is formatted with newlines between the major elements for readability.
     *
     * <p>Example usage:
     * <pre>{@code
     * char[][][] arr = {{{'a'}}, {{'b', 'c'}}};
     * String output = N.println(arr);
     * // Prints a formatted string like "[[[a]], [[b, c]]]" and returns it.
     * }</pre>
     *
     * @param a The 3D character array to print.
     * @return The string representation that was printed.
     */
    public static String println(final char[][][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final char[][] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(',').append(IOUtil.LINE_SEPARATOR).append("  ");
                            }

                            if (ai[j] == null) {
                                sb.append("null");
                            } else if (ai[j].length == 0) {
                                sb.append("[]");
                            } else {
                                final char[] aij = ai[j];
                                sb.append('[');

                                for (int k = 0, aijLen = aij.length; k < aijLen; k++) {
                                    if (k > 0) {
                                        sb.append(", ");
                                    }

                                    sb.append(aij[k]);
                                }

                                sb.append(']');
                            }
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Adds a byte value to all elements in a byte array in-place.
     * If the array is null or empty, no operation is performed.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[] arr = {1, 2, 3};
     * plus(arr, (byte)5);
     * // arr is now: {6, 7, 8}
     * }</pre>
     *
     * @param a the byte array to modify
     * @param param the value to add to each element
     */
    public static void plus(final byte[] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] += param;
        }
    }

    /**
     * Adds a byte value to all elements in a 2D byte array in-place.
     * The operation is applied to every element in every sub-array.
     *
     * @param a the 2D byte array to modify
     * @param param the value to add to each element
     */
    public static void plus(final byte[][] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[] element : a) {
            plus(element, param);
        }
    }

    /**
     * Adds a byte value to all elements in a 3D byte array in-place.
     * The operation is applied to every element at all levels.
     *
     * @param a the 3D byte array to modify
     * @param param the value to add to each element
     */
    public static void plus(final byte[][][] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[][] element : a) {
            plus(element, param);
        }
    }

    /**
     * Subtracts a byte value from all elements in a byte array in-place.
     * If the array is null or empty, no operation is performed.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[] arr = {10, 20, 30};
     * minus(arr, (byte)5);
     * // arr is now: {5, 15, 25}
     * }</pre>
     *
     * @param a the byte array to modify
     * @param param the value to subtract from each element
     */
    public static void minus(final byte[] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] -= param;
        }
    }

    /**
     * Subtracts a byte value from all elements in a 2D byte array in-place.
     * The operation is applied to every element in every sub-array.
     *
     * @param a the 2D byte array to modify
     * @param param the value to subtract from each element
     */
    public static void minus(final byte[][] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[] element : a) {
            minus(element, param);
        }
    }

    /**
     * Subtracts a byte value from all elements in a 3D byte array in-place.
     * The operation is applied to every element at all levels.
     *
     * @param a the 3D byte array to modify
     * @param param the value to subtract from each element
     */
    public static void minus(final byte[][][] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[][] element : a) {
            minus(element, param);
        }
    }

    /**
     * Multiplies all elements in a byte array by a byte value in-place.
     * If the array is null or empty, no operation is performed.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[] arr = {2, 3, 4};
     * multipliedBy(arr, (byte)3);
     * // arr is now: {6, 9, 12}
     * }</pre>
     *
     * @param a the byte array to modify
     * @param param the value to multiply each element by
     */
    public static void multipliedBy(final byte[] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] *= param;
        }
    }

    /**
     * Multiplies all elements in a 2D byte array by a byte value in-place.
     * The operation is applied to every element in every sub-array.
     *
     * @param a the 2D byte array to modify
     * @param param the value to multiply each element by
     */
    public static void multipliedBy(final byte[][] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     * Multiplies all elements in a 3D byte array by a byte value in-place.
     * The operation is applied to every element at all levels.
     *
     * @param a the 3D byte array to modify
     * @param param the value to multiply each element by
     */
    public static void multipliedBy(final byte[][][] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[][] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     * Divides all elements in a byte array by a byte value in-place.
     * Integer division is used, truncating any remainder.
     * If the array is null or empty, no operation is performed.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[] arr = {10, 20, 30};
     * dividedBy(arr, (byte)5);
     * // arr is now: {2, 4, 6}
     * }</pre>
     *
     * @param a the byte array to modify
     * @param param the value to divide each element by
     * @throws ArithmeticException if param is zero
     */
    public static void dividedBy(final byte[] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] /= param;
        }
    }

    /**
     * Divides all elements in a 2D byte array by a byte value in-place.
     * The operation is applied to every element in every sub-array.
     *
     * @param a the 2D byte array to modify
     * @param param the value to divide each element by
     * @throws ArithmeticException if param is zero
     */
    public static void dividedBy(final byte[][] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     * Divides all elements in a 3D byte array by a byte value in-place.
     * The operation is applied to every element at all levels.
     *
     * @param a the 3D byte array to modify
     * @param param the value to divide each element by
     * @throws ArithmeticException if param is zero
     */
    public static void dividedBy(final byte[][][] a, final byte param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[][] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     * Updates all elements in a byte array using the provided unary operator.
     * Each element is replaced with the result of applying the operator.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[] arr = {1, 2, 3};
     * updateAll(arr, b -> (byte)(b * b));
     * // arr is now: {1, 4, 9}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the operator
     * @param a the byte array to update
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final byte[] a, final Throwables.ByteUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsByte(a[i]);
        }
    }

    /**
     * Updates all elements in a 2D byte array using the provided unary operator.
     * Each element in every sub-array is replaced with the result of applying the operator.
     *
     * @param <E> the type of exception that may be thrown by the operator
     * @param a the 2D byte array to update
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final byte[][] a, final Throwables.ByteUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Updates all elements in a 3D byte array using the provided unary operator.
     * Each element at all levels is replaced with the result of applying the operator.
     *
     * @param <E> the type of exception that may be thrown by the operator
     * @param a the 3D byte array to update
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final byte[][][] a, final Throwables.ByteUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[][] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Replaces all elements in a byte array that match the predicate with a new value.
     * Elements that don't match the predicate remain unchanged.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[] arr = {1, 2, 3, 2, 4};
     * replaceIf(arr, b -> b == 2, (byte)10);
     * // arr is now: {1, 10, 3, 10, 4}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the predicate
     * @param a the byte array to modify
     * @param predicate the condition to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final byte[] a, final Throwables.BytePredicate<E> predicate, final byte newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
            }
        }
    }

    /**
     * Replaces all elements in a 2D byte array that match the predicate with a new value.
     * Elements that don't match the predicate remain unchanged.
     *
     * @param <E> the type of exception that may be thrown by the predicate
     * @param a the 2D byte array to modify
     * @param predicate the condition to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final byte[][] a, final Throwables.BytePredicate<E> predicate, final byte newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Replaces all elements in a 3D byte array that match the predicate with a new value.
     * Elements that don't match the predicate remain unchanged.
     *
     * @param <E> the type of exception that may be thrown by the predicate
     * @param a the 3D byte array to modify
     * @param predicate the condition to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final byte[][][] a, final Throwables.BytePredicate<E> predicate, final byte newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final byte[][] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Flattens a 2D byte array into a 1D byte array.
     * All elements from all sub-arrays are combined into a single array.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[][] arr = {{1, 2}, {3}, {4, 5}};
     * byte[] flattened = flatten(arr);
     * // Result: {1, 2, 3, 4, 5}
     * }</pre>
     *
     * @param a the 2D byte array to flatten
     * @return a 1D byte array containing all elements, or empty array if input is null/empty
     */
    public static byte[] flatten(final byte[][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_BYTE_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final byte[] c = new byte[count];
        int from = 0;

        for (final byte[] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            N.copy(element, 0, c, from, element.length);

            from += element.length;
        }

        return c;
    }

    /**
     * Flattens a 3D byte array into a 1D byte array.
     * All elements from all sub-arrays are combined into a single array.
     *
     * @param a the 3D byte array to flatten
     * @return a 1D byte array containing all elements, or empty array if input is null/empty
     */
    public static byte[] flatten(final byte[][][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_BYTE_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final byte[] c = new byte[count];
        int from = 0;

        for (final byte[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final byte[] bytes : element) {
                if (N.isEmpty(bytes)) {
                    continue;
                }

                N.copy(bytes, 0, c, from, bytes.length);

                from += bytes.length;
            }
        }

        return c;
    }

    /**
     * Flattens a 2D byte array, applies an operation to the flattened array, then sets the values back.
     * This is useful for operations that need to be applied to all elements regardless of structure.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[][] arr = {{3, 1}, {4, 2}};
     * flatOp(arr, t -> Arrays.sort(t)); // Sorts all elements
     * // arr becomes: {{1, 2}, {3, 4}}
     * }</pre>
     *
     * @param <E> the type of exception that may be thrown by the operation
     * @param a the 2D byte array to operate on
     * @param op the operation to apply to the flattened array
     * @throws E if the operation throws an exception
     */
    public static <E extends Exception> void flatOp(final byte[][] a, final Throwables.Consumer<? super byte[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final byte[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final byte[] e : a) {
            if (N.notEmpty(e)) {
                N.copy(tmp, idx, e, 0, e.length);
                idx += e.length;
            }
        }
    }

    /**
     * Flattens a 3D byte array, applies an operation to the flattened array, then sets the values back.
     * This is useful for operations that need to be applied to all elements regardless of structure.
     *
     * @param <E> the type of exception that may be thrown by the operation
     * @param a the 3D byte array to operate on
     * @param op the operation to apply to the flattened array
     * @throws E if the operation throws an exception
     */
    public static <E extends Exception> void flatOp(final byte[][][] a, final Throwables.Consumer<? super byte[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final byte[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final byte[][] e : a) {
            if (N.notEmpty(e)) {
                for (final byte[] ee : e) {
                    if (N.notEmpty(ee)) {
                        N.copy(tmp, idx, ee, 0, ee.length);
                        idx += ee.length;
                    }
                }
            }
        }
    }

    /**
     * Reshapes a one-dimensional byte array into a two-dimensional byte array with the specified number of columns.
     * The last row may have fewer elements if the total elements don't divide evenly.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[] arr = {1, 2, 3, 4, 5};
     * byte[][] reshaped = reshape(arr, 2);
     * // Result: {{1, 2}, {3, 4}, {5}}
     * }</pre>
     *
     * @param a the one-dimensional byte array to reshape
     * @param cols the number of columns for the reshaped array
     * @return a two-dimensional byte array with the specified number of columns
     * @throws IllegalArgumentException if the number of columns is less than or equal to zero
     */
    public static byte[][] reshape(final byte[] a, final int cols) throws IllegalArgumentException {
        checkMForReshape(cols);

        if (N.isEmpty(a)) {
            return new byte[0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, cols, RoundingMode.CEILING);
        final byte[][] c = new byte[n][];

        for (int i = 0, from = 0; i < n; i++, from += cols) {
            c[i] = N.copyOfRange(a, from, from + N.min(len - from, cols));
        }

        return c;
    }

    /**
     * Reshapes a one-dimensional byte array into a three-dimensional byte array with the specified number of rows and columns.
     * The array is divided into blocks of size rows  cols.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[] arr = {1, 2, 3, 4, 5, 6};
     * byte[][][] reshaped = reshape(arr, 2, 2);
     * // Result: {{{1, 2}, {3, 4}}, {{5, 6}}}
     * }</pre>
     *
     * @param a the one-dimensional byte array to reshape
     * @param rows the number of rows for the reshaped subarray
     * @param cols the number of columns for the reshaped subarray
     * @return a three-dimensional byte array with the specified number of rows and columns
     * @throws IllegalArgumentException if the number of rows or columns is less than or equal to zero
     */
    public static byte[][][] reshape(final byte[] a, final int rows, final int cols) throws IllegalArgumentException {
        checkMAndLForReshape(rows, cols);

        if (N.isEmpty(a)) {
            return new byte[0][0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, rows * cols, RoundingMode.CEILING);
        final byte[][][] c = new byte[n][][];

        for (int i = 0, from = 0; i < n; i++) {
            c[i] = new byte[N.min(rows, Numbers.divide(len - from, cols, RoundingMode.CEILING))][];

            for (int j = 0, y = c[i].length; j < y; j++, from += cols) {
                c[i][j] = N.copyOfRange(a, from, from + N.min(len - from, cols));
            }
        }

        return c;
    }

    /**
     * Adds two byte arrays element-wise.
     * The result array length is the minimum of the two input array lengths.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[] a = {1, 2, 3};
     * byte[] b = {4, 5, 6};
     * byte[] result = add(a, b);
     * // Result: {5, 7, 9}
     * }</pre>
     *
     * @param a the first byte array
     * @param b the second byte array
     * @return a new byte array containing the element-wise sum
     */
    public static byte[] add(final byte[] a, final byte[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (byte) (a[i] + b[i]);
        }

        return result;
    }

    /**
     * Adds two byte arrays element-wise with default values for missing elements.
     * When arrays have different lengths, the default values are used for the shorter array.
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[] a = {1, 2, 3};
     * byte[] b = {4, 5};
     * byte[] result = add(a, b, (byte)0, (byte)10);
     * // Result: {5, 7, 13} (third element: 3 + 10)
     * }</pre>
     *
     * @param a the first byte array
     * @param b the second byte array
     * @param valueForNoneA the default value to use when array a is shorter
     * @param valueForNoneB the default value to use when array b is shorter
     * @return a new byte array with length equal to the maximum of the input arrays
     */
    public static byte[] add(final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return add(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for add operation with specified result length.
     *
     * @param len the desired length of the result array
     * @param a the first byte array
     * @param b the second byte array
     * @param valueForNoneA the default value for array a
     * @param valueForNoneB the default value for array b
     * @return a new byte array of the specified length
     */
    private static byte[] add(final int len, final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = (byte) (a[i] + b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = (byte) (valueForNoneA + b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = (byte) (a[i] + valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = (byte) (valueForNoneA + valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Adds three byte arrays element-wise.
     * The result array length is the minimum of the three input array lengths.
     *
     * @param a the first byte array
     * @param b the second byte array
     * @param c the third byte array
     * @return a new byte array containing the element-wise sum
     */
    public static byte[] add(final byte[] a, final byte[] b, final byte[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (byte) (a[i] + b[i] + c[i]);
        }

        return result;
    }

    /**
     * Adds three byte arrays element-wise with default values for missing elements.
     * When arrays have different lengths, the default values are used for the shorter arrays.
     *
     * @param a the first byte array
     * @param b the second byte array
     * @param c the third byte array
     * @param valueForNoneA the default value to use when array a is shorter
     * @param valueForNoneB the default value to use when array b is shorter
     * @param valueForNoneC the default value to use when array c is shorter
     * @return a new byte array with length equal to the maximum of the input arrays
     */
    public static byte[] add(final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA, final byte valueForNoneB, final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return add(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for add operation with three arrays and specified result length.
     *
     * @param len the desired length of the result array
     * @param a the first byte array
     * @param b the second byte array
     * @param c the third byte array
     * @param valueForNoneA the default value for array a
     * @param valueForNoneB the default value for array b
     * @param valueForNoneC the default value for array c
     * @return a new byte array of the specified length
     */
    private static byte[] add(final int len, final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = (byte) (a[i] + b[i] + c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (byte) ((i < lenA ? a[i] : valueForNoneA) + (i < lenB ? b[i] : valueForNoneB) + (i < lenC ? c[i] : valueForNoneC));
            }
        }

        return result;
    }

    /**
     * Adds two 2D byte arrays element-wise.
     * The result array dimensions are the minimum of the two input array dimensions.
     *
     * @param a the first 2D byte array
     * @param b the second 2D byte array
     * @return a new 2D byte array containing the element-wise sum
     */
    public static byte[][] add(final byte[][] a, final byte[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     * Adds two 2D byte arrays element-wise with default values for missing elements.
     * When arrays have different dimensions, the default values are used for the shorter arrays.
     *
     * @param a the first 2D byte array
     * @param b the second 2D byte array
     * @param valueForNoneA the default value to use when array a is shorter
     * @param valueForNoneB the default value to use when array b is shorter
     * @return a new 2D byte array with dimensions equal to the maximum of the input arrays
     */
    public static byte[][] add(final byte[][] a, final byte[][] b, final byte valueForNoneA, final byte valueForNoneB) {
        return add(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for 2D add operation with specified dimensions.
     *
     * @param len the desired number of rows in the result
     * @param rowLen the desired number of columns in each row
     * @param a the first 2D byte array
     * @param b the second 2D byte array
     * @param valueForNoneA the default value for array a
     * @param valueForNoneB the default value for array b
     * @return a new 2D byte array of the specified dimensions
     */
    private static byte[][] add(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = add(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = add(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = add(rowLen, (byte[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 2D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     *
     * <p>Example usage:
     * <pre>
     * byte[][] a = {{1, 2}, {3, 4}};
     * byte[][] b = {{5, 6}, {7, 8}};
     * byte[][] c = {{9, 10}, {11, 12}};
     * byte[][] result = Arrays.add(a, b, c); // {{15, 18}, {21, 24}}
     * </pre>
     *
     * @param a the first 2D byte array
     * @param b the second 2D byte array
     * @param c the third 2D byte array
     * @return a new 2D byte array containing the element-wise sum of the input arrays
     */
    public static byte[][] add(final byte[][] a, final byte[][] b, final byte[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 2D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * <p>Example usage:
     * <pre>
     * byte[][] a = {{1, 2}, {3, 4}};
     * byte[][] b = {{5, 6}};
     * byte[][] c = {{9}};
     * byte valueForNoneA = 0, valueForNoneB = 10, valueForNoneC = 20;
     * byte[][] result = Arrays.add(a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
     * // Result will use default values for missing elements
     * </pre>
     *
     * @param a the first 2D byte array
     * @param b the second 2D byte array
     * @param c the third 2D byte array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 2D byte array containing the element-wise sum with defaults applied
     */
    public static byte[][] add(final byte[][] a, final byte[][] b, final byte[][] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        return add(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC);
    }

    /**
     * Internal helper method for performing element-wise addition with specified dimensions.
     *
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the first 2D byte array
     * @param b the second 2D byte array
     * @param c the third 2D byte array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 2D byte array with specified dimensions containing the sum
     */
    private static byte[][] add(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte[][] c, final byte valueForNoneA,
            final byte valueForNoneB, final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = add(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of two 3D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     *
     * <p>Example usage:
     * <pre>
     * byte[][][] a = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}};
     * byte[][][] b = {{{9, 10}, {11, 12}}, {{13, 14}, {15, 16}}};
     * byte[][][] result = Arrays.add(a, b);
     * // Result: {{{10, 12}, {14, 16}}, {{18, 20}, {22, 24}}}
     * </pre>
     *
     * @param a the first 3D byte array
     * @param b the second 3D byte array
     * @return a new 3D byte array containing the element-wise sum of the input arrays
     */
    public static byte[][][] add(final byte[][][] a, final byte[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of two 3D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * <p>Example usage:
     * <pre>
     * byte[][][] a = {{{1, 2}}};
     * byte[][][] b = {{{3, 4}}, {{5, 6}}};
     * byte valueForNoneA = 10, valueForNoneB = 20;
     * byte[][][] result = Arrays.add(a, b, valueForNoneA, valueForNoneB);
     * // Second element of result uses default values
     * </pre>
     *
     * @param a the first 3D byte array
     * @param b the second 3D byte array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new 3D byte array containing the element-wise sum with defaults applied
     */
    public static byte[][][] add(final byte[][][] a, final byte[][][] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = add(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = add(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = add(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 3D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     *
     * @param a the first 3D byte array
     * @param b the second 3D byte array
     * @param c the third 3D byte array
     * @return a new 3D byte array containing the element-wise sum of the input arrays
     */
    public static byte[][][] add(final byte[][][] a, final byte[][][] b, final byte[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 3D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * @param a the first 3D byte array
     * @param b the second 3D byte array
     * @param c the third 3D byte array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 3D byte array containing the element-wise sum with defaults applied
     */
    public static byte[][][] add(final byte[][][] a, final byte[][][] b, final byte[][][] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = add(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = add(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 1D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {10, 20, 30};
     * byte[] b = {1, 2, 3};
     * byte[] result = Arrays.subtract(a, b); // {9, 18, 27}
     * </pre>
     *
     * @param a the minuend array
     * @param b the subtrahend array
     * @return a new byte array containing the element-wise difference (a[i] - b[i])
     */
    public static byte[] subtract(final byte[] a, final byte[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (byte) (a[i] - b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 1D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {10, 20};
     * byte[] b = {1, 2, 3};
     * byte valueForNoneA = 30, valueForNoneB = 5;
     * byte[] result = Arrays.subtract(a, b, valueForNoneA, valueForNoneB);
     * // Result: {9, 18, 25} where 25 = 30 - 5
     * </pre>
     *
     * @param a the minuend array
     * @param b the subtrahend array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new byte array containing the element-wise difference with defaults applied
     */
    public static byte[] subtract(final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return subtract(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for performing element-wise subtraction with specified length.
     *
     * @param len the target length of the result array
     * @param a the minuend array
     * @param b the subtrahend array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new byte array with specified length containing the difference
     */
    private static byte[] subtract(final int len, final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = (byte) (a[i] - b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = (byte) (valueForNoneA - b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = (byte) (a[i] - valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = (byte) (valueForNoneA - valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 1D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     * The operation performed is: a[i] - b[i] - c[i].
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {100, 90, 80};
     * byte[] b = {10, 20, 30};
     * byte[] c = {5, 10, 15};
     * byte[] result = Arrays.subtract(a, b, c); // {85, 60, 35}
     * </pre>
     *
     * @param a the minuend array
     * @param b the first subtrahend array
     * @param c the second subtrahend array
     * @return a new byte array containing the element-wise difference (a[i] - b[i] - c[i])
     */
    public static byte[] subtract(final byte[] a, final byte[] b, final byte[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (byte) (a[i] - b[i] - c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 1D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * @param a the minuend array
     * @param b the first subtrahend array
     * @param c the second subtrahend array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new byte array containing the element-wise difference with defaults applied
     */
    public static byte[] subtract(final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return subtract(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for performing element-wise subtraction of three arrays with specified length.
     *
     * @param len the target length of the result array
     * @param a the minuend array
     * @param b the first subtrahend array
     * @param c the second subtrahend array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new byte array with specified length containing the difference
     */
    private static byte[] subtract(final int len, final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = (byte) (a[i] - b[i] - c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (byte) ((i < lenA ? a[i] : valueForNoneA) - (i < lenB ? b[i] : valueForNoneB) - (i < lenC ? c[i] : valueForNoneC));
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 2D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     *
     * @param a the minuend 2D array
     * @param b the subtrahend 2D array
     * @return a new 2D byte array containing the element-wise difference
     */
    public static byte[][] subtract(final byte[][] a, final byte[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 2D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * @param a the minuend 2D array
     * @param b the subtrahend 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new 2D byte array containing the element-wise difference with defaults applied
     */
    public static byte[][] subtract(final byte[][] a, final byte[][] b, final byte valueForNoneA, final byte valueForNoneB) {
        return subtract(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for performing element-wise subtraction of 2D arrays with specified dimensions.
     *
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the minuend 2D array
     * @param b the subtrahend 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new 2D byte array with specified dimensions containing the difference
     */
    private static byte[][] subtract(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = subtract(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = subtract(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = subtract(rowLen, (byte[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 2D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     * The operation performed is: a[i][j] - b[i][j] - c[i][j].
     *
     * @param a the minuend 2D array
     * @param b the first subtrahend 2D array
     * @param c the second subtrahend 2D array
     * @return a new 2D byte array containing the element-wise difference
     */
    public static byte[][] subtract(final byte[][] a, final byte[][] b, final byte[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 2D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * @param a the minuend 2D array
     * @param b the first subtrahend 2D array
     * @param c the second subtrahend 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 2D byte array containing the element-wise difference with defaults applied
     */
    public static byte[][] subtract(final byte[][] a, final byte[][] b, final byte[][] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        return subtract(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for performing element-wise subtraction of three 2D arrays with specified dimensions.
     *
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the minuend 2D array
     * @param b the first subtrahend 2D array
     * @param c the second subtrahend 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 2D byte array with specified dimensions containing the difference
     */
    private static byte[][] subtract(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte[][] c, final byte valueForNoneA,
            final byte valueForNoneB, final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = subtract(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 3D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     *
     * @param a the minuend 3D array
     * @param b the subtrahend 3D array
     * @return a new 3D byte array containing the element-wise difference
     */
    public static byte[][][] subtract(final byte[][][] a, final byte[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 3D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * @param a the minuend 3D array
     * @param b the subtrahend 3D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new 3D byte array containing the element-wise difference with defaults applied
     */
    public static byte[][][] subtract(final byte[][][] a, final byte[][][] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = subtract(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = subtract(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = subtract(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 3D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     *
     * @param a the minuend 3D array
     * @param b the first subtrahend 3D array
     * @param c the second subtrahend 3D array
     * @return a new 3D byte array containing the element-wise difference
     */
    public static byte[][][] subtract(final byte[][][] a, final byte[][][] b, final byte[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 3D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * @param a the minuend 3D array
     * @param b the first subtrahend 3D array
     * @param c the second subtrahend 3D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 3D byte array containing the element-wise difference with defaults applied
     */
    public static byte[][][] subtract(final byte[][][] a, final byte[][][] b, final byte[][][] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = subtract(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = subtract(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 1D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {2, 3, 4};
     * byte[] b = {5, 6, 7};
     * byte[] result = Arrays.multipliedBy(a, b); // {10, 18, 28}
     * </pre>
     *
     * @param a the first multiplicand array
     * @param b the second multiplicand array
     * @return a new byte array containing the element-wise product (a[i] * b[i])
     */
    public static byte[] multipliedBy(final byte[] a, final byte[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (byte) (a[i] * b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 1D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {2, 3};
     * byte[] b = {4, 5, 6};
     * byte valueForNoneA = 1, valueForNoneB = 10;
     * byte[] result = Arrays.multipliedBy(a, b, valueForNoneA, valueForNoneB);
     * // Result: {8, 15, 6} where 6 = 1 * 6
     * </pre>
     *
     * @param a the first multiplicand array
     * @param b the second multiplicand array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new byte array containing the element-wise product with defaults applied
     */
    public static byte[] multipliedBy(final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return multipliedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for performing element-wise multiplication with specified length.
     *
     * @param len the target length of the result array
     * @param a the first multiplicand array
     * @param b the second multiplicand array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new byte array with specified length containing the product
     */
    private static byte[] multipliedBy(final int len, final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = (byte) (a[i] * b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = (byte) (valueForNoneA * b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = (byte) (a[i] * valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = (byte) (valueForNoneA * valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 1D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {2, 3, 4};
     * byte[] b = {1, 2, 3};
     * byte[] c = {5, 2, 1};
     * byte[] result = Arrays.multipliedBy(a, b, c); // {10, 12, 12}
     * </pre>
     *
     * @param a the first multiplicand array
     * @param b the second multiplicand array
     * @param c the third multiplicand array
     * @return a new byte array containing the element-wise product (a[i] * b[i] * c[i])
     */
    public static byte[] multipliedBy(final byte[] a, final byte[] b, final byte[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (byte) (a[i] * b[i] * c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 1D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * @param a the first multiplicand array
     * @param b the second multiplicand array
     * @param c the third multiplicand array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new byte array containing the element-wise product with defaults applied
     */
    public static byte[] multipliedBy(final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return multipliedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for performing element-wise multiplication of three arrays with specified length.
     *
     * @param len the target length of the result array
     * @param a the first multiplicand array
     * @param b the second multiplicand array
     * @param c the third multiplicand array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new byte array with specified length containing the product
     */
    private static byte[] multipliedBy(final int len, final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = (byte) (a[i] * b[i] * c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (byte) ((i < lenA ? a[i] : valueForNoneA) * (i < lenB ? b[i] : valueForNoneB) * (i < lenC ? c[i] : valueForNoneC));
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 2D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     *
     * @param a the first multiplicand 2D array
     * @param b the second multiplicand 2D array
     * @return a new 2D byte array containing the element-wise product
     */
    public static byte[][] multipliedBy(final byte[][] a, final byte[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 2D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * @param a the first multiplicand 2D array
     * @param b the second multiplicand 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new 2D byte array containing the element-wise product with defaults applied
     */
    public static byte[][] multipliedBy(final byte[][] a, final byte[][] b, final byte valueForNoneA, final byte valueForNoneB) {
        return multipliedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for performing element-wise multiplication of 2D arrays with specified dimensions.
     *
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the first multiplicand 2D array
     * @param b the second multiplicand 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new 2D byte array with specified dimensions containing the product
     */
    private static byte[][] multipliedBy(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte valueForNoneA,
            final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = multipliedBy(rowLen, (byte[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 2D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     *
     * @param a the first multiplicand 2D array
     * @param b the second multiplicand 2D array
     * @param c the third multiplicand 2D array
     * @return a new 2D byte array containing the element-wise product
     */
    public static byte[][] multipliedBy(final byte[][] a, final byte[][] b, final byte[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 2D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values.
     *
     * @param a the first multiplicand 2D array
     * @param b the second multiplicand 2D array
     * @param c the third multiplicand 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 2D byte array containing the element-wise product with defaults applied
     */
    public static byte[][] multipliedBy(final byte[][] a, final byte[][] b, final byte[][] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        return multipliedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for performing element-wise multiplication of three 2D arrays with specified dimensions.
     *
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the first multiplicand 2D array
     * @param b the second multiplicand 2D array
     * @param c the third multiplicand 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 2D byte array with specified dimensions containing the product
     */
    private static byte[][] multipliedBy(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte[][] c, final byte valueForNoneA,
            final byte valueForNoneB, final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = multipliedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 3D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     *
     * <p>Example usage:
     * <pre>
     * byte[][][] a = {{{2, 3}, {4, 5}}, {{6, 7}, {8, 9}}};
     * byte[][][] b = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}};
     * byte[][][] result = Arrays.multipliedBy(a, b);
     * // Result: {{{2, 6}, {12, 20}}, {{30, 42}, {56, 72}}}
     * </pre>
     *
     * @param a the first multiplicand 3D array
     * @param b the second multiplicand 3D array
     * @return a new 3D byte array containing the element-wise product
     */
    public static byte[][][] multipliedBy(final byte[][][] a, final byte[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 3D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values before multiplication.
     *
     * <p>Example usage:
     * <pre>
     * byte[][][] a = {{{2, 3}}};
     * byte[][][] b = {{{4, 5}}, {{6, 7}}};
     * byte valueForNoneA = 1, valueForNoneB = 10;
     * byte[][][] result = Arrays.multipliedBy(a, b, valueForNoneA, valueForNoneB);
     * // Second element uses default values: {{1 * 6, 1 * 7}}
     * </pre>
     *
     * @param a the first multiplicand 3D array
     * @param b the second multiplicand 3D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new 3D byte array containing the element-wise product with defaults applied
     */
    public static byte[][][] multipliedBy(final byte[][][] a, final byte[][][] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = multipliedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = multipliedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 3D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     *
     * <p>Example usage:
     * <pre>
     * byte[][][] a = {{{2, 3}}, {{4, 5}}};
     * byte[][][] b = {{{1, 2}}, {{3, 4}}};
     * byte[][][] c = {{{5, 6}}, {{7, 8}}};
     * byte[][][] result = Arrays.multipliedBy(a, b, c);
     * // Result: {{{10, 36}}, {{84, 160}}}
     * </pre>
     *
     * @param a the first multiplicand 3D array
     * @param b the second multiplicand 3D array
     * @param c the third multiplicand 3D array
     * @return a new 3D byte array containing the element-wise product (a * b * c)
     */
    public static byte[][][] multipliedBy(final byte[][][] a, final byte[][][] b, final byte[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 3D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values before multiplication.
     *
     * @param a the first multiplicand 3D array
     * @param b the second multiplicand 3D array
     * @param c the third multiplicand 3D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 3D byte array containing the element-wise product with defaults applied
     */
    public static byte[][][] multipliedBy(final byte[][][] a, final byte[][][] b, final byte[][][] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = multipliedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 1D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     * Note: Integer division is performed, truncating any decimal values.
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {10, 20, 30};
     * byte[] b = {2, 4, 5};
     * byte[] result = Arrays.dividedBy(a, b); // {5, 5, 6}
     * </pre>
     *
     * @param a the dividend array
     * @param b the divisor array
     * @return a new byte array containing the element-wise quotient (a[i] / b[i])
     * @throws ArithmeticException if any element in b is zero
     */
    public static byte[] dividedBy(final byte[] a, final byte[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (byte) (a[i] / b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 1D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values before division.
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {20, 30};
     * byte[] b = {2, 3, 4};
     * byte valueForNoneA = 40, valueForNoneB = 5;
     * byte[] result = Arrays.dividedBy(a, b, valueForNoneA, valueForNoneB);
     * // Result: {10, 10, 10} where last element is 40/4
     * </pre>
     *
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new byte array containing the element-wise quotient with defaults applied
     * @throws ArithmeticException if any divisor (including default) is zero
     */
    public static byte[] dividedBy(final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for performing element-wise division with specified length.
     *
     * @param len the target length of the result array
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new byte array with specified length containing the quotient
     */
    private static byte[] dividedBy(final int len, final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = (byte) (a[i] / b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = (byte) (valueForNoneA / b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = (byte) (a[i] / valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = (byte) (valueForNoneA / valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 1D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     * The operation performed is: a[i] / b[i] / c[i].
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {120, 100, 80};
     * byte[] b = {2, 4, 5};
     * byte[] c = {3, 5, 2};
     * byte[] result = Arrays.dividedBy(a, b, c); // {20, 5, 8}
     * </pre>
     *
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @return a new byte array containing the element-wise quotient (a[i] / b[i] / c[i])
     * @throws ArithmeticException if any element in b or c is zero
     */
    public static byte[] dividedBy(final byte[] a, final byte[] b, final byte[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (byte) (a[i] / b[i] / c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of three 1D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values before division.
     *
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new byte array containing the element-wise quotient with defaults applied
     * @throws ArithmeticException if any divisor (including defaults) is zero
     */
    public static byte[] dividedBy(final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for performing element-wise division of three arrays with specified length.
     *
     * @param len the target length of the result array
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new byte array with specified length containing the quotient
     */
    private static byte[] dividedBy(final int len, final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = (byte) (a[i] / b[i] / c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (byte) ((i < lenA ? a[i] : valueForNoneA) / (i < lenB ? b[i] : valueForNoneB) / (i < lenC ? c[i] : valueForNoneC));
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of two 2D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     *
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @return a new 2D byte array containing the element-wise quotient
     * @throws ArithmeticException if any element in b is zero
     */
    public static byte[][] dividedBy(final byte[][] a, final byte[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 2D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values before division.
     *
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new 2D byte array containing the element-wise quotient with defaults applied
     * @throws ArithmeticException if any divisor (including defaults) is zero
     */
    public static byte[][] dividedBy(final byte[][] a, final byte[][] b, final byte valueForNoneA, final byte valueForNoneB) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for performing element-wise division of 2D arrays with specified dimensions.
     *
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new 2D byte array with specified dimensions containing the quotient
     */
    private static byte[][] dividedBy(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, (byte[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 2D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     * The operation performed is: a[i][j] / b[i][j] / c[i][j].
     *
     * @param a the dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @return a new 2D byte array containing the element-wise quotient
     * @throws ArithmeticException if any element in b or c is zero
     */
    public static byte[][] dividedBy(final byte[][] a, final byte[][] b, final byte[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of three 2D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values before division.
     *
     * @param a the dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 2D byte array containing the element-wise quotient with defaults applied
     * @throws ArithmeticException if any divisor (including defaults) is zero
     */
    public static byte[][] dividedBy(final byte[][] a, final byte[][] b, final byte[][] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for performing element-wise division of three 2D arrays with specified dimensions.
     *
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 2D byte array with specified dimensions containing the quotient
     */
    private static byte[][] dividedBy(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte[][] c, final byte valueForNoneA,
            final byte valueForNoneB, final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of two 3D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     *
     * @param a the dividend 3D array
     * @param b the divisor 3D array
     * @return a new 3D byte array containing the element-wise quotient
     * @throws ArithmeticException if any element in b is zero
     */
    public static byte[][][] dividedBy(final byte[][][] a, final byte[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 3D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values before division.
     *
     * @param a the dividend 3D array
     * @param b the divisor 3D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @return a new 3D byte array containing the element-wise quotient with defaults applied
     * @throws ArithmeticException if any divisor (including defaults) is zero
     */
    public static byte[][][] dividedBy(final byte[][][] a, final byte[][][] b, final byte valueForNoneA, final byte valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 3D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     * The operation performed is: a[i][j][k] / b[i][j][k] / c[i][j][k].
     *
     * @param a the dividend 3D array
     * @param b the first divisor 3D array
     * @param c the second divisor 3D array
     * @return a new 3D byte array containing the element-wise quotient
     * @throws ArithmeticException if any element in b or c is zero
     */
    public static byte[][][] dividedBy(final byte[][][] a, final byte[][][] b, final byte[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of three 3D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values before division.
     *
     * @param a the dividend 3D array
     * @param b the first divisor 3D array
     * @param c the second divisor 3D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @return a new 3D byte array containing the element-wise quotient with defaults applied
     * @throws ArithmeticException if any divisor (including defaults) is zero
     */
    public static byte[][][] dividedBy(final byte[][][] a, final byte[][][] b, final byte[][][] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 1D byte arrays with zero-safe handling.
     * When a divisor is zero, the provided default value is used instead.
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {10, 20, 30};
     * byte[] b = {2, 0, 5};
     * byte defaultValueForZero = 1;
     * byte[] result = Arrays.dividedBy(a, b, defaultValueForZero); // {5, 20, 6}
     * </pre>
     *
     * @param a the dividend array
     * @param b the divisor array
     * @param defaultValueForZero value to use when divisor is zero
     * @return a new byte array containing the element-wise quotient with zero handling
     */
    public static byte[] dividedBy(final byte[] a, final byte[] b, final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (byte) (a[i] / (b[i] == 0 ? defaultValueForZero : b[i]));
        }

        return result;
    }

    /**
     * Performs element-wise division of two 1D byte arrays with default values and zero-safe handling.
     * The result array length is the maximum length between the two input arrays.
     * When a divisor is zero, the provided defaultValueForZero is used instead.
     *
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param defaultValueForZero value to use when divisor is zero
     * @return a new byte array containing the element-wise quotient with defaults and zero handling
     */
    public static byte[] dividedBy(final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB, final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     * Internal helper method for performing element-wise division with zero handling and specified length.
     *
     * @param len the target length of the result array
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param defaultValueForZero value to use when divisor is zero
     * @return a new byte array with specified length containing the quotient
     */
    private static byte[] dividedBy(final int len, final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB,
            final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = (byte) (a[i] / (b[i] == 0 ? defaultValueForZero : b[i]));
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = (byte) (valueForNoneA / (b[i] == 0 ? defaultValueForZero : b[i]));
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = (byte) (a[i] / valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = (byte) (valueForNoneA / valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 1D byte arrays with zero-safe handling.
     * When a divisor is zero, the provided default value is used instead.
     * The operation performed is: a[i] / (b[i] or default) / (c[i] or default).
     *
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param defaultValueForZero value to use when any divisor is zero
     * @return a new byte array containing the element-wise quotient with zero handling
     */
    public static byte[] dividedBy(final byte[] a, final byte[] b, final byte[] c, final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (byte) (a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]));
        }

        return result;
    }

    /**
     * Performs element-wise division of three 1D byte arrays with default values and zero-safe handling.
     * The result array length is the maximum length among the three input arrays.
     * When a divisor is zero, the provided defaultValueForZero is used instead.
     *
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param defaultValueForZero value to use when any divisor is zero
     * @return a new byte array containing the element-wise quotient with defaults and zero handling
     */
    public static byte[] dividedBy(final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA, final byte valueForNoneB, final byte valueForNoneC,
            final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     * Internal helper method for performing element-wise division of three arrays with zero handling.
     *
     * @param len the target length of the result array
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param defaultValueForZero value to use when any divisor is zero
     * @return a new byte array with specified length containing the quotient
     */
    private static byte[] dividedBy(final int len, final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC, final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = (byte) (a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]));
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (byte) ((i < lenA ? a[i] : valueForNoneA) / (i < lenB ? (b[i] == 0 ? defaultValueForZero : b[i]) : valueForNoneB)
                        / (i < lenC ? (c[i] == 0 ? defaultValueForZero : c[i]) : valueForNoneC));
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of two 2D byte arrays with zero-safe handling.
     * When a divisor is zero, the provided default value is used instead.
     *
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @param defaultValueForZero value to use when divisor is zero
     * @return a new 2D byte array containing the element-wise quotient with zero handling
     */
    public static byte[][] dividedBy(final byte[][] a, final byte[][] b, final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 2D byte arrays with default values and zero-safe handling.
     * The result array length is the maximum length between the two input arrays.
     * When a divisor is zero, the provided defaultValueForZero is used instead.
     *
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param defaultValueForZero value to use when divisor is zero
     * @return a new 2D byte array containing the element-wise quotient with defaults and zero handling
     */
    public static byte[][] dividedBy(final byte[][] a, final byte[][] b, final byte valueForNoneA, final byte valueForNoneB, final byte defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     * Internal helper method for performing element-wise division of 2D arrays with zero handling.
     *
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param defaultValueForZero value to use when divisor is zero
     * @return a new 2D byte array with specified dimensions containing the quotient
     */
    private static byte[][] dividedBy(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte valueForNoneA, final byte valueForNoneB,
            final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, (byte[]) null, null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 2D byte arrays with zero-safe handling.
     * When a divisor is zero, the provided default value is used instead.
     *
     * @param a the dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @param defaultValueForZero value to use when any divisor is zero
     * @return a new 2D byte array containing the element-wise quotient with zero handling
     */
    public static byte[][] dividedBy(final byte[][] a, final byte[][] b, final byte[][] c, final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs element-wise division of three 2D byte arrays with default values and zero-safe handling.
     * The result array length is the maximum length among the three input arrays.
     * When a divisor is zero, the provided defaultValueForZero is used instead.
     *
     * @param a the dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param defaultValueForZero value to use when any divisor is zero
     * @return a new 2D byte array containing the element-wise quotient with defaults and zero handling
     */
    public static byte[][] dividedBy(final byte[][] a, final byte[][] b, final byte[][] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC, final byte defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     * Internal helper method for performing element-wise division of three 2D arrays with zero handling.
     *
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param defaultValueForZero value to use when any divisor is zero
     * @return a new 2D byte array with specified dimensions containing the quotient
     */
    private static byte[][] dividedBy(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte[][] c, final byte valueForNoneA,
            final byte valueForNoneB, final byte valueForNoneC, final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of two 3D byte arrays with zero-safe handling.
     * When a divisor is zero, the provided default value is used instead.
     *
     * @param a the dividend 3D array
     * @param b the divisor 3D array
     * @param defaultValueForZero value to use when divisor is zero
     * @return a new 3D byte array containing the element-wise quotient with zero handling
     */
    public static byte[][][] dividedBy(final byte[][][] a, final byte[][][] b, final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 3D byte arrays with default values and zero-safe handling.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values before division.
     * When a divisor is zero, the provided defaultValueForZero is used instead.
     *
     * <p>Example usage:
     * <pre>
     * byte[][][] a = {{{20, 30}}, {{40, 50}}};
     * byte[][][] b = {{{2, 0}}};
     * byte valueForNoneA = 60, valueForNoneB = 3, defaultValueForZero = 1;
     * byte[][][] result = Arrays.dividedBy(a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
     * // Result: {{{10, 30}}, {{20, 16}}} where second element uses default values
     * </pre>
     *
     * @param a the dividend 3D array
     * @param b the divisor 3D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param defaultValueForZero value to use when divisor is zero
     * @return a new 3D byte array containing the element-wise quotient with defaults and zero handling
     */
    public static byte[][][] dividedBy(final byte[][][] a, final byte[][][] b, final byte valueForNoneA, final byte valueForNoneB,
            final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 3D byte arrays with zero-safe handling.
     * The result array length is the minimum length among the three input arrays.
     * When a divisor is zero, the provided default value is used instead.
     * The operation performed is: a[i][j][k] / (b[i][j][k] or default) / (c[i][j][k] or default).
     *
     * @param a the dividend 3D array
     * @param b the first divisor 3D array
     * @param c the second divisor 3D array
     * @param defaultValueForZero value to use when any divisor is zero
     * @return a new 3D byte array containing the element-wise quotient with zero handling
     */
    public static byte[][][] dividedBy(final byte[][][] a, final byte[][][] b, final byte[][][] c, final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs element-wise division of three 3D byte arrays with default values and zero-safe handling.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values before division.
     * When a divisor is zero, the provided defaultValueForZero is used instead.
     *
     * @param a the dividend 3D array
     * @param b the first divisor 3D array
     * @param c the second divisor 3D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param defaultValueForZero value to use when any divisor is zero
     * @return a new 3D byte array containing the element-wise quotient with defaults and zero handling
     */
    public static byte[][][] dividedBy(final byte[][][] a, final byte[][][] b, final byte[][][] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC, final byte defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                    defaultValueForZero);
        }

        return result;
    }

    /**
     * Applies a binary function element-wise to two 1D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     * This is a generic zip operation that allows custom operations on array elements.
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {10, 20, 30};
     * byte[] b = {3, 4, 5};
     * Throwables.ByteBiFunction<Byte, RuntimeException> maxFunc = (x, y) -> (byte)Math.max(x, y);
     * byte[] result = Arrays.zip(a, b, maxFunc); // {10, 20, 30}
     * </pre>
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param zipFunction the binary function to apply to corresponding elements
     * @return a new byte array containing the results of applying the function
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[] zip(final byte[] a, final byte[] b, final Throwables.ByteBiFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        return result;
    }

    /**
     * Applies a binary function element-wise to two 1D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values before applying the function.
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {10, 20};
     * byte[] b = {3, 4, 5};
     * byte valueForNoneA = 0, valueForNoneB = 1;
     * Throwables.ByteBiFunction<Byte, RuntimeException> addFunc = (x, y) -> (byte)(x + y);
     * byte[] result = Arrays.zip(a, b, valueForNoneA, valueForNoneB, addFunc);
     * // Result: {13, 24, 5} where last element is 0 + 5
     * </pre>
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param zipFunction the binary function to apply to corresponding elements
     * @return a new byte array containing the results with defaults applied
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[] zip(final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB,
            final Throwables.ByteBiFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return zip(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Internal helper method for applying a binary function with specified length.
     *
     * @param <E> the type of exception the zip function may throw
     * @param len the target length of the result array
     * @param a the first input array
     * @param b the second input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param zipFunction the binary function to apply
     * @return a new byte array with specified length containing the function results
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> byte[] zip(final int len, final byte[] a, final byte[] b, final byte valueForNoneA, final byte valueForNoneB,
            final Throwables.ByteBiFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zipFunction.apply(valueForNoneA, b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zipFunction.apply(a[i], valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zipFunction.apply(valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Applies a ternary function element-wise to three 1D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     * This is a generic zip operation that allows custom operations on array elements.
     *
     * <p>Example usage:
     * <pre>
     * byte[] a = {10, 20, 30};
     * byte[] b = {3, 4, 5};
     * byte[] c = {1, 2, 3};
     * Throwables.ByteTriFunction<Byte, RuntimeException> medianFunc =
     *     (x, y, z) -> (byte)Arrays.sort(new byte[]{x, y, z})[1];
     * byte[] result = Arrays.zip(a, b, c, medianFunc); // {3, 4, 5}
     * </pre>
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param c the third input array
     * @param zipFunction the ternary function to apply to corresponding elements
     * @return a new byte array containing the results of applying the function
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[] zip(final byte[] a, final byte[] b, final byte[] c, final Throwables.ByteTriFunction<Byte, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Applies a ternary function element-wise to three 1D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values before applying the function.
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param c the third input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param zipFunction the ternary function to apply to corresponding elements
     * @return a new byte array containing the results with defaults applied
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[] zip(final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC, final Throwables.ByteTriFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return zip(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
    }

    /**
     * Internal helper method for applying a ternary function with specified length.
     *
     * @param <E> the type of exception the zip function may throw
     * @param len the target length of the result array
     * @param a the first input array
     * @param b the second input array
     * @param c the third input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param zipFunction the ternary function to apply
     * @return a new byte array with specified length containing the function results
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> byte[] zip(final int len, final byte[] a, final byte[] b, final byte[] c, final byte valueForNoneA,
            final byte valueForNoneB, final byte valueForNoneC, final Throwables.ByteTriFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[] result = new byte[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Applies a binary function element-wise to two 2D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     * The function is applied to each corresponding sub-array pair.
     *
     * <p>Example usage:
     * <pre>
     * byte[][] a = {{1, 2}, {3, 4}};
     * byte[][] b = {{5, 6}, {7, 8}};
     * Throwables.ByteBiFunction<Byte, RuntimeException> multiplyFunc = (x, y) -> (byte)(x * y);
     * byte[][] result = Arrays.zip(a, b, multiplyFunc); // {{5, 12}, {21, 32}}
     * </pre>
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input 2D array
     * @param b the second input 2D array
     * @param zipFunction the binary function to apply to corresponding elements
     * @return a new 2D byte array containing the results of applying the function
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[][] zip(final byte[][] a, final byte[][] b, final Throwables.ByteBiFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a binary function element-wise to two 2D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values before applying the function.
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input 2D array
     * @param b the second input 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param zipFunction the binary function to apply to corresponding elements
     * @return a new 2D byte array containing the results with defaults applied
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[][] zip(final byte[][] a, final byte[][] b, final byte valueForNoneA, final byte valueForNoneB,
            final Throwables.ByteBiFunction<Byte, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Internal helper method for applying a binary function to 2D arrays with specified dimensions.
     *
     * @param <E> the type of exception the zip function may throw
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the first input 2D array
     * @param b the second input 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param zipFunction the binary function to apply
     * @return a new 2D byte array with specified dimensions containing the function results
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> byte[][] zip(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte valueForNoneA,
            final byte valueForNoneB, final Throwables.ByteBiFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zip(rowLen, null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zip(rowLen, a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zip(rowLen, null, null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Applies a ternary function element-wise to three 2D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     * The function is applied to each corresponding sub-array triple.
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input 2D array
     * @param b the second input 2D array
     * @param c the third input 2D array
     * @param zipFunction the ternary function to apply to corresponding elements
     * @return a new 2D byte array containing the results of applying the function
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[][] zip(final byte[][] a, final byte[][] b, final byte[][] c,
            final Throwables.ByteTriFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a ternary function element-wise to three 2D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values before applying the function.
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input 2D array
     * @param b the second input 2D array
     * @param c the third input 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param zipFunction the ternary function to apply to corresponding elements
     * @return a new 2D byte array containing the results with defaults applied
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[][] zip(final byte[][] a, final byte[][] b, final byte[][] c, final byte valueForNoneA, final byte valueForNoneB,
            final byte valueForNoneC, final Throwables.ByteTriFunction<Byte, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC, zipFunction);
    }

    /**
     * Internal helper method for applying a ternary function to 2D arrays with specified dimensions.
     *
     * @param <E> the type of exception the zip function may throw
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the first input 2D array
     * @param b the second input 2D array
     * @param c the third input 2D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param zipFunction the ternary function to apply
     * @return a new 2D byte array with specified dimensions containing the function results
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> byte[][] zip(final int len, final int rowLen, final byte[][] a, final byte[][] b, final byte[][] c,
            final byte valueForNoneA, final byte valueForNoneB, final byte valueForNoneC, final Throwables.ByteTriFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][] result = new byte[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zip(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                        zipFunction);
            }
        }

        return result;
    }

    /**
     * Applies a binary function element-wise to two 3D byte arrays.
     * The result array length is the minimum length between the two input arrays.
     * The function is applied to each corresponding 2D sub-array pair.
     *
     * <p>Example usage:
     * <pre>
     * byte[][][] a = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}};
     * byte[][][] b = {{{2, 2}, {2, 2}}, {{3, 3}, {3, 3}}};
     * Throwables.ByteBiFunction<Byte, RuntimeException> powerFunc = (x, y) -> (byte)Math.pow(x, y);
     * byte[][][] result = Arrays.zip(a, b, powerFunc);
     * </pre>
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input 3D array
     * @param b the second input 3D array
     * @param zipFunction the binary function to apply to corresponding elements
     * @return a new 3D byte array containing the results of applying the function
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[][][] zip(final byte[][][] a, final byte[][][] b, final Throwables.ByteBiFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a binary function element-wise to two 3D byte arrays with default values.
     * The result array length is the maximum length between the two input arrays.
     * Missing elements are replaced with the provided default values before applying the function.
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input 3D array
     * @param b the second input 3D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param zipFunction the binary function to apply to corresponding elements
     * @return a new 3D byte array containing the results with defaults applied
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[][][] zip(final byte[][][] a, final byte[][][] b, final byte valueForNoneA, final byte valueForNoneB,
            final Throwables.ByteBiFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final byte[][][] result = new byte[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = zip(a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = zip(null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = zip(a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Applies a ternary function element-wise to three 3D byte arrays.
     * The result array length is the minimum length among the three input arrays.
     * The function is applied to each corresponding 2D sub-array triple.
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input 3D array
     * @param b the second input 3D array
     * @param c the third input 3D array
     * @param zipFunction the ternary function to apply to corresponding elements
     * @return a new 3D byte array containing the results of applying the function
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[][][] zip(final byte[][][] a, final byte[][][] b, final byte[][][] c,
            final Throwables.ByteTriFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a ternary function element-wise to three 3D byte arrays with default values.
     * The result array length is the maximum length among the three input arrays.
     * Missing elements are replaced with the provided default values before applying the function.
     *
     * <p>This method provides the most flexible way to combine three 3D arrays using a custom
     * operation, handling arrays of different sizes gracefully by using default values for
     * missing elements.
     *
     * @param <E> the type of exception the zip function may throw
     * @param a the first input 3D array
     * @param b the second input 3D array
     * @param c the third input 3D array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param zipFunction the ternary function to apply to corresponding elements
     * @return a new 3D byte array containing the results with defaults applied
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> byte[][][] zip(final byte[][][] a, final byte[][][] b, final byte[][][] c, final byte valueForNoneA,
            final byte valueForNoneB, final byte valueForNoneC, final Throwables.ByteTriFunction<Byte, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final byte[][][] result = new byte[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = zip(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = zip(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        return result;
    }

    /**
     * Calculates the total count of elements in a two-dimensional byte array.
     * Null sub-arrays are treated as having zero elements.
     *
     * <pre>
     * byte[][] array = {{1, 2, 3}, null, {4, 5}};
     * long count = totalCountOfElements(array); // returns 5
     * </pre>
     *
     * @param a the two-dimensional byte array
     * @return the total count of all elements across all sub-arrays
     */
    public static long totalCountOfElements(final byte[][] a) {
        long count = 0;

        for (final byte[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        return count;
    }

    /**
     * Calculates the total count of elements in a three-dimensional byte array.
     * Empty or null sub-arrays at any level are skipped.
     *
     * <pre>
     * byte[][][] array = {{{1, 2}, {3}}, {{4, 5, 6}}};
     * long count = totalCountOfElements(array); // returns 6
     * </pre>
     *
     * @param a the three-dimensional byte array
     * @return the total count of all elements across all sub-arrays
     */
    public static long totalCountOfElements(final byte[][][] a) {
        long count = 0;

        for (final byte[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final byte[] bytes : element) {
                if (N.isEmpty(bytes)) {
                    continue;
                }

                count += bytes.length;
            }
        }

        return count;
    }

    /**
     * Finds the minimum length among all sub-arrays in a two-dimensional byte array.
     * Null sub-arrays are treated as having length 0.
     * Returns 0 if the input array is null or empty.
     *
     * <pre>
     * byte[][] array = {{1, 2, 3}, {4, 5}, {6, 7, 8, 9}};
     * int minLen = minSubArrayLen(array); // returns 2
     * </pre>
     *
     * @param a the two-dimensional byte array to analyze
     * @return the minimum sub-array length, or 0 if the array is empty
     */
    public static int minSubArrayLen(final byte[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int minLen = Integer.MAX_VALUE;

        for (final byte[] ae : a) {
            minLen = N.min(minLen, ae == null ? 0 : ae.length);
        }

        return minLen;
    }

    /**
     * Finds the maximum length among all sub-arrays in a two-dimensional byte array.
     * Null sub-arrays are treated as having length 0.
     * Returns 0 if the input array is null or empty.
     *
     * <pre>
     * byte[][] array = {{1, 2}, null, {3, 4, 5, 6}};
     * int maxLen = maxSubArrayLen(array); // returns 4
     * </pre>
     *
     * @param a the two-dimensional byte array to analyze
     * @return the maximum sub-array length, or 0 if the array is empty
     */
    public static int maxSubArrayLen(final byte[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int maxLen = 0;

        for (final byte[] ae : a) {
            maxLen = N.max(maxLen, ae == null ? 0 : ae.length);
        }

        return maxLen;
    }

    /**
     * Prints a one-dimensional byte array to the console and returns the printed string.
     * Handles null arrays and empty arrays appropriately.
     *
     * <pre>
     * byte[] array = {1, 2, 3};
     * String output = println(array); // prints and returns "[1, 2, 3]"
     * </pre>
     *
     * @param a the byte array to print
     * @return the string representation that was printed
     */
    public static String println(final byte[] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            return N.println(N.toString(a));
        }
    }

    /**
     * Prints a two-dimensional byte array to the console with proper formatting.
     * Each sub-array is printed on the same line, separated by the ARRAY_PRINT_SEPARATOR.
     *
     * <pre>
     * byte[][] array = {{1, 2}, {3, 4, 5}};
     * String output = println(array); // prints formatted 2D array
     * </pre>
     *
     * @param a the two-dimensional byte array to print
     * @return the string representation that was printed
     */
    public static String println(final byte[][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final byte[] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(", ");
                            }

                            sb.append(ai[j]);
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Prints a three-dimensional byte array to the console with multi-line formatting.
     * Sub-arrays at different levels are properly indented for readability.
     *
     * <pre>
     * byte[][][] array = {{{1, 2}, {3}}, {{4, 5}}};
     * String output = println(array); // prints formatted 3D array
     * </pre>
     *
     * @param a the three-dimensional byte array to print
     * @return the string representation that was printed
     */
    public static String println(final byte[][][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final byte[][] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(',').append(IOUtil.LINE_SEPARATOR).append("  ");
                            }

                            if (ai[j] == null) {
                                sb.append("null");
                            } else if (ai[j].length == 0) {
                                sb.append("[]");
                            } else {
                                final byte[] aij = ai[j];
                                sb.append('[');

                                for (int k = 0, aijLen = aij.length; k < aijLen; k++) {
                                    if (k > 0) {
                                        sb.append(", ");
                                    }

                                    sb.append(aij[k]);
                                }

                                sb.append(']');
                            }
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Adds a constant value to all elements in a short array in-place.
     * Does nothing if the array is null or empty.
     *
     * <pre>
     * short[] array = {1, 2, 3};
     * plus(array, (short)5); // array becomes {6, 7, 8}
     * </pre>
     *
     * @param a the array to modify
     * @param param the value to add to each element
     */
    public static void plus(final short[] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] += param;
        }
    }

    /**
     * Adds a constant value to all elements in a two-dimensional short array in-place.
     * Applies the operation to all sub-arrays.
     *
     * <pre>
     * short[][] array = {{1, 2}, {3, 4}};
     * plus(array, (short)10); // array becomes {{11, 12}, {13, 14}}
     * </pre>
     *
     * @param a the two-dimensional array to modify
     * @param param the value to add to each element
     */
    public static void plus(final short[][] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[] element : a) {
            plus(element, param);
        }
    }

    /**
     * Adds a constant value to all elements in a three-dimensional short array in-place.
     * Applies the operation recursively to all sub-arrays.
     *
     * <pre>
     * short[][][] array = {{{1, 2}}, {{3, 4}}};
     * plus(array, (short)5); // all elements increased by 5
     * </pre>
     *
     * @param a the three-dimensional array to modify
     * @param param the value to add to each element
     */
    public static void plus(final short[][][] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[][] element : a) {
            plus(element, param);
        }
    }

    /**
     * Subtracts a constant value from all elements in a short array in-place.
     * Does nothing if the array is null or empty.
     *
     * <pre>
     * short[] array = {10, 20, 30};
     * minus(array, (short)5); // array becomes {5, 15, 25}
     * </pre>
     *
     * @param a the array to modify
     * @param param the value to subtract from each element
     */
    public static void minus(final short[] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] -= param;
        }
    }

    /**
     * Subtracts a constant value from all elements in a two-dimensional short array in-place.
     * Applies the operation to all sub-arrays.
     *
     * <pre>
     * short[][] array = {{10, 20}, {30, 40}};
     * minus(array, (short)5); // array becomes {{5, 15}, {25, 35}}
     * </pre>
     *
     * @param a the two-dimensional array to modify
     * @param param the value to subtract from each element
     */
    public static void minus(final short[][] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[] element : a) {
            minus(element, param);
        }
    }

    /**
     * Subtracts a constant value from all elements in a three-dimensional short array in-place.
     * Applies the operation recursively to all sub-arrays.
     *
     * <pre>
     * short[][][] array = {{{10, 20}}, {{30, 40}}};
     * minus(array, (short)5); // all elements decreased by 5
     * </pre>
     *
     * @param a the three-dimensional array to modify
     * @param param the value to subtract from each element
     */
    public static void minus(final short[][][] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[][] element : a) {
            minus(element, param);
        }
    }

    /**
     * Multiplies all elements in a short array by a constant value in-place.
     * Does nothing if the array is null or empty.
     *
     * <pre>
     * short[] array = {2, 3, 4};
     * multipliedBy(array, (short)5); // array becomes {10, 15, 20}
     * </pre>
     *
     * @param a the array to modify
     * @param param the value to multiply each element by
     */
    public static void multipliedBy(final short[] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] *= param;
        }
    }

    /**
     * Multiplies all elements in a two-dimensional short array by a constant value in-place.
     * Applies the operation to all sub-arrays.
     *
     * <pre>
     * short[][] array = {{1, 2}, {3, 4}};
     * multipliedBy(array, (short)3); // array becomes {{3, 6}, {9, 12}}
     * </pre>
     *
     * @param a the two-dimensional array to modify
     * @param param the value to multiply each element by
     */
    public static void multipliedBy(final short[][] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     * Multiplies all elements in a three-dimensional short array by a constant value in-place.
     * Applies the operation recursively to all sub-arrays.
     *
     * <pre>
     * short[][][] array = {{{2, 4}}, {{6, 8}}};
     * multipliedBy(array, (short)2); // all elements doubled
     * </pre>
     *
     * @param a the three-dimensional array to modify
     * @param param the value to multiply each element by
     */
    public static void multipliedBy(final short[][][] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[][] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     * Divides all elements in a short array by a constant value in-place.
     * Integer division is used, so results are truncated.
     * Does nothing if the array is null or empty.
     *
     * <pre>
     * short[] array = {10, 20, 30};
     * dividedBy(array, (short)5); // array becomes {2, 4, 6}
     * </pre>
     *
     * @param a the array to modify
     * @param param the value to divide each element by
     * @throws ArithmeticException if param is zero
     */
    public static void dividedBy(final short[] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] /= param;
        }
    }

    /**
     * Divides all elements in a two-dimensional short array by a constant value in-place.
     * Applies the operation to all sub-arrays.
     *
     * <pre>
     * short[][] array = {{20, 40}, {60, 80}};
     * dividedBy(array, (short)10); // array becomes {{2, 4}, {6, 8}}
     * </pre>
     *
     * @param a the two-dimensional array to modify
     * @param param the value to divide each element by
     * @throws ArithmeticException if param is zero
     */
    public static void dividedBy(final short[][] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     * Divides all elements in a three-dimensional short array by a constant value in-place.
     * Applies the operation recursively to all sub-arrays.
     *
     * <pre>
     * short[][][] array = {{{100, 200}}, {{300, 400}}};
     * dividedBy(array, (short)10); // all elements divided by 10
     * </pre>
     *
     * @param a the three-dimensional array to modify
     * @param param the value to divide each element by
     * @throws ArithmeticException if param is zero
     */
    public static void dividedBy(final short[][][] a, final short param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[][] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     * Updates all elements in a short array using the provided unary operator.
     * The operator is applied to each element and the result replaces the original value.
     *
     * <pre>
     * short[] array = {1, 2, 3};
     * updateAll(array, x -> (short)(x * x)); // array becomes {1, 4, 9}
     * </pre>
     *
     * @param <E> the type of exception the operator may throw
     * @param a the array to update
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final short[] a, final Throwables.ShortUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsShort(a[i]);
        }
    }

    /**
     * Updates all elements in a two-dimensional short array using the provided unary operator.
     * The operator is applied to each element in all sub-arrays.
     *
     * <pre>
     * short[][] array = {{1, 2}, {3, 4}};
     * updateAll(array, x -> (short)(x + 10)); // array becomes {{11, 12}, {13, 14}}
     * </pre>
     *
     * @param <E> the type of exception the operator may throw
     * @param a the two-dimensional array to update
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final short[][] a, final Throwables.ShortUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Updates all elements in a three-dimensional short array using the provided unary operator.
     * The operator is applied recursively to all elements in all sub-arrays.
     *
     * <pre>
     * short[][][] array = {{{1, 2}}, {{3, 4}}};
     * updateAll(array, x -> (short)(x * 2)); // all elements doubled
     * </pre>
     *
     * @param <E> the type of exception the operator may throw
     * @param a the three-dimensional array to update
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final short[][][] a, final Throwables.ShortUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[][] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Replaces elements in a short array that match the predicate with a new value.
     * Only elements for which the predicate returns true are replaced.
     *
     * <pre>
     * short[] array = {1, 2, 3, 4, 5};
     * replaceIf(array, x -> x > 3, (short)0); // array becomes {1, 2, 3, 0, 0}
     * </pre>
     *
     * @param <E> the type of exception the predicate may throw
     * @param a the array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final short[] a, final Throwables.ShortPredicate<E> predicate, final short newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
            }
        }
    }

    /**
     * Replaces elements in a two-dimensional short array that match the predicate with a new value.
     * The predicate is applied to all elements in all sub-arrays.
     *
     * <pre>
     * short[][] array = {{1, 2}, {3, 4}};
     * replaceIf(array, x -> x % 2 == 0, (short)0); // array becomes {{1, 0}, {3, 0}}
     * </pre>
     *
     * @param <E> the type of exception the predicate may throw
     * @param a the two-dimensional array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final short[][] a, final Throwables.ShortPredicate<E> predicate, final short newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Replaces elements in a three-dimensional short array that match the predicate with a new value.
     * The predicate is applied recursively to all elements in all sub-arrays.
     *
     * <pre>
     * short[][][] array = {{{1, 2}}, {{3, 4}}};
     * replaceIf(array, x -> x < 3, (short)10); // replaces 1 and 2 with 10
     * </pre>
     *
     * @param <E> the type of exception the predicate may throw
     * @param a the three-dimensional array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final short[][][] a, final Throwables.ShortPredicate<E> predicate, final short newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final short[][] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Reshapes a one-dimensional short array into a two-dimensional array with the specified number of columns.
     * The last row may have fewer elements if the array length is not evenly divisible by cols.
     *
     * <pre>
     * short[] array = {1, 2, 3, 4, 5};
     * short[][] reshaped = reshape(array, 2); // returns {{1, 2}, {3, 4}, {5}}
     * </pre>
     *
     * @param a the array to reshape
     * @param cols the number of columns in each row
     * @return a two-dimensional array with the specified column count
     * @throws IllegalArgumentException if cols is less than 1
     */
    public static short[][] reshape(final short[] a, final int cols) throws IllegalArgumentException {
        checkMForReshape(cols);

        if (N.isEmpty(a)) {
            return new short[0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, cols, RoundingMode.CEILING);
        final short[][] c = new short[n][];

        for (int i = 0, from = 0; i < n; i++, from += cols) {
            c[i] = N.copyOfRange(a, from, from + N.min(len - from, cols));
        }

        return c;
    }

    /**
     * Reshapes a one-dimensional short array into a three-dimensional array with the specified dimensions.
     * The array is divided into blocks of size rowscols, with partial blocks allowed.
     *
     * <pre>
     * short[] array = {1, 2, 3, 4, 5, 6, 7, 8};
     * short[][][] reshaped = reshape(array, 2, 2); // returns {{{1,2},{3,4}}, {{5,6},{7,8}}}
     * </pre>
     *
     * @param a the array to reshape
     * @param rows the number of rows in each 2D block
     * @param cols the number of columns in each row
     * @return a three-dimensional array with the specified dimensions
     * @throws IllegalArgumentException if rows or cols is less than 1
     */
    public static short[][][] reshape(final short[] a, final int rows, final int cols) throws IllegalArgumentException {
        checkMAndLForReshape(rows, cols);

        if (N.isEmpty(a)) {
            return new short[0][0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, rows * cols, RoundingMode.CEILING);
        final short[][][] c = new short[n][][];

        for (int i = 0, from = 0; i < n; i++) {
            c[i] = new short[N.min(rows, Numbers.divide(len - from, cols, RoundingMode.CEILING))][];

            for (int j = 0, y = c[i].length; j < y; j++, from += cols) {
                c[i][j] = N.copyOfRange(a, from, from + N.min(len - from, cols));
            }
        }

        return c;
    }

    /**
     * Flattens a two-dimensional short array into a one-dimensional array.
     * All elements from all sub-arrays are combined into a single array in row-major order.
     * Null or empty sub-arrays are skipped.
     *
     * <pre>
     * short[][] array = {{1, 2}, {3, 4, 5}};
     * short[] flat = flatten(array); // returns {1, 2, 3, 4, 5}
     * </pre>
     *
     * @param a the two-dimensional array to flatten
     * @return a one-dimensional array containing all elements
     */
    public static short[] flatten(final short[][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_SHORT_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final short[] c = new short[count];
        int from = 0;

        for (final short[] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            N.copy(element, 0, c, from, element.length);

            from += element.length;
        }

        return c;
    }

    /**
     * Flattens a three-dimensional short array into a one-dimensional array.
     * All elements from all sub-arrays at all levels are combined into a single array.
     * Null or empty sub-arrays at any level are skipped.
     *
     * <pre>
     * short[][][] array = {{{1, 2}, {3}}, {{4, 5}}};
     * short[] flat = flatten(array); // returns {1, 2, 3, 4, 5}
     * </pre>
     *
     * @param a the three-dimensional array to flatten
     * @return a one-dimensional array containing all elements
     */
    public static short[] flatten(final short[][][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_SHORT_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final short[] c = new short[count];
        int from = 0;

        for (final short[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final short[] shorts : element) {
                if (N.isEmpty(shorts)) {
                    continue;
                }

                N.copy(shorts, 0, c, from, shorts.length);

                from += shorts.length;
            }
        }

        return c;
    }

    /**
     * Performs an operation on a flattened view of a two-dimensional array and writes the result back.
     * This method flattens the array, applies the operation, then copies the values back to their original positions.
     *
     * <pre>
     * short[][] array = {{3, 1}, {4, 2}};
     * flatOp(array, t -> N.sort(t)); // sorts all elements across sub-arrays
     * </pre>
     *
     * @param <E> the type of exception the operation may throw
     * @param a the two-dimensional array to operate on
     * @param op the operation to perform on the flattened array
     * @throws E if the operation throws an exception
     */
    public static <E extends Exception> void flatOp(final short[][] a, final Throwables.Consumer<? super short[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final short[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final short[] e : a) {
            if (N.notEmpty(e)) {
                N.copy(tmp, idx, e, 0, e.length);
                idx += e.length;
            }
        }
    }

    /**
     * Performs an operation on a flattened view of a three-dimensional array and writes the result back.
     * This method flattens the array, applies the operation, then copies the values back to their original positions.
     *
     * <pre>
     * short[][][] array = {{{5, 2}}, {{3, 1}}};
     * flatOp(array, t -> N.sort(t)); // sorts all elements across all sub-arrays
     * </pre>
     *
     * @param <E> the type of exception the operation may throw
     * @param a the three-dimensional array to operate on
     * @param op the operation to perform on the flattened array
     * @throws E if the operation throws an exception
     */
    public static <E extends Exception> void flatOp(final short[][][] a, final Throwables.Consumer<? super short[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final short[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final short[][] e : a) {
            if (N.notEmpty(e)) {
                for (final short[] ee : e) {
                    if (N.notEmpty(ee)) {
                        N.copy(tmp, idx, ee, 0, ee.length);
                        idx += ee.length;
                    }
                }
            }
        }
    }

    /**
     * Performs element-wise addition of two short arrays.
     * The result array has the length of the shorter input array.
     *
     * <pre>
     * short[] a = {1, 2, 3};
     * short[] b = {4, 5, 6, 7};
     * short[] result = add(a, b); // returns {5, 7, 9}
     * </pre>
     *
     * @param a the first array
     * @param b the second array
     * @return a new array containing the element-wise sums
     */
    public static short[] add(final short[] a, final short[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (short) (a[i] + b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of two short arrays with default values for missing elements.
     * The result array has the length of the longer input array.
     *
     * <pre>
     * short[] a = {1, 2};
     * short[] b = {3, 4, 5};
     * short[] result = add(a, b, (short)10, (short)20); // returns {4, 6, 25}
     * </pre>
     *
     * @param a the first array
     * @param b the second array
     * @param valueForNoneA the default value to use when array a has no element at an index
     * @param valueForNoneB the default value to use when array b has no element at an index
     * @return a new array containing the element-wise sums
     */
    public static short[] add(final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return add(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for element-wise addition with specified length.
     */
    private static short[] add(final int len, final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = (short) (a[i] + b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = (short) (valueForNoneA + b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = (short) (a[i] + valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = (short) (valueForNoneA + valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of three short arrays.
     * The result array has the length of the shortest input array.
     *
     * <pre>
     * short[] a = {1, 2, 3};
     * short[] b = {4, 5, 6};
     * short[] c = {7, 8, 9};
     * short[] result = add(a, b, c); // returns {12, 15, 18}
     * </pre>
     *
     * @param a the first array
     * @param b the second array
     * @param c the third array
     * @return a new array containing the element-wise sums
     */
    public static short[] add(final short[] a, final short[] b, final short[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (short) (a[i] + b[i] + c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of three short arrays with default values for missing elements.
     * The result array has the length of the longest input array.
     *
     * <pre>
     * short[] a = {1, 2};
     * short[] b = {3};
     * short[] c = {5, 6, 7};
     * short[] result = add(a, b, c, (short)0, (short)0, (short)0); // returns {9, 8, 7}
     * </pre>
     *
     * @param a the first array
     * @param b the second array
     * @param c the third array
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new array containing the element-wise sums
     */
    public static short[] add(final short[] a, final short[] b, final short[] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return add(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for element-wise addition of three arrays with specified length.
     */
    private static short[] add(final int len, final short[] a, final short[] b, final short[] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = (short) (a[i] + b[i] + c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (short) ((i < lenA ? a[i] : valueForNoneA) + (i < lenB ? b[i] : valueForNoneB) + (i < lenC ? c[i] : valueForNoneC));
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of two 2D short arrays.
     * The result array has dimensions equal to the minimum dimensions of the input arrays.
     * Only overlapping elements are added.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[][] a = {{1, 2}, {3, 4}, {5, 6}};
     * short[][] b = {{10, 20}, {30, 40}};
     * short[][] result = Arrays.add(a, b); // {{11, 22}, {33, 44}}
     * </pre>
     *
     * @param a the first array, can be null or empty
     * @param b the second array, can be null or empty
     * @return a new array containing the element-wise sum of overlapping elements,
     *         or an empty array if either input is null/empty
     */
    public static short[][] add(final short[][] a, final short[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of two 2D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of the input arrays.
     * Missing elements are treated as having the specified default values.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[][] a = {{1, 2}, {3}};
     * short[][] b = {{10}, {30, 40}};
     * short[][] result = Arrays.add(a, b, (short)0, (short)100);
     * // {{11, 102}, {33, 140}} - missing elements use default values
     * </pre>
     *
     * @param a the first array, can be null
     * @param b the second array, can be null
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @return a new array with dimensions of max(a.length, b.length) x max(subarray lengths)
     */
    public static short[][] add(final short[][] a, final short[][] b, final short valueForNoneA, final short valueForNoneB) {
        return add(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for element-wise addition with specified dimensions.
     *
     * @param len the desired length of the result array
     * @param rowLen the desired length of each row in the result array
     * @param a the first array
     * @param b the second array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @return the result array with specified dimensions
     */
    private static short[][] add(final int len, final int rowLen, final short[][] a, final short[][] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = add(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = add(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = add(rowLen, (short[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 2D short arrays.
     * The result array has dimensions equal to the minimum dimensions of all input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[][] a = {{1, 2}, {3, 4}};
     * short[][] b = {{10, 20}, {30, 40}};
     * short[][] c = {{100, 200}, {300, 400}};
     * short[][] result = Arrays.add(a, b, c); // {{111, 222}, {333, 444}}
     * </pre>
     *
     * @param a the first array, can be null or empty
     * @param b the second array, can be null or empty
     * @param c the third array, can be null or empty
     * @return a new array containing the element-wise sum of overlapping elements
     */
    public static short[][] add(final short[][] a, final short[][] b, final short[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 2D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of all input arrays.
     *
     * <p>This method is useful when working with jagged arrays or arrays of different sizes,
     * allowing you to specify what value should be used when an element is missing.</p>
     *
     * @param a the first array, can be null
     * @param b the second array, can be null
     * @param c the third array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new array with dimensions of max(lengths) x max(subarray lengths)
     */
    public static short[][] add(final short[][] a, final short[][] b, final short[][] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        return add(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC);
    }

    /**
     * Internal helper method for three-array addition with specified dimensions.
     *
     * @param len the desired length of the result array
     * @param rowLen the desired length of each row
     * @param a the first array
     * @param b the second array
     * @param c the third array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @param valueForNoneC default value for missing elements in c
     * @return the result array with specified dimensions
     */
    private static short[][] add(final int len, final int rowLen, final short[][] a, final short[][] b, final short[][] c, final short valueForNoneA,
            final short valueForNoneB, final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = add(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of two 3D short arrays.
     * The result array has dimensions equal to the minimum dimensions of the input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[][][] a = {{{1, 2}}, {{3, 4}}};
     * short[][][] b = {{{10, 20}}, {{30, 40}}};
     * short[][][] result = Arrays.add(a, b); // {{{11, 22}}, {{33, 44}}}
     * </pre>
     *
     * @param a the first 3D array, can be null or empty
     * @param b the second 3D array, can be null or empty
     * @return a new 3D array containing the element-wise sum of overlapping elements
     */
    public static short[][][] add(final short[][][] a, final short[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of two 3D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of the input arrays.
     *
     * @param a the first 3D array, can be null
     * @param b the second 3D array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @return a new 3D array with maximum dimensions, using default values for missing elements
     */
    public static short[][][] add(final short[][][] a, final short[][][] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = add(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = add(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = add(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 3D short arrays.
     * The result array has dimensions equal to the minimum dimensions of all input arrays.
     *
     * @param a the first 3D array, can be null or empty
     * @param b the second 3D array, can be null or empty
     * @param c the third 3D array, can be null or empty
     * @return a new 3D array containing the element-wise sum of overlapping elements
     */
    public static short[][][] add(final short[][][] a, final short[][][] b, final short[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 3D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of all input arrays.
     *
     * @param a the first 3D array, can be null
     * @param b the second 3D array, can be null
     * @param c the third 3D array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new 3D array with maximum dimensions, using default values for missing elements
     */
    public static short[][][] add(final short[][][] a, final short[][][] b, final short[][][] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = add(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = add(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 1D short arrays (a - b).
     * The result array has length equal to the minimum length of the input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[] a = {10, 20, 30};
     * short[] b = {1, 2, 3, 4};
     * short[] result = Arrays.subtract(a, b); // {9, 18, 27}
     * </pre>
     *
     * @param a the minuend array, can be null or empty
     * @param b the subtrahend array, can be null or empty
     * @return a new array containing the element-wise difference of overlapping elements
     */
    public static short[] subtract(final short[] a, final short[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (short) (a[i] - b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 1D short arrays with default values for missing elements.
     * The result array has length equal to the maximum length of the input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[] a = {10, 20};
     * short[] b = {1, 2, 3};
     * short[] result = Arrays.subtract(a, b, (short)0, (short)5); // {9, 18, -5}
     * </pre>
     *
     * @param a the minuend array, can be null
     * @param b the subtrahend array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @return a new array with length max(a.length, b.length)
     */
    public static short[] subtract(final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return subtract(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for element-wise subtraction with specified length.
     *
     * @param len the desired length of the result array
     * @param a the minuend array
     * @param b the subtrahend array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @return the result array with specified length
     */
    private static short[] subtract(final int len, final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = (short) (a[i] - b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = (short) (valueForNoneA - b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = (short) (a[i] - valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = (short) (valueForNoneA - valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 1D short arrays (a - b - c).
     * The result array has length equal to the minimum length of all input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[] a = {100, 200};
     * short[] b = {10, 20};
     * short[] c = {1, 2};
     * short[] result = Arrays.subtract(a, b, c); // {89, 178}
     * </pre>
     *
     * @param a the minuend array, can be null or empty
     * @param b the first subtrahend array, can be null or empty
     * @param c the second subtrahend array, can be null or empty
     * @return a new array containing a[i] - b[i] - c[i] for overlapping elements
     */
    public static short[] subtract(final short[] a, final short[] b, final short[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (short) (a[i] - b[i] - c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 1D short arrays with default values for missing elements.
     * The result array has length equal to the maximum length of all input arrays.
     *
     * @param a the minuend array, can be null
     * @param b the first subtrahend array, can be null
     * @param c the second subtrahend array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new array with length max(a.length, b.length, c.length)
     */
    public static short[] subtract(final short[] a, final short[] b, final short[] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return subtract(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for three-array subtraction with specified length.
     *
     * @param len the desired length of the result array
     * @param a the minuend array
     * @param b the first subtrahend array
     * @param c the second subtrahend array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @param valueForNoneC default value for missing elements in c
     * @return the result array with specified length
     */
    private static short[] subtract(final int len, final short[] a, final short[] b, final short[] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = (short) (a[i] - b[i] - c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (short) ((i < lenA ? a[i] : valueForNoneA) - (i < lenB ? b[i] : valueForNoneB) - (i < lenC ? c[i] : valueForNoneC));
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 2D short arrays (a - b).
     * The result array has dimensions equal to the minimum dimensions of the input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[][] a = {{10, 20}, {30, 40}};
     * short[][] b = {{1, 2}, {3, 4}};
     * short[][] result = Arrays.subtract(a, b); // {{9, 18}, {27, 36}}
     * </pre>
     *
     * @param a the minuend array, can be null or empty
     * @param b the subtrahend array, can be null or empty
     * @return a new 2D array containing the element-wise difference
     */
    public static short[][] subtract(final short[][] a, final short[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 2D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of the input arrays.
     *
     * @param a the minuend array, can be null
     * @param b the subtrahend array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @return a new 2D array with maximum dimensions
     */
    public static short[][] subtract(final short[][] a, final short[][] b, final short valueForNoneA, final short valueForNoneB) {
        return subtract(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for 2D array subtraction with specified dimensions.
     *
     * @param len the desired length of the result array
     * @param rowLen the desired length of each row
     * @param a the minuend array
     * @param b the subtrahend array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @return the result array with specified dimensions
     */
    private static short[][] subtract(final int len, final int rowLen, final short[][] a, final short[][] b, final short valueForNoneA,
            final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = subtract(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = subtract(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = subtract(rowLen, (short[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 2D short arrays (a - b - c).
     * The result array has dimensions equal to the minimum dimensions of all input arrays.
     *
     * @param a the minuend array, can be null or empty
     * @param b the first subtrahend array, can be null or empty
     * @param c the second subtrahend array, can be null or empty
     * @return a new 2D array containing a[i][j] - b[i][j] - c[i][j]
     */
    public static short[][] subtract(final short[][] a, final short[][] b, final short[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 2D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of all input arrays.
     *
     * @param a the minuend array, can be null
     * @param b the first subtrahend array, can be null
     * @param c the second subtrahend array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new 2D array with maximum dimensions
     */
    public static short[][] subtract(final short[][] a, final short[][] b, final short[][] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        return subtract(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for three 2D array subtraction with specified dimensions.
     *
     * @param len the desired length of the result array
     * @param rowLen the desired length of each row
     * @param a the minuend array
     * @param b the first subtrahend array
     * @param c the second subtrahend array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @param valueForNoneC default value for missing elements in c
     * @return the result array with specified dimensions
     */
    private static short[][] subtract(final int len, final int rowLen, final short[][] a, final short[][] b, final short[][] c, final short valueForNoneA,
            final short valueForNoneB, final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = subtract(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 3D short arrays (a - b).
     * The result array has dimensions equal to the minimum dimensions of the input arrays.
     *
     * @param a the minuend array, can be null or empty
     * @param b the subtrahend array, can be null or empty
     * @return a new 3D array containing the element-wise difference
     */
    public static short[][][] subtract(final short[][][] a, final short[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 3D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of the input arrays.
     *
     * @param a the minuend array, can be null
     * @param b the subtrahend array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @return a new 3D array with maximum dimensions
     */
    public static short[][][] subtract(final short[][][] a, final short[][][] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = subtract(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = subtract(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = subtract(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 3D short arrays (a - b - c).
     * The result array has dimensions equal to the minimum dimensions of all input arrays.
     *
     * @param a the minuend array, can be null or empty
     * @param b the first subtrahend array, can be null or empty
     * @param c the second subtrahend array, can be null or empty
     * @return a new 3D array containing the element-wise differences
     */
    public static short[][][] subtract(final short[][][] a, final short[][][] b, final short[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 3D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of all input arrays.
     *
     * @param a the minuend array, can be null
     * @param b the first subtrahend array, can be null
     * @param c the second subtrahend array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new 3D array with maximum dimensions
     */
    public static short[][][] subtract(final short[][][] a, final short[][][] b, final short[][][] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = subtract(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = subtract(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 1D short arrays (a * b).
     * The result array has length equal to the minimum length of the input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[] a = {2, 3, 4};
     * short[] b = {5, 6, 7, 8};
     * short[] result = Arrays.multipliedBy(a, b); // {10, 18, 28}
     * </pre>
     *
     * @param a the first array, can be null or empty
     * @param b the second array, can be null or empty
     * @return a new array containing the element-wise product of overlapping elements
     */
    public static short[] multipliedBy(final short[] a, final short[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (short) (a[i] * b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 1D short arrays with default values for missing elements.
     * The result array has length equal to the maximum length of the input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[] a = {2, 3};
     * short[] b = {5, 6, 7};
     * short[] result = Arrays.multipliedBy(a, b, (short)1, (short)10); // {10, 18, 70}
     * </pre>
     *
     * @param a the first array, can be null
     * @param b the second array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @return a new array with length max(a.length, b.length)
     */
    public static short[] multipliedBy(final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return multipliedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for element-wise multiplication with specified length.
     *
     * @param len the desired length of the result array
     * @param a the first array
     * @param b the second array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @return the result array with specified length
     */
    private static short[] multipliedBy(final int len, final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = (short) (a[i] * b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = (short) (valueForNoneA * b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = (short) (a[i] * valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = (short) (valueForNoneA * valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 1D short arrays (a * b * c).
     * The result array has length equal to the minimum length of all input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[] a = {2, 3};
     * short[] b = {4, 5};
     * short[] c = {6, 7};
     * short[] result = Arrays.multipliedBy(a, b, c); // {48, 105}
     * </pre>
     *
     * @param a the first array, can be null or empty
     * @param b the second array, can be null or empty
     * @param c the third array, can be null or empty
     * @return a new array containing a[i] * b[i] * c[i] for overlapping elements
     */
    public static short[] multipliedBy(final short[] a, final short[] b, final short[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (short) (a[i] * b[i] * c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 1D short arrays with default values for missing elements.
     * The result array has length equal to the maximum length of all input arrays.
     *
     * @param a the first array, can be null
     * @param b the second array, can be null
     * @param c the third array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new array with length max(a.length, b.length, c.length)
     */
    public static short[] multipliedBy(final short[] a, final short[] b, final short[] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return multipliedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for three-array multiplication with specified length.
     *
     * @param len the desired length of the result array
     * @param a the first array
     * @param b the second array
     * @param c the third array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @param valueForNoneC default value for missing elements in c
     * @return the result array with specified length
     */
    private static short[] multipliedBy(final int len, final short[] a, final short[] b, final short[] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = (short) (a[i] * b[i] * c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (short) ((i < lenA ? a[i] : valueForNoneA) * (i < lenB ? b[i] : valueForNoneB) * (i < lenC ? c[i] : valueForNoneC));
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 2D short arrays (a * b).
     * The result array has dimensions equal to the minimum dimensions of the input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[][] a = {{2, 3}, {4, 5}};
     * short[][] b = {{10, 20}, {30, 40}};
     * short[][] result = Arrays.multipliedBy(a, b); // {{20, 60}, {120, 200}}
     * </pre>
     *
     * @param a the first array, can be null or empty
     * @param b the second array, can be null or empty
     * @return a new 2D array containing the element-wise product
     */
    public static short[][] multipliedBy(final short[][] a, final short[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 2D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of the input arrays.
     *
     * @param a the first array, can be null
     * @param b the second array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @return a new 2D array with maximum dimensions
     */
    public static short[][] multipliedBy(final short[][] a, final short[][] b, final short valueForNoneA, final short valueForNoneB) {
        return multipliedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for 2D array multiplication with specified dimensions.
     *
     * @param len the desired length of the result array
     * @param rowLen the desired length of each row
     * @param a the first array
     * @param b the second array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @return the result array with specified dimensions
     */
    private static short[][] multipliedBy(final int len, final int rowLen, final short[][] a, final short[][] b, final short valueForNoneA,
            final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = multipliedBy(rowLen, (short[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 2D short arrays (a * b * c).
     * The result array has dimensions equal to the minimum dimensions of all input arrays.
     * Only overlapping elements are multiplied.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[][] a = {{2, 3}, {4, 5}};
     * short[][] b = {{1, 2}, {3, 4}};
     * short[][] c = {{10, 10}, {10, 10}};
     * short[][] result = Arrays.multipliedBy(a, b, c); // {{20, 60}, {120, 200}}
     * </pre>
     *
     * @param a the first array, can be null or empty
     * @param b the second array, can be null or empty
     * @param c the third array, can be null or empty
     * @return a new 2D array containing the element-wise product of overlapping elements
     */
    public static short[][] multipliedBy(final short[][] a, final short[][] b, final short[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 2D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of all input arrays.
     * Missing elements are treated as having the specified default values.
     *
     * <p>This method is particularly useful when working with jagged arrays or arrays of different sizes,
     * allowing you to specify what value should be used when an element is missing.</p>
     *
     * <p>Example usage:</p>
     * <pre>
     * short[][] a = {{2, 3}, {4}};
     * short[][] b = {{1}, {3, 4}};
     * short[][] c = {{10, 10}};
     * // Missing elements use default values (1 for all arrays in this example)
     * short[][] result = Arrays.multipliedBy(a, b, c, (short)1, (short)1, (short)1);
     * </pre>
     *
     * @param a the first array, can be null
     * @param b the second array, can be null
     * @param c the third array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new 2D array with dimensions of max(lengths) x max(subarray lengths)
     */
    public static short[][] multipliedBy(final short[][] a, final short[][] b, final short[][] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        return multipliedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for three-array multiplication with specified dimensions.
     *
     * @param len the desired length of the result array
     * @param rowLen the desired length of each row in the result array
     * @param a the first array
     * @param b the second array
     * @param c the third array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @param valueForNoneC default value for missing elements in c
     * @return the result array with specified dimensions
     */
    private static short[][] multipliedBy(final int len, final int rowLen, final short[][] a, final short[][] b, final short[][] c, final short valueForNoneA,
            final short valueForNoneB, final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = multipliedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 3D short arrays (a * b).
     * The result array has dimensions equal to the minimum dimensions of the input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[][][] a = {{{2, 3}}, {{4, 5}}};
     * short[][][] b = {{{10, 20}}, {{30, 40}}};
     * short[][][] result = Arrays.multipliedBy(a, b); // {{{20, 60}}, {{120, 200}}}
     * </pre>
     *
     * @param a the first 3D array, can be null or empty
     * @param b the second 3D array, can be null or empty
     * @return a new 3D array containing the element-wise product of overlapping elements
     */
    public static short[][][] multipliedBy(final short[][][] a, final short[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 3D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of the input arrays.
     *
     * @param a the first 3D array, can be null
     * @param b the second 3D array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @return a new 3D array with maximum dimensions, using default values for missing elements
     */
    public static short[][][] multipliedBy(final short[][][] a, final short[][][] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = multipliedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = multipliedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 3D short arrays (a * b * c).
     * The result array has dimensions equal to the minimum dimensions of all input arrays.
     *
     * @param a the first 3D array, can be null or empty
     * @param b the second 3D array, can be null or empty
     * @param c the third 3D array, can be null or empty
     * @return a new 3D array containing the element-wise product of overlapping elements
     */
    public static short[][][] multipliedBy(final short[][][] a, final short[][][] b, final short[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 3D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of all input arrays.
     *
     * @param a the first 3D array, can be null
     * @param b the second 3D array, can be null
     * @param c the third 3D array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new 3D array with maximum dimensions, using default values for missing elements
     */
    public static short[][][] multipliedBy(final short[][][] a, final short[][][] b, final short[][][] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = multipliedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 1D short arrays (a / b).
     * The result array has length equal to the minimum length of the input arrays.
     * Note: Integer division is performed, so results are truncated.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[] a = {10, 20, 30};
     * short[] b = {2, 4, 5};
     * short[] result = Arrays.dividedBy(a, b); // {5, 5, 6}
     * </pre>
     *
     * @param a the dividend array, can be null or empty
     * @param b the divisor array, can be null or empty
     * @return a new array containing the element-wise quotient of overlapping elements
     * @throws ArithmeticException if any element in b is zero
     */
    public static short[] dividedBy(final short[] a, final short[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (short) (a[i] / b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 1D short arrays with default values for missing elements.
     * The result array has length equal to the maximum length of the input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[] a = {10, 20};
     * short[] b = {2, 4, 5};
     * short[] result = Arrays.dividedBy(a, b, (short)30, (short)1); // {5, 5, 30}
     * </pre>
     *
     * @param a the dividend array, can be null
     * @param b the divisor array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @return a new array with length max(a.length, b.length)
     * @throws ArithmeticException if any divisor is zero
     */
    public static short[] dividedBy(final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for element-wise division with specified length.
     *
     * @param len the desired length of the result array
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @return the result array with specified length
     */
    private static short[] dividedBy(final int len, final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = (short) (a[i] / b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = (short) (valueForNoneA / b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = (short) (a[i] / valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = (short) (valueForNoneA / valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 1D short arrays (a / b / c).
     * The result array has length equal to the minimum length of all input arrays.
     * Operations are performed left to right: (a[i] / b[i]) / c[i].
     *
     * <p>Example usage:</p>
     * <pre>
     * short[] a = {100, 200};
     * short[] b = {10, 20};
     * short[] c = {2, 4};
     * short[] result = Arrays.dividedBy(a, b, c); // {5, 2}
     * </pre>
     *
     * @param a the dividend array, can be null or empty
     * @param b the first divisor array, can be null or empty
     * @param c the second divisor array, can be null or empty
     * @return a new array containing (a[i] / b[i]) / c[i] for overlapping elements
     * @throws ArithmeticException if any element in b or c is zero
     */
    public static short[] dividedBy(final short[] a, final short[] b, final short[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (short) (a[i] / b[i] / c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of three 1D short arrays with default values for missing elements.
     * The result array has length equal to the maximum length of all input arrays.
     *
     * @param a the dividend array, can be null
     * @param b the first divisor array, can be null
     * @param c the second divisor array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new array with length max(a.length, b.length, c.length)
     * @throws ArithmeticException if any divisor is zero
     */
    public static short[] dividedBy(final short[] a, final short[] b, final short[] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for three-array division with specified length.
     *
     * @param len the desired length of the result array
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @param valueForNoneC default value for missing elements in c
     * @return the result array with specified length
     */
    private static short[] dividedBy(final int len, final short[] a, final short[] b, final short[] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = (short) (a[i] / b[i] / c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (short) ((i < lenA ? a[i] : valueForNoneA) / (i < lenB ? b[i] : valueForNoneB) / (i < lenC ? c[i] : valueForNoneC));
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of two 2D short arrays (a / b).
     * The result array has dimensions equal to the minimum dimensions of the input arrays.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[][] a = {{10, 20}, {30, 40}};
     * short[][] b = {{2, 4}, {5, 8}};
     * short[][] result = Arrays.dividedBy(a, b); // {{5, 5}, {6, 5}}
     * </pre>
     *
     * @param a the dividend array, can be null or empty
     * @param b the divisor array, can be null or empty
     * @return a new 2D array containing the element-wise quotient
     * @throws ArithmeticException if any element in b is zero
     */
    public static short[][] dividedBy(final short[][] a, final short[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 2D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of the input arrays.
     *
     * @param a the dividend array, can be null
     * @param b the divisor array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @return a new 2D array with maximum dimensions
     * @throws ArithmeticException if any divisor is zero
     */
    public static short[][] dividedBy(final short[][] a, final short[][] b, final short valueForNoneA, final short valueForNoneB) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for 2D array division with specified dimensions.
     *
     * @param len the desired length of the result array
     * @param rowLen the desired length of each row
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @return the result array with specified dimensions
     */
    private static short[][] dividedBy(final int len, final int rowLen, final short[][] a, final short[][] b, final short valueForNoneA,
            final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, (short[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 2D short arrays (a / b / c).
     * The result array has dimensions equal to the minimum dimensions of all input arrays.
     *
     * @param a the dividend array, can be null or empty
     * @param b the first divisor array, can be null or empty
     * @param c the second divisor array, can be null or empty
     * @return a new 2D array containing the element-wise quotients
     * @throws ArithmeticException if any element in b or c is zero
     */
    public static short[][] dividedBy(final short[][] a, final short[][] b, final short[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of three 2D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of all input arrays.
     *
     * @param a the dividend array, can be null
     * @param b the first divisor array, can be null
     * @param c the second divisor array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new 2D array with maximum dimensions
     * @throws ArithmeticException if any divisor is zero
     */
    public static short[][] dividedBy(final short[][] a, final short[][] b, final short[][] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for three 2D array division with specified dimensions.
     *
     * @param len the desired length of the result array
     * @param rowLen the desired length of each row
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @param valueForNoneC default value for missing elements in c
     * @return the result array with specified dimensions
     */
    private static short[][] dividedBy(final int len, final int rowLen, final short[][] a, final short[][] b, final short[][] c, final short valueForNoneA,
            final short valueForNoneB, final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of two 3D short arrays (a / b).
     * The result array has dimensions equal to the minimum dimensions of the input arrays.
     *
     * @param a the dividend array, can be null or empty
     * @param b the divisor array, can be null or empty
     * @return a new 3D array containing the element-wise quotient
     * @throws ArithmeticException if any element in b is zero
     */
    public static short[][][] dividedBy(final short[][][] a, final short[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 3D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of the input arrays.
     *
     * @param a the dividend array, can be null
     * @param b the divisor array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @return a new 3D array with maximum dimensions
     * @throws ArithmeticException if any divisor is zero
     */
    public static short[][][] dividedBy(final short[][][] a, final short[][][] b, final short valueForNoneA, final short valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 3D short arrays (a / b / c).
     * The result array has dimensions equal to the minimum dimensions of all input arrays.
     *
     * @param a the dividend array, can be null or empty
     * @param b the first divisor array, can be null or empty
     * @param c the second divisor array, can be null or empty
     * @return a new 3D array containing the element-wise quotients
     * @throws ArithmeticException if any element in b or c is zero
     */
    public static short[][][] dividedBy(final short[][][] a, final short[][][] b, final short[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of three 3D short arrays with default values for missing elements.
     * The result array has dimensions equal to the maximum dimensions of all input arrays.
     *
     * @param a the dividend array, can be null
     * @param b the first divisor array, can be null
     * @param c the second divisor array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @return a new 3D array with maximum dimensions
     * @throws ArithmeticException if any divisor is zero
     */
    public static short[][][] dividedBy(final short[][][] a, final short[][][] b, final short[][][] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 1D short arrays with a default value for zero divisors.
     * When a divisor is zero, the specified default value is used instead to avoid division by zero.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[] a = {10, 20, 30};
     * short[] b = {2, 0, 5};
     * short[] result = Arrays.dividedBy(a, b, (short)1); // {5, 20, 6}
     * // Note: 20/0 becomes 20/1 = 20
     * </pre>
     *
     * @param a the dividend array, can be null or empty
     * @param b the divisor array, can be null or empty
     * @param defaultValueForZero the value to use when a divisor is zero
     * @return a new array containing the element-wise quotient with zero-handling
     */
    public static short[] dividedBy(final short[] a, final short[] b, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (short) (a[i] / (b[i] == 0 ? defaultValueForZero : b[i]));
        }

        return result;
    }

    /**
     * Performs element-wise division of two 1D short arrays with default values for missing elements
     * and a default value for zero divisors.
     *
     * <p>This method combines the functionality of handling missing elements and zero divisors,
     * making it suitable for robust array division operations.</p>
     *
     * @param a the dividend array, can be null
     * @param b the divisor array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param defaultValueForZero the value to use when a divisor is zero
     * @return a new array with length max(a.length, b.length) with zero-handling
     */
    public static short[] dividedBy(final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     * Internal helper method for element-wise division with zero-handling and specified length.
     *
     * @param len the desired length of the result array
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @param defaultValueForZero the value to use when a divisor is zero
     * @return the result array with specified length
     */
    private static short[] dividedBy(final int len, final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB,
            final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = (short) (a[i] / (b[i] == 0 ? defaultValueForZero : b[i]));
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = (short) (valueForNoneA / (b[i] == 0 ? defaultValueForZero : b[i]));
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = (short) (a[i] / valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = (short) (valueForNoneA / valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 1D short arrays with a default value for zero divisors.
     * Operations are performed left to right: (a[i] / b[i]) / c[i], with zero-handling at each step.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[] a = {100, 200, 300};
     * short[] b = {10, 0, 20};
     * short[] c = {2, 4, 0};
     * short[] result = Arrays.dividedBy(a, b, c, (short)1);
     * // {5, 50, 15} - zeros are replaced with 1
     * </pre>
     *
     * @param a the dividend array, can be null or empty
     * @param b the first divisor array, can be null or empty
     * @param c the second divisor array, can be null or empty
     * @param defaultValueForZero the value to use when a divisor is zero
     * @return a new array containing the element-wise quotient with zero-handling
     */
    public static short[] dividedBy(final short[] a, final short[] b, final short[] c, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = (short) (a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]));
        }

        return result;
    }

    /**
     * Performs element-wise division of three 1D short arrays with default values for missing elements
     * and a default value for zero divisors.
     *
     * @param a the dividend array, can be null
     * @param b the first divisor array, can be null
     * @param c the second divisor array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param valueForNoneC the default value for missing elements in array c
     * @param defaultValueForZero the value to use when a divisor is zero
     * @return a new array with length max(a.length, b.length, c.length) with zero-handling
     */
    public static short[] dividedBy(final short[] a, final short[] b, final short[] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     * Internal helper method for three-array division with zero-handling and specified length.
     *
     * @param len the desired length of the result array
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @param valueForNoneC default value for missing elements in c
     * @param defaultValueForZero the value to use when a divisor is zero
     * @return the result array with specified length
     */
    private static short[] dividedBy(final int len, final short[] a, final short[] b, final short[] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = (short) (a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]));
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (short) ((i < lenA ? a[i] : valueForNoneA) / (i < lenB ? (b[i] == 0 ? defaultValueForZero : b[i]) : valueForNoneB)
                        / (i < lenC ? (c[i] == 0 ? defaultValueForZero : c[i]) : valueForNoneC));
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of two 2D short arrays with a default value for zero divisors.
     * When a divisor is zero, the specified default value is used instead.
     *
     * <p>Example usage:</p>
     * <pre>
     * short[][] a = {{10, 20}, {30, 40}};
     * short[][] b = {{2, 0}, {5, 8}};
     * short[][] result = Arrays.dividedBy(a, b, (short)1); // {{5, 20}, {6, 5}}
     * </pre>
     *
     * @param a the dividend array, can be null or empty
     * @param b the divisor array, can be null or empty
     * @param defaultValueForZero the value to use when a divisor is zero
     * @return a new 2D array containing the element-wise quotient with zero-handling
     */
    public static short[][] dividedBy(final short[][] a, final short[][] b, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 2D short arrays with default values for missing elements
     * and a default value for zero divisors.
     *
     * @param a the dividend array, can be null
     * @param b the divisor array, can be null
     * @param valueForNoneA the default value for missing elements in array a
     * @param valueForNoneB the default value for missing elements in array b
     * @param defaultValueForZero the value to use when a divisor is zero
     * @return a new 2D array with maximum dimensions and zero-handling
     */
    public static short[][] dividedBy(final short[][] a, final short[][] b, final short valueForNoneA, final short valueForNoneB,
            final short defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     * Internal helper method for 2D array division with zero-handling and specified dimensions.
     *
     * @param len the desired length of the result array
     * @param rowLen the desired length of each row
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA default value for missing elements in a
     * @param valueForNoneB default value for missing elements in b
     * @param defaultValueForZero the value to use when a divisor is zero
     * @return the result array with specified dimensions
     */
    private static short[][] dividedBy(final int len, final int rowLen, final short[][] a, final short[][] b, final short valueForNoneA,
            final short valueForNoneB, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, (short[]) null, null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 2D short arrays with a default value for zero divisors.
     * Operations are performed left to right with zero-handling at each step.
     *
     * @param a the dividend array, can be null or empty
     * @param b the first divisor array, can be null or empty
     * @param c the second divisor array, can be null or empty
     * @param defaultValueForZero the value to use when a divisor is zero
     * @return a new 2D array containing the element-wise quotient with zero-handling
     */
    public static short[][] dividedBy(final short[][] a, final short[][] b, final short[][] c, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs element-wise division of three 2D short arrays with configurable default values.
     * This method divides corresponding elements from arrays a, b, and c, handling missing values
     * and division by zero cases.
     *
     * <p>Example usage:
     * <pre>
     * short[][] a = {{10, 20}, {30, 40}};
     * short[][] b = {{2, 4}, {5, 8}};
     * short[][] c = {{1, 1}, {2, 2}};
     * short[][] result = dividedBy(a, b, c, (short)0, (short)1, (short)1, (short)-1);
     * // result will contain the element-wise division a[i][j] / (b[i][j] * c[i][j])
     * </pre></p>
     *
     * @param a the dividend array (numerator)
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA the value to use when element in array a is missing
     * @param valueForNoneB the value to use when element in array b is missing
     * @param valueForNoneC the value to use when element in array c is missing
     * @param defaultValueForZero the value to return when division by zero occurs
     * @return a new 2D array containing the element-wise division results
     */
    public static short[][] dividedBy(final short[][] a, final short[][] b, final short[][] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC, final short defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     * Internal helper method for performing element-wise division with specified dimensions.
     *
     * @param len the target length of the result array
     * @param rowLen the target length of each row in the result array
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param defaultValueForZero value to use when division by zero occurs
     * @return a new 2D array with division results
     */
    private static short[][] dividedBy(final int len, final int rowLen, final short[][] a, final short[][] b, final short[][] c, final short valueForNoneA,
            final short valueForNoneB, final short valueForNoneC, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of two 3D short arrays.
     * Only processes elements that exist in both arrays (intersection).
     *
     * <p>Example usage:
     * <pre>
     * short[][][] a = {{{10, 20}}, {{30, 40}}};
     * short[][][] b = {{{2, 4}}, {{5, 8}}};
     * short[][][] result = dividedBy(a, b, (short)-1);
     * // Performs element-wise division with -1 as default for division by zero
     * </pre></p>
     *
     * @param a the dividend array (numerator)
     * @param b the divisor array (denominator)
     * @param defaultValueForZero the value to return when division by zero occurs
     * @return a new 3D array containing the division results, with size equal to the smaller input array
     */
    public static short[][][] dividedBy(final short[][][] a, final short[][][] b, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 3D short arrays with default values for missing elements.
     * This method can handle arrays of different sizes by using default values.
     *
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA the value to use when element in array a is missing
     * @param valueForNoneB the value to use when element in array b is missing
     * @param defaultValueForZero the value to return when division by zero occurs
     * @return a new 3D array with size equal to the larger input array
     */
    public static short[][][] dividedBy(final short[][][] a, final short[][][] b, final short valueForNoneA, final short valueForNoneB,
            final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of three 3D short arrays.
     * Only processes elements that exist in all three arrays (intersection).
     *
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param defaultValueForZero the value to return when division by zero occurs
     * @return a new 3D array with size equal to the smallest input array
     */
    public static short[][][] dividedBy(final short[][][] a, final short[][][] b, final short[][][] c, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs element-wise division of three 3D short arrays with default values for missing elements.
     * This is the most flexible division method, handling arrays of different sizes.
     *
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param defaultValueForZero value to use when division by zero occurs
     * @return a new 3D array with size equal to the largest input array
     */
    public static short[][][] dividedBy(final short[][][] a, final short[][][] b, final short[][][] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC, final short defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                    defaultValueForZero);
        }

        return result;
    }

    /**
     * Applies a binary function to corresponding elements of two 1D short arrays.
     * The result array length equals the smaller of the two input arrays.
     *
     * <p>Example usage:
     * <pre>
     * short[] a = {1, 2, 3, 4};
     * short[] b = {5, 6, 7};
     * short[] result = zip(a, b, (x, y) -> (short)(x + y));
     * // result will be {6, 8, 10}
     * </pre></p>
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param zipFunction the function to apply to corresponding elements
     * @return a new array containing the results of applying the function
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[] zip(final short[] a, final short[] b, final Throwables.ShortBiFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        return result;
    }

    /**
     * Applies a binary function to corresponding elements of two 1D short arrays with default values.
     * The result array length equals the larger of the two input arrays.
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param valueForNoneA default value to use when array a has no corresponding element
     * @param valueForNoneB default value to use when array b has no corresponding element
     * @param zipFunction the function to apply to elements
     * @return a new array containing the function results
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[] zip(final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB,
            final Throwables.ShortBiFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return zip(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Internal helper method for zipping arrays with specified length.
     *
     * @param <E> the type of exception that may be thrown
     * @param len the target length of the result array
     * @param a the first input array
     * @param b the second input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param zipFunction the function to apply
     * @return a new array with zip results
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> short[] zip(final int len, final short[] a, final short[] b, final short valueForNoneA, final short valueForNoneB,
            final Throwables.ShortBiFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zipFunction.apply(valueForNoneA, b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zipFunction.apply(a[i], valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zipFunction.apply(valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Applies a ternary function to corresponding elements of three 1D short arrays.
     * The result array length equals the smallest of the three input arrays.
     *
     * <p>Example usage:
     * <pre>
     * short[] a = {1, 2, 3};
     * short[] b = {4, 5, 6};
     * short[] c = {7, 8, 9};
     * short[] result = zip(a, b, c, (x, y, z) -> (short)(x + y + z));
     * // result will be {12, 15, 18}
     * </pre></p>
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param c the third input array
     * @param zipFunction the function to apply to corresponding elements
     * @return a new array containing the function results
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[] zip(final short[] a, final short[] b, final short[] c, final Throwables.ShortTriFunction<Short, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Applies a ternary function to corresponding elements of three 1D short arrays with default values.
     * The result array length equals the largest of the three input arrays.
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param c the third input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param zipFunction the function to apply to elements
     * @return a new array containing the function results
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[] zip(final short[] a, final short[] b, final short[] c, final short valueForNoneA, final short valueForNoneB,
            final short valueForNoneC, final Throwables.ShortTriFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return zip(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
    }

    /**
     * Internal helper method for zipping three arrays with specified length.
     *
     * @param <E> the type of exception that may be thrown
     * @param len the target length of the result array
     * @param a the first input array
     * @param b the second input array
     * @param c the third input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param zipFunction the function to apply
     * @return a new array with zip results
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> short[] zip(final int len, final short[] a, final short[] b, final short[] c, final short valueForNoneA,
            final short valueForNoneB, final short valueForNoneC, final Throwables.ShortTriFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[] result = new short[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Applies a binary function to corresponding elements of two 2D short arrays.
     * Processes only the overlapping portion of the arrays.
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param zipFunction the function to apply to corresponding elements
     * @return a new 2D array containing the function results
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[][] zip(final short[][] a, final short[][] b, final Throwables.ShortBiFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a binary function to corresponding elements of two 2D short arrays with default values.
     * Can handle arrays of different sizes by using default values for missing elements.
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param zipFunction the function to apply to elements
     * @return a new 2D array containing the function results
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[][] zip(final short[][] a, final short[][] b, final short valueForNoneA, final short valueForNoneB,
            final Throwables.ShortBiFunction<Short, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Internal helper method for zipping 2D arrays with specified dimensions.
     *
     * @param <E> the type of exception that may be thrown
     * @param len the target length of the result array
     * @param rowLen the target length of each row
     * @param a the first input array
     * @param b the second input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param zipFunction the function to apply
     * @return a new 2D array with zip results
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> short[][] zip(final int len, final int rowLen, final short[][] a, final short[][] b, final short valueForNoneA,
            final short valueForNoneB, final Throwables.ShortBiFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zip(rowLen, null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zip(rowLen, a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zip(rowLen, null, null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Applies a ternary function to corresponding elements of three 2D short arrays.
     * Processes only the overlapping portion of all three arrays.
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param c the third input array
     * @param zipFunction the function to apply to corresponding elements
     * @return a new 2D array containing the function results
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[][] zip(final short[][] a, final short[][] b, final short[][] c,
            final Throwables.ShortTriFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a ternary function to corresponding elements of three 2D short arrays with default values.
     * Can handle arrays of different sizes by using default values for missing elements.
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param c the third input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param zipFunction the function to apply to elements
     * @return a new 2D array containing the function results
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[][] zip(final short[][] a, final short[][] b, final short[][] c, final short valueForNoneA,
            final short valueForNoneB, final short valueForNoneC, final Throwables.ShortTriFunction<Short, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC, zipFunction);
    }

    /**
     * Internal helper method for zipping three 2D arrays with specified dimensions.
     *
     * @param <E> the type of exception that may be thrown
     * @param len the target length of the result array
     * @param rowLen the target length of each row
     * @param a the first input array
     * @param b the second input array
     * @param c the third input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param zipFunction the function to apply
     * @return a new 2D array with zip results
     * @throws E if the zip function throws an exception
     */
    private static <E extends Exception> short[][] zip(final int len, final int rowLen, final short[][] a, final short[][] b, final short[][] c,
            final short valueForNoneA, final short valueForNoneB, final short valueForNoneC, final Throwables.ShortTriFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][] result = new short[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zip(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                        zipFunction);
            }
        }

        return result;
    }

    /**
     * Applies a binary function to corresponding elements of two 3D short arrays.
     * Processes only the overlapping portion of the arrays.
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param zipFunction the function to apply to corresponding elements
     * @return a new 3D array containing the function results
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[][][] zip(final short[][][] a, final short[][][] b, final Throwables.ShortBiFunction<Short, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a binary function to corresponding elements of two 3D short arrays with default values.
     * Can handle arrays of different sizes by using default values for missing elements.
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param zipFunction the function to apply to elements
     * @return a new 3D array containing the function results
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[][][] zip(final short[][][] a, final short[][][] b, final short valueForNoneA, final short valueForNoneB,
            final Throwables.ShortBiFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final short[][][] result = new short[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = zip(a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = zip(null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = zip(a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Applies a ternary function to corresponding elements of three 3D short arrays.
     * Processes only the overlapping portion of all three arrays.
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param c the third input array
     * @param zipFunction the function to apply to corresponding elements
     * @return a new 3D array containing the function results
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[][][] zip(final short[][][] a, final short[][][] b, final short[][][] c,
            final Throwables.ShortTriFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a ternary function to corresponding elements of three 3D short arrays with default values.
     * Can handle arrays of different sizes by using default values for missing elements.
     *
     * @param <E> the type of exception that the zip function may throw
     * @param a the first input array
     * @param b the second input array
     * @param c the third input array
     * @param valueForNoneA default value for missing elements in array a
     * @param valueForNoneB default value for missing elements in array b
     * @param valueForNoneC default value for missing elements in array c
     * @param zipFunction the function to apply to elements
     * @return a new 3D array containing the function results
     * @throws E if the zip function throws an exception
     */
    public static <E extends Exception> short[][][] zip(final short[][][] a, final short[][][] b, final short[][][] c, final short valueForNoneA,
            final short valueForNoneB, final short valueForNoneC, final Throwables.ShortTriFunction<Short, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final short[][][] result = new short[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = zip(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = zip(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        return result;
    }

    /**
     * Calculates the total number of elements in a 2D short array.
     * Handles null arrays and null sub-arrays gracefully.
     *
     * <p>Example usage:
     * <pre>
     * short[][] array = {{1, 2, 3}, {4, 5}, null, {6, 7, 8, 9}};
     * long count = totalCountOfElements(array);
     * // count will be 9 (3 + 2 + 0 + 4)
     * </pre></p>
     *
     * @param a the 2D array to count elements in
     * @return the total number of elements across all sub-arrays
     */
    public static long totalCountOfElements(final short[][] a) {
        long count = 0;

        for (final short[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        return count;
    }

    /**
     * Calculates the total number of elements in a 3D short array.
     * Handles null arrays and null sub-arrays at all levels gracefully.
     *
     * @param a the 3D array to count elements in
     * @return the total number of elements across all sub-arrays
     */
    public static long totalCountOfElements(final short[][][] a) {
        long count = 0;

        for (final short[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final short[] shorts : element) {
                if (N.isEmpty(shorts)) {
                    continue;
                }

                count += shorts.length;
            }
        }

        return count;
    }

    /**
     * Finds the minimum length among all sub-arrays in a 2D short array.
     * Returns 0 if the array is null or contains only null sub-arrays.
     *
     * <p>Example usage:
     * <pre>
     * short[][] array = {{1, 2, 3}, {4, 5}, {6, 7, 8, 9}};
     * int minLen = minSubArrayLen(array);
     * // minLen will be 2
     * </pre></p>
     *
     * @param a the 2D array to examine
     * @return the minimum length of any sub-array, or 0 if array is null
     */
    public static int minSubArrayLen(final short[][] a) {
        if (a == null) {
            return 0;
        }

        int minLen = 0;

        for (final short[] shorts : a) {
            minLen = N.min(minLen, shorts == null ? 0 : shorts.length);
        }

        return minLen;
    }

    /**
     * Finds the maximum length among all sub-arrays in a 2D short array.
     * Returns 0 if the array is null or empty.
     *
     * <p>Example usage:
     * <pre>
     * short[][] array = {{1, 2, 3}, {4, 5}, {6, 7, 8, 9}};
     * int maxLen = maxSubArrayLen(array);
     * // maxLen will be 4
     * </pre></p>
     *
     * @param a the 2D array to examine
     * @return the maximum length of any sub-array, or 0 if array is null or empty
     */
    public static int maxSubArrayLen(final short[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int maxLen = 0;

        for (final short[] ae : a) {
            maxLen = N.max(maxLen, ae == null ? 0 : ae.length);
        }

        return maxLen;
    }

    /**
     * Prints a 1D short array to the console in a formatted string representation.
     * Handles null arrays gracefully.
     *
     * <p>Example usage:
     * <pre>
     * short[] array = {1, 2, 3, 4, 5};
     * println(array);
     * // Prints: [1, 2, 3, 4, 5]
     * </pre></p>
     *
     * @param a the array to print
     * @return the string representation that was printed
     */
    public static String println(final short[] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            return N.println(N.toString(a));
        }
    }

    /**
     * Prints a 2D short array to the console in a formatted string representation.
     * Each sub-array is printed on a new line for clarity.
     *
     * <p>Example usage:
     * <pre>
     * short[][] array = {{1, 2}, {3, 4, 5}, {6}};
     * println(array);
     * // Prints formatted 2D array representation
     * </pre></p>
     *
     * @param a the 2D array to print
     * @return the string representation that was printed
     */
    public static String println(final short[][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final short[] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(", ");
                            }

                            sb.append(ai[j]);
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Prints a 3D short array to the console in a formatted string representation.
     * Uses indentation and line breaks to show the array structure clearly.
     *
     * @param a the 3D array to print
     * @return the string representation that was printed
     */
    public static String println(final short[][][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final short[][] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(',').append(IOUtil.LINE_SEPARATOR).append("  ");
                            }

                            if (ai[j] == null) {
                                sb.append("null");
                            } else if (ai[j].length == 0) {
                                sb.append("[]");
                            } else {
                                final short[] aij = ai[j];
                                sb.append('[');

                                for (int k = 0, aijLen = aij.length; k < aijLen; k++) {
                                    if (k > 0) {
                                        sb.append(", ");
                                    }

                                    sb.append(aij[k]);
                                }

                                sb.append(']');
                            }
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Adds the specified value to each element of the given array in-place.
     *
     * <p>This method modifies the original array by adding the parameter value to each element.
     * If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[] arr = {1, 2, 3};
     * Arrays.plus(arr, 5);
     * // arr is now {6, 7, 8}
     * </pre>
     *
     * @param a the array to be modified
     * @param param the value to add to each element
     */
    public static void plus(final int[] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] += param;
        }
    }

    /**
     * Adds the specified value to each element of the given 2D array in-place.
     *
     * <p>This method modifies the original 2D array by adding the parameter value to each element
     * in all sub-arrays. If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][] arr = {{1, 2}, {3, 4}};
     * Arrays.plus(arr, 10);
     * // arr is now {{11, 12}, {13, 14}}
     * </pre>
     *
     * @param a the 2D array to be modified
     * @param param the value to add to each element
     */
    public static void plus(final int[][] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[] element : a) {
            plus(element, param);
        }
    }

    /**
     * Adds the specified value to each element of the given 3D array in-place.
     *
     * <p>This method modifies the original 3D array by adding the parameter value to each element
     * in all nested arrays. If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][][] arr = {{{1, 2}}, {{3, 4}}};
     * Arrays.plus(arr, 5);
     * // arr is now {{{6, 7}}, {{8, 9}}}
     * </pre>
     *
     * @param a the 3D array to be modified
     * @param param the value to add to each element
     */
    public static void plus(final int[][][] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[][] element : a) {
            plus(element, param);
        }
    }

    /**
     * Subtracts the specified value from each element of the given array in-place.
     *
     * <p>This method modifies the original array by subtracting the parameter value from each element.
     * If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[] arr = {10, 20, 30};
     * Arrays.minus(arr, 5);
     * // arr is now {5, 15, 25}
     * </pre>
     *
     * @param a the array to be modified
     * @param param the value to subtract from each element
     */
    public static void minus(final int[] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] -= param;
        }
    }

    /**
     * Subtracts the specified value from each element of the given 2D array in-place.
     *
     * <p>This method modifies the original 2D array by subtracting the parameter value from each element
     * in all sub-arrays. If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][] arr = {{10, 20}, {30, 40}};
     * Arrays.minus(arr, 5);
     * // arr is now {{5, 15}, {25, 35}}
     * </pre>
     *
     * @param a the 2D array to be modified
     * @param param the value to subtract from each element
     */
    public static void minus(final int[][] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[] element : a) {
            minus(element, param);
        }
    }

    /**
     * Subtracts the specified value from each element of the given 3D array in-place.
     *
     * <p>This method modifies the original 3D array by subtracting the parameter value from each element
     * in all nested arrays. If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][][] arr = {{{10, 20}}, {{30, 40}}};
     * Arrays.minus(arr, 5);
     * // arr is now {{{5, 15}}, {{25, 35}}}
     * </pre>
     *
     * @param a the 3D array to be modified
     * @param param the value to subtract from each element
     */
    public static void minus(final int[][][] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[][] element : a) {
            minus(element, param);
        }
    }

    /**
     * Multiplies each element of the given array by the specified value in-place.
     *
     * <p>This method modifies the original array by multiplying each element by the parameter value.
     * If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[] arr = {2, 3, 4};
     * Arrays.multipliedBy(arr, 5);
     * // arr is now {10, 15, 20}
     * </pre>
     *
     * @param a the array to be modified
     * @param param the value to multiply each element by
     */
    public static void multipliedBy(final int[] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] *= param;
        }
    }

    /**
     * Multiplies each element of the given 2D array by the specified value in-place.
     *
     * <p>This method modifies the original 2D array by multiplying each element in all sub-arrays
     * by the parameter value. If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][] arr = {{1, 2}, {3, 4}};
     * Arrays.multipliedBy(arr, 3);
     * // arr is now {{3, 6}, {9, 12}}
     * </pre>
     *
     * @param a the 2D array to be modified
     * @param param the value to multiply each element by
     */
    public static void multipliedBy(final int[][] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     * Multiplies each element of the given 3D array by the specified value in-place.
     *
     * <p>This method modifies the original 3D array by multiplying each element in all nested arrays
     * by the parameter value. If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][][] arr = {{{2, 4}}, {{6, 8}}};
     * Arrays.multipliedBy(arr, 2);
     * // arr is now {{{4, 8}}, {{12, 16}}}
     * </pre>
     *
     * @param a the 3D array to be modified
     * @param param the value to multiply each element by
     */
    public static void multipliedBy(final int[][][] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[][] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     * Divides each element of the given array by the specified value in-place.
     *
     * <p>This method modifies the original array by dividing each element by the parameter value.
     * Note that integer division is performed, so results are truncated to integers.
     * If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[] arr = {10, 20, 30};
     * Arrays.dividedBy(arr, 5);
     * // arr is now {2, 4, 6}
     * </pre>
     *
     * @param a the array to be modified
     * @param param the value to divide each element by
     * @throws ArithmeticException if param is zero
     */
    public static void dividedBy(final int[] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] /= param;
        }
    }

    /**
     * Divides each element of the given 2D array by the specified value in-place.
     *
     * <p>This method modifies the original 2D array by dividing each element in all sub-arrays
     * by the parameter value. Integer division is performed, so results are truncated.
     * If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][] arr = {{20, 40}, {60, 80}};
     * Arrays.dividedBy(arr, 10);
     * // arr is now {{2, 4}, {6, 8}}
     * </pre>
     *
     * @param a the 2D array to be modified
     * @param param the value to divide each element by
     * @throws ArithmeticException if param is zero
     */
    public static void dividedBy(final int[][] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     * Divides each element of the given 3D array by the specified value in-place.
     *
     * <p>This method modifies the original 3D array by dividing each element in all nested arrays
     * by the parameter value. Integer division is performed, so results are truncated.
     * If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][][] arr = {{{100, 200}}, {{300, 400}}};
     * Arrays.dividedBy(arr, 50);
     * // arr is now {{{2, 4}}, {{6, 8}}}
     * </pre>
     *
     * @param a the 3D array to be modified
     * @param param the value to divide each element by
     * @throws ArithmeticException if param is zero
     */
    public static void dividedBy(final int[][][] a, final int param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[][] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     * Updates all elements of the given array by applying the specified unary operator.
     *
     * <p>This method modifies the original array by applying the operator function to each element.
     * The operator can throw a checked exception of type E. If the array is null or empty,
     * the method returns without performing any operation.</p>
     *
     * <pre>
     * int[] arr = {1, 2, 3};
     * Arrays.updateAll(arr, x -> x * x);
     * // arr is now {1, 4, 9}
     * </pre>
     *
     * @param <E> the type of exception that the operator may throw
     * @param a the array to be modified
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final int[] a, final Throwables.IntUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsInt(a[i]);
        }
    }

    /**
     * Updates all elements of the given 2D array by applying the specified unary operator.
     *
     * <p>This method modifies the original 2D array by applying the operator function to each element
     * in all sub-arrays. The operator can throw a checked exception of type E.
     * If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][] arr = {{1, 2}, {3, 4}};
     * Arrays.updateAll(arr, x -> x + 10);
     * // arr is now {{11, 12}, {13, 14}}
     * </pre>
     *
     * @param <E> the type of exception that the operator may throw
     * @param a the 2D array to be modified
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final int[][] a, final Throwables.IntUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Updates all elements of the given 3D array by applying the specified unary operator.
     *
     * <p>This method modifies the original 3D array by applying the operator function to each element
     * in all nested arrays. The operator can throw a checked exception of type E.
     * If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][][] arr = {{{1, 2}}, {{3, 4}}};
     * Arrays.updateAll(arr, x -> x * 2);
     * // arr is now {{{2, 4}}, {{6, 8}}}
     * </pre>
     *
     * @param <E> the type of exception that the operator may throw
     * @param a the 3D array to be modified
     * @param operator the unary operator to apply to each element
     * @throws E if the operator throws an exception
     */
    public static <E extends Exception> void updateAll(final int[][][] a, final Throwables.IntUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[][] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Replaces elements in the array that match the given predicate with the specified new value.
     *
     * <p>This method modifies the original array by testing each element with the predicate
     * and replacing matching elements with the new value. The predicate can throw a checked
     * exception of type E. If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[] arr = {1, 2, 3, 4, 5};
     * Arrays.replaceIf(arr, x -> x % 2 == 0, 0);
     * // arr is now {1, 0, 3, 0, 5}
     * </pre>
     *
     * @param <E> the type of exception that the predicate may throw
     * @param a the array to be modified
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final int[] a, final Throwables.IntPredicate<E> predicate, final int newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
            }
        }
    }

    /**
     * Replaces elements in the 2D array that match the given predicate with the specified new value.
     *
     * <p>This method modifies the original 2D array by testing each element in all sub-arrays
     * with the predicate and replacing matching elements with the new value.
     * If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][] arr = {{1, 2}, {3, 4}};
     * Arrays.replaceIf(arr, x -> x > 2, 10);
     * // arr is now {{1, 2}, {10, 10}}
     * </pre>
     *
     * @param <E> the type of exception that the predicate may throw
     * @param a the 2D array to be modified
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final int[][] a, final Throwables.IntPredicate<E> predicate, final int newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Replaces elements in the 3D array that match the given predicate with the specified new value.
     *
     * <p>This method modifies the original 3D array by testing each element in all nested arrays
     * with the predicate and replacing matching elements with the new value.
     * If the array is null or empty, the method returns without performing any operation.</p>
     *
     * <pre>
     * int[][][] arr = {{{1, 2}}, {{3, 4}}};
     * Arrays.replaceIf(arr, x -> x < 3, 0);
     * // arr is now {{{0, 0}}, {{3, 4}}}
     * </pre>
     *
     * @param <E> the type of exception that the predicate may throw
     * @param a the 3D array to be modified
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @throws E if the predicate throws an exception
     */
    public static <E extends Exception> void replaceIf(final int[][][] a, final Throwables.IntPredicate<E> predicate, final int newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final int[][] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Reshapes a 1D array into a 2D array with the specified number of columns.
     *
     * <p>This method creates a new 2D array by dividing the input array into rows of the specified
     * column count. The last row may contain fewer elements if the array length is not evenly
     * divisible by the column count. If the input array is null or empty, returns an empty 2D array.</p>
     *
     * <pre>
     * int[] arr = {1, 2, 3, 4, 5, 6, 7};
     * int[][] result = Arrays.reshape(arr, 3);
     * // result is {{1, 2, 3}, {4, 5, 6}, {7}}
     * </pre>
     *
     * @param a the 1D array to reshape
     * @param cols the number of columns in each row
     * @return a new 2D array containing the reshaped data
     * @throws IllegalArgumentException if cols is less than 1
     */
    public static int[][] reshape(final int[] a, final int cols) throws IllegalArgumentException {
        checkMForReshape(cols);

        if (N.isEmpty(a)) {
            return new int[0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, cols, RoundingMode.CEILING);
        final int[][] c = new int[n][];

        for (int i = 0, from = 0; i < n; i++, from += cols) {
            c[i] = N.copyOfRange(a, from, from + N.min(len - from, cols));
        }

        return c;
    }

    /**
     * Reshapes a 1D array into a 3D array with the specified dimensions.
     *
     * <p>This method creates a new 3D array by dividing the input array first into matrices
     * of the specified row and column counts. Each matrix may be incomplete if the array length
     * is not evenly divisible by rows  cols. If the input array is null or empty, returns an empty 3D array.</p>
     *
     * <pre>
     * int[] arr = {1, 2, 3, 4, 5, 6, 7, 8};
     * int[][][] result = Arrays.reshape(arr, 2, 2);
     * // result is {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}
     * </pre>
     *
     * @param a the 1D array to reshape
     * @param rows the number of rows in each 2D matrix
     * @param cols the number of columns in each row
     * @return a new 3D array containing the reshaped data
     * @throws IllegalArgumentException if rows or cols is less than 1
     */
    public static int[][][] reshape(final int[] a, final int rows, final int cols) throws IllegalArgumentException {
        checkMAndLForReshape(rows, cols);

        if (N.isEmpty(a)) {
            return new int[0][0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, rows * cols, RoundingMode.CEILING);
        final int[][][] c = new int[n][][];

        for (int i = 0, from = 0; i < n; i++) {
            c[i] = new int[N.min(rows, Numbers.divide(len - from, cols, RoundingMode.CEILING))][];

            for (int j = 0, y = c[i].length; j < y; j++, from += cols) {
                c[i][j] = N.copyOfRange(a, from, from + N.min(len - from, cols));
            }
        }

        return c;
    }

    /**
     * Flattens a 2D array into a 1D array.
     *
     * <p>This method creates a new 1D array containing all elements from the 2D array
     * in row-major order. Empty sub-arrays are skipped. If the input array is null or empty,
     * returns an empty array.</p>
     *
     * <pre>
     * int[][] arr = {{1, 2, 3}, {4, 5}, {6, 7, 8}};
     * int[] result = Arrays.flatten(arr);
     * // result is {1, 2, 3, 4, 5, 6, 7, 8}
     * </pre>
     *
     * @param a the 2D array to flatten
     * @return a new 1D array containing all elements from the input array
     */
    public static int[] flatten(final int[][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_INT_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final int[] c = new int[count];
        int from = 0;

        for (final int[] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            N.copy(element, 0, c, from, element.length);

            from += element.length;
        }

        return c;
    }

    /**
     * Flattens a 3D array into a 1D array.
     *
     * <p>This method creates a new 1D array containing all elements from the 3D array
     * in depth-first order. Empty sub-arrays at any level are skipped. If the input array
     * is null or empty, returns an empty array.</p>
     *
     * <pre>
     * int[][][] arr = {{{1, 2}, {3}}, {{4, 5, 6}}};
     * int[] result = Arrays.flatten(arr);
     * // result is {1, 2, 3, 4, 5, 6}
     * </pre>
     *
     * @param a the 3D array to flatten
     * @return a new 1D array containing all elements from the input array
     */
    public static int[] flatten(final int[][][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_INT_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final int[] c = new int[count];
        int from = 0;

        for (final int[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final int[] ints : element) {
                if (N.isEmpty(ints)) {
                    continue;
                }

                N.copy(ints, 0, c, from, ints.length);

                from += ints.length;
            }
        }

        return c;
    }

    /**
     * Flattens a 2D array, applies the given operation, and updates the original array with the results.
     *
     * <p>This method provides a convenient way to apply operations that work on 1D arrays to 2D arrays.
     * The array is flattened, the operation is applied to the flattened array, and then the values
     * are copied back to the original 2D array structure.</p>
     *
     * <pre>
     * int[][] arr = {{3, 1, 4}, {1, 5, 9}};
     * Arrays.flatOp(arr, t -> N.sort(t));
     * // arr is now {{1, 1, 3}, {4, 5, 9}}
     * </pre>
     *
     * @param <E> the type of exception that the operation may throw
     * @param a the 2D array to process
     * @param op the operation to apply to the flattened array
     * @throws E if the operation throws an exception
     */
    public static <E extends Exception> void flatOp(final int[][] a, final Throwables.Consumer<? super int[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final int[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final int[] e : a) {
            if (N.notEmpty(e)) {
                N.copy(tmp, idx, e, 0, e.length);
                idx += e.length;
            }
        }
    }

    /**
     * Flattens a 3D array, applies the given operation, and updates the original array with the results.
     *
     * <p>This method provides a convenient way to apply operations that work on 1D arrays to 3D arrays.
     * The array is flattened, the operation is applied to the flattened array, and then the values
     * are copied back to the original 3D array structure.</p>
     *
     * <pre>
     * int[][][] arr = {{{5, 2}}, {{8, 1}}};
     * Arrays.flatOp(arr, t -> N.sort(t));
     * // arr is now {{{1, 2}}, {{5, 8}}}
     * </pre>
     *
     * @param <E> the type of exception that the operation may throw
     * @param a the 3D array to process
     * @param op the operation to apply to the flattened array
     * @throws E if the operation throws an exception
     */
    public static <E extends Exception> void flatOp(final int[][][] a, final Throwables.Consumer<? super int[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final int[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final int[][] e : a) {
            if (N.notEmpty(e)) {
                for (final int[] ee : e) {
                    if (N.notEmpty(ee)) {
                        N.copy(tmp, idx, ee, 0, ee.length);
                        idx += ee.length;
                    }
                }
            }
        }
    }

    /**
     * Performs element-wise addition of two arrays.
     *
     * <p>This method creates a new array containing the element-wise sum of the input arrays.
     * The result array length is the minimum of the two input array lengths. If either array
     * is null or empty, the result length will be zero.</p>
     *
     * <pre>
     * int[] a = {1, 2, 3, 4};
     * int[] b = {5, 6, 7};
     * int[] result = Arrays.add(a, b);
     * // result is {6, 8, 10}
     * </pre>
     *
     * @param a the first array
     * @param b the second array
     * @return a new array containing the element-wise sum
     */
    public static int[] add(final int[] a, final int[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] + b[i];
        }

        return result;
    }

    /**
     * Performs element-wise addition of two arrays with default values for missing elements.
     *
     * <p>This method creates a new array containing the element-wise sum of the input arrays.
     * When one array is shorter than the other, the specified default values are used for
     * the missing elements. The result array length is the maximum of the two input array lengths.</p>
     *
     * <pre>
     * int[] a = {1, 2, 3};
     * int[] b = {4, 5};
     * int[] result = Arrays.add(a, b, 0, 10);
     * // result is {5, 7, 13} (3 + 10 for the last element)
     * </pre>
     *
     * @param a the first array
     * @param b the second array
     * @param valueForNoneA the default value to use when array a has no element at a position
     * @param valueForNoneB the default value to use when array b has no element at a position
     * @return a new array containing the element-wise sum with defaults
     */
    public static int[] add(final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return add(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Performs element-wise addition of two arrays with specified result length and default values.
     *
     * <p>This private helper method implements the core logic for array addition with default values.
     * It handles all cases where arrays may have different lengths or the result length differs
     * from both input arrays.</p>
     *
     * @param len the desired length of the result array
     * @param a the first array
     * @param b the second array
     * @param valueForNoneA the default value to use when array a has no element at a position
     * @param valueForNoneB the default value to use when array b has no element at a position
     * @return a new array containing the element-wise sum with defaults
     */
    private static int[] add(final int len, final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] + b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA + b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] + valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA + valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of three arrays.
     *
     * <p>This method creates a new array containing the element-wise sum of the three input arrays.
     * The result array length is the minimum of the three input array lengths. If any array
     * is null or empty, it may affect the result length.</p>
     *
     * <pre>
     * int[] a = {1, 2, 3};
     * int[] b = {4, 5, 6};
     * int[] c = {7, 8};
     * int[] result = Arrays.add(a, b, c);
     * // result is {12, 15} (1+4+7, 2+5+8)
     * </pre>
     *
     * @param a the first array
     * @param b the second array
     * @param c the third array
     * @return a new array containing the element-wise sum
     */
    public static int[] add(final int[] a, final int[] b, final int[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] + b[i] + c[i];
        }

        return result;
    }

    /**
     * Performs element-wise addition of three arrays with default values for missing elements.
     *
     * <p>This method creates a new array containing the element-wise sum of the three input arrays.
     * When any array is shorter than the others, the specified default values are used for
     * the missing elements. The result array length is the maximum of the three input array lengths.</p>
     *
     * <pre>
     * int[] a = {1, 2, 3};
     * int[] b = {4, 5};
     * int[] c = {7};
     * int[] result = Arrays.add(a, b, c, 0, 10, 20);
     * // result is {12, 17, 23} (1+4+7, 2+5+20, 3+10+20)
     * </pre>
     *
     * @param a the first array
     * @param b the second array
     * @param c the third array
     * @param valueForNoneA the default value to use when array a has no element at a position
     * @param valueForNoneB the default value to use when array b has no element at a position
     * @param valueForNoneC the default value to use when array c has no element at a position
     * @return a new array containing the element-wise sum with defaults
     */
    public static int[] add(final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB, final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return add(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Performs element-wise addition of three arrays with specified result length and default values.
     *
     * <p>This private helper method implements the core logic for three-array addition with default values.
     * It efficiently handles all cases where arrays may have different lengths.</p>
     *
     * @param len the desired length of the result array
     * @param a the first array
     * @param b the second array
     * @param c the third array
     * @param valueForNoneA the default value to use when array a has no element at a position
     * @param valueForNoneB the default value to use when array b has no element at a position
     * @param valueForNoneC the default value to use when array c has no element at a position
     * @return a new array containing the element-wise sum with defaults
     */
    private static int[] add(final int len, final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] + b[i] + c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) + (i < lenB ? b[i] : valueForNoneB) + (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of two 2D arrays.
     *
     * <p>This method creates a new 2D array containing the element-wise sum of the input arrays.
     * Addition is performed on corresponding sub-arrays. The result array length is the minimum
     * of the two input array lengths.</p>
     *
     * <pre>
     * int[][] a = {{1, 2}, {3, 4}};
     * int[][] b = {{5, 6}, {7, 8}};
     * int[][] result = Arrays.add(a, b);
     * // result is {{6, 8}, {10, 12}}
     * </pre>
     *
     * @param a the first 2D array
     * @param b the second 2D array
     * @return a new 2D array containing the element-wise sum
     */
    public static int[][] add(final int[][] a, final int[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of two 2D arrays with default values for missing elements.
     *
     * <p>This method creates a new 2D array containing the element-wise sum of the input arrays.
     * When arrays have different dimensions, the specified default values are used for missing elements.
     * The result dimensions match the maximum dimensions of the input arrays.</p>
     *
     * <pre>
     * int[][] a = {{1, 2}, {3}};
     * int[][] b = {{4, 5, 6}};
     * int[][] result = Arrays.add(a, b, 0, 10);
     * // result is {{5, 7, 16}, {13, 10, 10}}
     * </pre>
     *
     * @param a the first 2D array
     * @param b the second 2D array
     * @param valueForNoneA the default value to use when array a has no element at a position
     * @param valueForNoneB the default value to use when array b has no element at a position
     * @return a new 2D array containing the element-wise sum with defaults
     */
    public static int[][] add(final int[][] a, final int[][] b, final int valueForNoneA, final int valueForNoneB) {
        return add(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Performs element-wise addition of two 2D arrays with specified dimensions and default values.
     *
     * <p>This private helper method implements the core logic for 2D array addition with default values.
     * It handles all cases where arrays may have different dimensions at both the outer and inner levels.</p>
     *
     * @param len the desired number of rows in the result array
     * @param rowLen the desired number of columns in each row
     * @param a the first 2D array
     * @param b the second 2D array
     * @param valueForNoneA the default value to use when array a has no element at a position
     * @param valueForNoneB the default value to use when array b has no element at a position
     * @return a new 2D array containing the element-wise sum with defaults
     */
    private static int[][] add(final int len, final int rowLen, final int[][] a, final int[][] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = add(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = add(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = add(rowLen, (int[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 2D arrays.
     *
     * <p>This method creates a new 2D array containing the element-wise sum of the three input arrays.
     * Addition is performed on corresponding sub-arrays. The result array length is the minimum
     * of the three input array lengths.</p>
     *
     * <pre>
     * int[][] a = {{1, 2}, {3, 4}};
     * int[][] b = {{5, 6}, {7, 8}};
     * int[][] c = {{9, 10}, {11, 12}};
     * int[][] result = Arrays.add(a, b, c);
     * // result is {{15, 18}, {21, 24}}
     * </pre>
     *
     * @param a the first 2D array
     * @param b the second 2D array
     * @param c the third 2D array
     * @return a new 2D array containing the element-wise sum
     */
    public static int[][] add(final int[][] a, final int[][] b, final int[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 2D arrays with default values for missing elements.
     *
     * <p>This method creates a new 2D array containing the element-wise sum of the three input arrays.
     * When arrays have different dimensions, the specified default values are used for missing elements.
     * The result dimensions match the maximum dimensions of the input arrays.</p>
     *
     * <pre>
     * int[][] a = {{1, 2}, {3}};
     * int[][] b = {{4, 5}};
     * int[][] c = {{7}};
     * int[][] result = Arrays.add(a, b, c, 0, 10, 20);
     * // result is {{12, 37}, {33, 30}}
     * </pre>
     *
     * @param a the first 2D array
     * @param b the second 2D array
     * @param c the third 2D array
     * @param valueForNoneA the default value to use when array a has no element at a position
     * @param valueForNoneB the default value to use when array b has no element at a position
     * @param valueForNoneC the default value to use when array c has no element at a position
     * @return a new 2D array containing the element-wise sum with defaults
     */
    public static int[][] add(final int[][] a, final int[][] b, final int[][] c, final int valueForNoneA, final int valueForNoneB, final int valueForNoneC) {
        return add(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC);
    }

    /**
     * Performs element-wise addition of three 2D arrays with specified dimensions and default values.
     *
     * <p>This private helper method implements the core logic for three 2D array addition with default values.
     * It efficiently handles all cases where arrays may have different dimensions.</p>
     *
     * @param len the desired number of rows in the result array
     * @param rowLen the desired number of columns in each row
     * @param a the first 2D array
     * @param b the second 2D array
     * @param c the third 2D array
     * @param valueForNoneA the default value to use when array a has no element at a position
     * @param valueForNoneB the default value to use when array b has no element at a position
     * @param valueForNoneC the default value to use when array c has no element at a position
     * @return a new 2D array containing the element-wise sum with defaults
     */
    private static int[][] add(final int len, final int rowLen, final int[][] a, final int[][] b, final int[][] c, final int valueForNoneA,
            final int valueForNoneB, final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = add(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of two 3D arrays.
     *
     * <p>This method creates a new 3D array containing the element-wise sum of the input arrays.
     * Addition is performed on corresponding 2D sub-arrays. The result array length is the minimum
     * of the two input array lengths.</p>
     *
     * <pre>
     * int[][][] a = {{{1, 2}}, {{3, 4}}};
     * int[][][] b = {{{5, 6}}, {{7, 8}}};
     * int[][][] result = Arrays.add(a, b);
     * // result is {{{6, 8}}, {{10, 12}}}
     * </pre>
     *
     * @param a the first 3D array
     * @param b the second 3D array
     * @return a new 3D array containing the element-wise sum
     */
    public static int[][][] add(final int[][][] a, final int[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of two 3D arrays with default values for missing elements.
     *
     * <p>This method creates a new 3D array containing the element-wise sum of the input arrays.
     * When arrays have different dimensions at any level, the specified default values are used
     * for missing elements. The result dimensions match the maximum dimensions of the input arrays.</p>
     *
     * <pre>
     * int[][][] a = {{{1, 2}}, {{3}}};
     * int[][][] b = {{{4, 5, 6}}};
     * int[][][] result = Arrays.add(a, b, 0, 10);
     * // result is {{{5, 7, 16}}, {{13, 10, 10}}}
     * </pre>
     *
     * @param a the first 3D array
     * @param b the second 3D array
     * @param valueForNoneA the default value to use when array a has no element at a position
     * @param valueForNoneB the default value to use when array b has no element at a position
     * @return a new 3D array containing the element-wise sum with defaults
     */
    public static int[][][] add(final int[][][] a, final int[][][] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = add(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = add(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = add(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 3D integer arrays.
     * The result array length is determined by the minimum length among the three input arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}};
     * int[][][] b = {{{1, 1}, {1, 1}}, {{2, 2}, {2, 2}}};
     * int[][][] c = {{{0, 1}, {2, 3}}, {{4, 5}, {6, 7}}};
     * int[][][] result = Arrays.add(a, b, c);
     * // result[0][0][0] = 1 + 1 + 0 = 2
     * // result[0][0][1] = 2 + 1 + 1 = 4
     * </pre>
     *
     * @param a the first 3D array
     * @param b the second 3D array
     * @param c the third 3D array
     * @return a new 3D array containing the element-wise sum, with length equal to the minimum of the three input arrays
     */
    public static int[][][] add(final int[][][] a, final int[][][] b, final int[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise addition of three 3D integer arrays with default values for missing elements.
     * The result array length is determined by the maximum length among the three input arrays.
     * When an array is shorter than the maximum length, the specified default value is used for missing elements.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{1, 2}}, {{3, 4}}};
     * int[][][] b = {{{5, 6}}};  // shorter array
     * int[][][] c = {{{7, 8}}, {{9, 10}}, {{11, 12}}};  // longer array
     * int[][][] result = Arrays.add(a, b, c, 0, 1, 2);
     * // For index 1: a[1] exists, b[1] missing (use 1), c[1] exists
     * // For index 2: a[2] missing (use 0), b[2] missing (use 1), c[2] exists
     * </pre>
     *
     * @param a the first 3D array
     * @param b the second 3D array
     * @param c the third 3D array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @param valueForNoneC the default value to use for missing elements in array c
     * @return a new 3D array containing the element-wise sum, with length equal to the maximum of the three input arrays
     */
    public static int[][][] add(final int[][][] a, final int[][][] b, final int[][][] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = add(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = add(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 1D integer arrays (a - b).
     * The result array length is determined by the minimum length of the two input arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {10, 20, 30, 40};
     * int[] b = {1, 2, 3};
     * int[] result = Arrays.subtract(a, b);
     * // result = {9, 18, 27} (length is 3, the minimum)
     * </pre>
     *
     * @param a the minuend array
     * @param b the subtrahend array
     * @return a new array containing the element-wise difference, with length equal to the minimum of the two input arrays
     */
    public static int[] subtract(final int[] a, final int[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] - b[i];
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 1D integer arrays with default values for missing elements.
     * The result array length is determined by the maximum length of the two input arrays.
     * When an array is shorter than the maximum length, the specified default value is used for missing elements.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {10, 20, 30};
     * int[] b = {1, 2, 3, 4, 5};
     * int[] result = Arrays.subtract(a, b, 0, 1);
     * // For indices 3,4: a[3]=0, a[4]=0 (default), b[3]=4, b[4]=5
     * // result = {9, 18, 27, -4, -5}
     * </pre>
     *
     * @param a the minuend array
     * @param b the subtrahend array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @return a new array containing the element-wise difference, with length equal to the maximum of the two input arrays
     */
    public static int[] subtract(final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return subtract(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    // Private helper methods for subtract operations

    private static int[] subtract(final int len, final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] - b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA - b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] - valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA - valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 1D integer arrays (a - b - c).
     * The result array length is determined by the minimum length among the three input arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {100, 200, 300};
     * int[] b = {10, 20, 30};
     * int[] c = {1, 2, 3};
     * int[] result = Arrays.subtract(a, b, c);
     * // result = {89, 178, 267}
     * </pre>
     *
     * @param a the minuend array
     * @param b the first subtrahend array
     * @param c the second subtrahend array
     * @return a new array containing the element-wise difference, with length equal to the minimum of the three input arrays
     */
    public static int[] subtract(final int[] a, final int[] b, final int[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] - b[i] - c[i];
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 1D integer arrays with default values for missing elements.
     * The result array length is determined by the maximum length among the three input arrays.
     * When an array is shorter than the maximum length, the specified default value is used for missing elements.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {100, 200};
     * int[] b = {10, 20, 30};
     * int[] c = {1};
     * int[] result = Arrays.subtract(a, b, c, 0, 5, 2);
     * // For index 2: a[2]=0 (default), b[2]=30, c[2]=2 (default)
     * // result = {89, 178, -32}
     * </pre>
     *
     * @param a the minuend array
     * @param b the first subtrahend array
     * @param c the second subtrahend array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @param valueForNoneC the default value to use for missing elements in array c
     * @return a new array containing the element-wise difference, with length equal to the maximum of the three input arrays
     */
    public static int[] subtract(final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB, final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return subtract(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    // Private helper methods for subtract operations

    // Private helper methods for subtract operations

    private static int[] subtract(final int len, final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] - b[i] - c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) - (i < lenB ? b[i] : valueForNoneB) - (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 2D integer arrays (a - b).
     * The result array length is determined by the minimum length of the two input arrays.
     * Each sub-array is processed independently using element-wise subtraction.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{10, 20}, {30, 40}, {50, 60}};
     * int[][] b = {{1, 2}, {3, 4}};
     * int[][] result = Arrays.subtract(a, b);
     * // result = {{9, 18}, {27, 36}} (length is 2, the minimum)
     * </pre>
     *
     * @param a the minuend 2D array
     * @param b the subtrahend 2D array
     * @return a new 2D array containing the element-wise difference, with length equal to the minimum of the two input arrays
     */
    public static int[][] subtract(final int[][] a, final int[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 2D integer arrays with default values for missing elements.
     * The result array dimensions are determined by the maximum dimensions of the two input arrays.
     * When an array or sub-array is shorter, the specified default value is used for missing elements.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{10, 20}, {30}};
     * int[][] b = {{1, 2, 3}, {4, 5}, {6, 7}};
     * int[][] result = Arrays.subtract(a, b, 0, 1);
     * // Handles both different outer array lengths and different sub-array lengths
     * </pre>
     *
     * @param a the minuend 2D array
     * @param b the subtrahend 2D array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @return a new 2D array containing the element-wise difference, with dimensions equal to the maximum of the two input arrays
     */
    public static int[][] subtract(final int[][] a, final int[][] b, final int valueForNoneA, final int valueForNoneB) {
        return subtract(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    // Private helper methods for subtract operations

    private static int[][] subtract(final int len, final int rowLen, final int[][] a, final int[][] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = subtract(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = subtract(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = subtract(rowLen, (int[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 2D integer arrays (a - b - c).
     * The result array length is determined by the minimum length among the three input arrays.
     * Each sub-array is processed independently using element-wise subtraction.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{100, 200}, {300, 400}};
     * int[][] b = {{10, 20}, {30, 40}};
     * int[][] c = {{1, 2}, {3, 4}};
     * int[][] result = Arrays.subtract(a, b, c);
     * // result = {{89, 178}, {267, 356}}
     * </pre>
     *
     * @param a the minuend 2D array
     * @param b the first subtrahend 2D array
     * @param c the second subtrahend 2D array
     * @return a new 2D array containing the element-wise difference, with length equal to the minimum of the three input arrays
     */
    public static int[][] subtract(final int[][] a, final int[][] b, final int[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 2D integer arrays with default values for missing elements.
     * The result array dimensions are determined by the maximum dimensions among the three input arrays.
     * When an array or sub-array is shorter, the specified default value is used for missing elements.
     *
     * <p>This method handles arrays of different lengths at both the outer array level and sub-array level,
     * ensuring all elements are processed using the provided default values where necessary.
     *
     * @param a the minuend 2D array
     * @param b the first subtrahend 2D array
     * @param c the second subtrahend 2D array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @param valueForNoneC the default value to use for missing elements in array c
     * @return a new 2D array containing the element-wise difference, with dimensions equal to the maximum of the three input arrays
     */
    public static int[][] subtract(final int[][] a, final int[][] b, final int[][] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC) {
        return subtract(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    // Private helper methods for subtract operations

    /**
     * Performs element-wise subtraction of two 3D integer arrays (a - b).
     * The result array length is determined by the minimum length of the two input arrays.
     * Each 2D sub-array is processed independently using element-wise subtraction.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{10, 20}, {30, 40}}, {{50, 60}, {70, 80}}};
     * int[][][] b = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}};
     * int[][][] result = Arrays.subtract(a, b);
     * // result[0][0] = {9, 18}, result[0][1] = {27, 36}, etc.
     * </pre>
     *
     * @param a the minuend 3D array
     * @param b the subtrahend 3D array
     * @return a new 3D array containing the element-wise difference, with length equal to the minimum of the two input arrays
     */
    public static int[][][] subtract(final int[][][] a, final int[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of two 3D integer arrays with default values for missing elements.
     * The result array length is determined by the maximum length of the two input arrays.
     * When an array is shorter than the maximum length, the specified default value is used for missing elements.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{10, 20}}, {{30, 40}}};
     * int[][][] b = {{{1, 2}}};  // shorter array
     * int[][][] result = Arrays.subtract(a, b, 0, 5);
     * // For index 1: a[1] exists, b[1] missing (uses default 5)
     * </pre>
     *
     * @param a the minuend 3D array
     * @param b the subtrahend 3D array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @return a new 3D array containing the element-wise difference, with length equal to the maximum of the two input arrays
     */
    public static int[][][] subtract(final int[][][] a, final int[][][] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = subtract(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = subtract(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = subtract(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 3D integer arrays (a - b - c).
     * The result array length is determined by the minimum length among the three input arrays.
     * Each 2D sub-array is processed independently using element-wise subtraction.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{100, 200}}, {{300, 400}}};
     * int[][][] b = {{{10, 20}}, {{30, 40}}};
     * int[][][] c = {{{1, 2}}, {{3, 4}}};
     * int[][][] result = Arrays.subtract(a, b, c);
     * // result[0][0] = {89, 178}, etc.
     * </pre>
     *
     * @param a the minuend 3D array
     * @param b the first subtrahend 3D array
     * @param c the second subtrahend 3D array
     * @return a new 3D array containing the element-wise difference, with length equal to the minimum of the three input arrays
     */
    public static int[][][] subtract(final int[][][] a, final int[][][] b, final int[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise subtraction of three 3D integer arrays with default values for missing elements.
     * The result array length is determined by the maximum length among the three input arrays.
     * When an array is shorter than the maximum length, the specified default value is used for missing elements.
     *
     * <p>This method handles arrays of different lengths at all levels (3D, 2D, and 1D),
     * ensuring all elements are processed using the provided default values where necessary.
     *
     * @param a the minuend 3D array
     * @param b the first subtrahend 3D array
     * @param c the second subtrahend 3D array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @param valueForNoneC the default value to use for missing elements in array c
     * @return a new 3D array containing the element-wise difference, with length equal to the maximum of the three input arrays
     */
    public static int[][][] subtract(final int[][][] a, final int[][][] b, final int[][][] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = subtract(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = subtract(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    // Private helper methods for subtract operations

    private static int[][] subtract(final int len, final int rowLen, final int[][] a, final int[][] b, final int[][] c, final int valueForNoneA,
            final int valueForNoneB, final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = subtract(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 1D integer arrays (a * b).
     * The result array length is determined by the minimum length of the two input arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {2, 3, 4, 5};
     * int[] b = {10, 20, 30};
     * int[] result = Arrays.multipliedBy(a, b);
     * // result = {20, 60, 120} (length is 3, the minimum)
     * </pre>
     *
     * @param a the first multiplicand array
     * @param b the second multiplicand array
     * @return a new array containing the element-wise product, with length equal to the minimum of the two input arrays
     */
    public static int[] multipliedBy(final int[] a, final int[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] * b[i];
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 1D integer arrays with default values for missing elements.
     * The result array length is determined by the maximum length of the two input arrays.
     * When an array is shorter than the maximum length, the specified default value is used for missing elements.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {2, 3, 4};
     * int[] b = {10, 20, 30, 40, 50};
     * int[] result = Arrays.multipliedBy(a, b, 1, 2);
     * // For indices 3,4: a[3]=1, a[4]=1 (default), b[3]=40, b[4]=50
     * // result = {20, 60, 120, 40, 50}
     * </pre>
     *
     * @param a the first multiplicand array
     * @param b the second multiplicand array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @return a new array containing the element-wise product, with length equal to the maximum of the two input arrays
     */
    public static int[] multipliedBy(final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return multipliedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    // Private helper methods for subtract operations

    // Private helper methods for multipliedBy operations

    private static int[] multipliedBy(final int len, final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] * b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA * b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] * valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA * valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 1D integer arrays (a * b * c).
     * The result array length is determined by the minimum length among the three input arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {2, 3, 4};
     * int[] b = {5, 6, 7};
     * int[] c = {10, 10, 10};
     * int[] result = Arrays.multipliedBy(a, b, c);
     * // result = {100, 180, 280}
     * </pre>
     *
     * @param a the first multiplicand array
     * @param b the second multiplicand array
     * @param c the third multiplicand array
     * @return a new array containing the element-wise product, with length equal to the minimum of the three input arrays
     */
    public static int[] multipliedBy(final int[] a, final int[] b, final int[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] * b[i] * c[i];
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 1D integer arrays with default values for missing elements.
     * The result array length is determined by the maximum length among the three input arrays.
     * When an array is shorter than the maximum length, the specified default value is used for missing elements.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {2, 3};
     * int[] b = {4, 5, 6};
     * int[] c = {7};
     * int[] result = Arrays.multipliedBy(a, b, c, 1, 1, 2);
     * // For index 1: a[1]=3, b[1]=5, c[1]=2 (default)
     * // For index 2: a[2]=1 (default), b[2]=6, c[2]=2 (default)
     * // result = {56, 30, 12}
     * </pre>
     *
     * @param a the first multiplicand array
     * @param b the second multiplicand array
     * @param c the third multiplicand array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @param valueForNoneC the default value to use for missing elements in array c
     * @return a new array containing the element-wise product, with length equal to the maximum of the three input arrays
     */
    public static int[] multipliedBy(final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB, final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return multipliedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    // Private helper methods for subtract operations

    // Private helper methods for multipliedBy operations

    private static int[] multipliedBy(final int len, final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] * b[i] * c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) * (i < lenB ? b[i] : valueForNoneB) * (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 2D integer arrays (a * b).
     * The result array length is determined by the minimum length of the two input arrays.
     * Each sub-array is processed independently using element-wise multiplication.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{2, 3}, {4, 5}, {6, 7}};
     * int[][] b = {{10, 10}, {20, 20}};
     * int[][] result = Arrays.multipliedBy(a, b);
     * // result = {{20, 30}, {80, 100}} (length is 2, the minimum)
     * </pre>
     *
     * @param a the first multiplicand 2D array
     * @param b the second multiplicand 2D array
     * @return a new 2D array containing the element-wise product, with length equal to the minimum of the two input arrays
     */
    public static int[][] multipliedBy(final int[][] a, final int[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 2D integer arrays with default values for missing elements.
     * The result array dimensions are determined by the maximum dimensions of the two input arrays.
     * When an array or sub-array is shorter, the specified default value is used for missing elements.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{2, 3}, {4}};
     * int[][] b = {{10, 20, 30}, {40, 50}, {60, 70}};
     * int[][] result = Arrays.multipliedBy(a, b, 1, 1);
     * // Handles both different outer array lengths and different sub-array lengths
     * </pre>
     *
     * @param a the first multiplicand 2D array
     * @param b the second multiplicand 2D array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @return a new 2D array containing the element-wise product, with dimensions equal to the maximum of the two input arrays
     */
    public static int[][] multipliedBy(final int[][] a, final int[][] b, final int valueForNoneA, final int valueForNoneB) {
        return multipliedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    // Private helper methods for subtract operations

    // Private helper methods for multipliedBy operations

    private static int[][] multipliedBy(final int len, final int rowLen, final int[][] a, final int[][] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = multipliedBy(rowLen, (int[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 2D integer arrays (a * b * c).
     * The result array length is determined by the minimum length among the three input arrays.
     * Each sub-array is processed independently using element-wise multiplication.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{2, 3}, {4, 5}};
     * int[][] b = {{5, 6}, {7, 8}};
     * int[][] c = {{10, 10}, {10, 10}};
     * int[][] result = Arrays.multipliedBy(a, b, c);
     * // result = {{100, 180}, {280, 400}}
     * </pre>
     *
     * @param a the first multiplicand 2D array
     * @param b the second multiplicand 2D array
     * @param c the third multiplicand 2D array
     * @return a new 2D array containing the element-wise product, with length equal to the minimum of the three input arrays
     */
    public static int[][] multipliedBy(final int[][] a, final int[][] b, final int[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 2D integer arrays with default values for missing elements.
     * The result array dimensions are determined by the maximum dimensions among the three input arrays.
     * When an array or sub-array is shorter, the specified default value is used for missing elements.
     *
     * <p>This method handles arrays of different lengths at both the outer array level and sub-array level,
     * ensuring all elements are processed using the provided default values where necessary.
     *
     * @param a the first multiplicand 2D array
     * @param b the second multiplicand 2D array
     * @param c the third multiplicand 2D array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @param valueForNoneC the default value to use for missing elements in array c
     * @return a new 2D array containing the element-wise product, with dimensions equal to the maximum of the three input arrays
     */
    public static int[][] multipliedBy(final int[][] a, final int[][] b, final int[][] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC) {
        return multipliedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Performs element-wise multiplication of two 3D integer arrays (a * b).
     * The result array length is determined by the minimum length of the two input arrays.
     * Each 2D sub-array is processed independently using element-wise multiplication.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{2, 3}, {4, 5}}, {{6, 7}, {8, 9}}};
     * int[][][] b = {{{10, 10}, {10, 10}}, {{20, 20}, {20, 20}}};
     * int[][][] result = Arrays.multipliedBy(a, b);
     * // result[0][0] = {20, 30}, result[0][1] = {40, 50}, etc.
     * </pre>
     *
     * @param a the first multiplicand 3D array
     * @param b the second multiplicand 3D array
     * @return a new 3D array containing the element-wise product, with length equal to the minimum of the two input arrays
     */
    public static int[][][] multipliedBy(final int[][][] a, final int[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of two 3D integer arrays with default values for missing elements.
     * The result array length is determined by the maximum length of the two input arrays.
     * When an array is shorter than the maximum length, the specified default value is used for missing elements.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{2, 3}}, {{4, 5}}};
     * int[][][] b = {{{10, 20}}};  // shorter array
     * int[][][] result = Arrays.multipliedBy(a, b, 1, 2);
     * // For index 1: a[1] exists, b[1] missing (uses default 2)
     * </pre>
     *
     * @param a the first multiplicand 3D array
     * @param b the second multiplicand 3D array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @return a new 3D array containing the element-wise product, with length equal to the maximum of the two input arrays
     */
    public static int[][][] multipliedBy(final int[][][] a, final int[][][] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = multipliedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = multipliedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 3D integer arrays (a * b * c).
     * The result array length is determined by the minimum length among the three input arrays.
     * Each 2D sub-array is processed independently using element-wise multiplication.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{2, 3}}, {{4, 5}}};
     * int[][][] b = {{{5, 6}}, {{7, 8}}};
     * int[][][] c = {{{10, 10}}, {{10, 10}}};
     * int[][][] result = Arrays.multipliedBy(a, b, c);
     * // result[0][0] = {100, 180}, etc.
     * </pre>
     *
     * @param a the first multiplicand 3D array
     * @param b the second multiplicand 3D array
     * @param c the third multiplicand 3D array
     * @return a new 3D array containing the element-wise product, with length equal to the minimum of the three input arrays
     */
    public static int[][][] multipliedBy(final int[][][] a, final int[][][] b, final int[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs element-wise multiplication of three 3D integer arrays with default values for missing elements.
     * The result array length is determined by the maximum length among the three input arrays.
     * When an array is shorter than the maximum length, the specified default value is used for missing elements.
     *
     * <p>This method handles arrays of different lengths at all levels (3D, 2D, and 1D),
     * ensuring all elements are processed using the provided default values where necessary.
     *
     * @param a the first multiplicand 3D array
     * @param b the second multiplicand 3D array
     * @param c the third multiplicand 3D array
     * @param valueForNoneA the default value to use for missing elements in array a
     * @param valueForNoneB the default value to use for missing elements in array b
     * @param valueForNoneC the default value to use for missing elements in array c
     * @return a new 3D array containing the element-wise product, with length equal to the maximum of the three input arrays
     */
    public static int[][][] multipliedBy(final int[][][] a, final int[][][] b, final int[][][] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = multipliedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    // Private helper methods for subtract operations

    // Private helper methods for multipliedBy operations

    private static int[][] multipliedBy(final int len, final int rowLen, final int[][] a, final int[][] b, final int[][] c, final int valueForNoneA,
            final int valueForNoneB, final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = multipliedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of two integer arrays.
     * The result array length equals the minimum length of the input arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {10, 20, 30};
     * int[] b = {2, 4, 5};
     * int[] result = Arrays.dividedBy(a, b); // Returns {5, 5, 6}
     * </pre>
     *
     * @param a the dividend array
     * @param b the divisor array
     * @return a new array containing the element-wise division results
     * @throws ArithmeticException if any element in array b is zero
     */
    public static int[] dividedBy(final int[] a, final int[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / b[i];
        }

        return result;
    }

    /**
     * Performs element-wise division of two integer arrays with default values for missing elements.
     * The result array length equals the maximum length of the input arrays.
     * When an array is shorter, the specified default value is used for missing elements.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {10, 20};
     * int[] b = {2, 4, 5};
     * int[] result = Arrays.dividedBy(a, b, 30, 1); // Returns {5, 5, 30}
     * // For index 2: valueForNoneA (30) / b[2] (5) = 6
     * </pre>
     *
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA the default value to use when array a is shorter
     * @param valueForNoneB the default value to use when array b is shorter
     * @return a new array containing the element-wise division results
     * @throws ArithmeticException if division by zero occurs
     */
    public static int[] dividedBy(final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for element-wise division with specified result length.
     *
     * @param len the desired length of the result array
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA the default value to use when array a is shorter
     * @param valueForNoneB the default value to use when array b is shorter
     * @return a new array containing the element-wise division results
     */
    private static int[] dividedBy(final int len, final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] / b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA / b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] / valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA / valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Performs chained element-wise division of three integer arrays (a/b/c).
     * The result array length equals the minimum length of the three input arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {100, 200, 300};
     * int[] b = {2, 4, 5};
     * int[] c = {5, 5, 6};
     * int[] result = Arrays.dividedBy(a, b, c); // Returns {10, 10, 10}
     * // Each element: a[i] / b[i] / c[i]
     * </pre>
     *
     * @param a the first dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @return a new array containing the chained division results
     * @throws ArithmeticException if any divisor element is zero
     */
    public static int[] dividedBy(final int[] a, final int[] b, final int[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / b[i] / c[i];
        }

        return result;
    }

    /**
     * Performs chained element-wise division of three integer arrays with default values.
     * The result array length equals the maximum length of the three input arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {100, 200};
     * int[] b = {2, 4, 5};
     * int[] c = {5};
     * int[] result = Arrays.dividedBy(a, b, c, 300, 1, 10);
     * // Returns {10, 10, 30}
     * </pre>
     *
     * @param a the first dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA the default value when array a is shorter
     * @param valueForNoneB the default value when array b is shorter
     * @param valueForNoneC the default value when array c is shorter
     * @return a new array containing the chained division results
     * @throws ArithmeticException if division by zero occurs
     */
    public static int[] dividedBy(final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB, final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for chained division with specified result length.
     *
     * @param len the desired length of the result array
     * @param a the first dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA the default value when array a is shorter
     * @param valueForNoneB the default value when array b is shorter
     * @param valueForNoneC the default value when array c is shorter
     * @return a new array containing the chained division results
     */
    private static int[] dividedBy(final int len, final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] / b[i] / c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) / (i < lenB ? b[i] : valueForNoneB) / (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of two 2D integer arrays.
     * Each corresponding row is divided element-wise.
     * The result array has dimensions based on the minimum dimensions of inputs.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{10, 20}, {30, 40}};
     * int[][] b = {{2, 4}, {5, 8}};
     * int[][] result = Arrays.dividedBy(a, b);
     * // Returns {{5, 5}, {6, 5}}
     * </pre>
     *
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @return a new 2D array containing the element-wise division results
     * @throws ArithmeticException if any divisor element is zero
     */
    public static int[][] dividedBy(final int[][] a, final int[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 2D integer arrays with default values.
     * The result array dimensions are based on the maximum dimensions of inputs.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{10, 20}};
     * int[][] b = {{2, 4}, {5, 8}};
     * int[][] result = Arrays.dividedBy(a, b, 30, 1);
     * // Returns {{5, 5}, {6, 30}}
     * </pre>
     *
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @return a new 2D array containing the element-wise division results
     * @throws ArithmeticException if division by zero occurs
     */
    public static int[][] dividedBy(final int[][] a, final int[][] b, final int valueForNoneA, final int valueForNoneB) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Internal helper method for 2D array division with specified dimensions.
     *
     * @param len the desired number of rows in the result
     * @param rowLen the desired length of each row
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @return a new 2D array containing the element-wise division results
     */
    private static int[][] dividedBy(final int len, final int rowLen, final int[][] a, final int[][] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, (int[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs chained element-wise division of three 2D integer arrays.
     * Each corresponding element is divided in sequence (a[i][j]/b[i][j]/c[i][j]).
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{100, 200}};
     * int[][] b = {{2, 4}};
     * int[][] c = {{5, 5}};
     * int[][] result = Arrays.dividedBy(a, b, c);
     * // Returns {{10, 10}}
     * </pre>
     *
     * @param a the first dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @return a new 2D array containing the chained division results
     * @throws ArithmeticException if any divisor element is zero
     */
    public static int[][] dividedBy(final int[][] a, final int[][] b, final int[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs chained element-wise division of three 2D integer arrays with default values.
     * The result dimensions are based on the maximum dimensions of all inputs.
     *
     * @param a the first dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @param valueForNoneC the default value when array c elements are missing
     * @return a new 2D array containing the chained division results
     * @throws ArithmeticException if division by zero occurs
     */
    public static int[][] dividedBy(final int[][] a, final int[][] b, final int[][] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Internal helper method for 2D array chained division with specified dimensions.
     *
     * @param len the desired number of rows in the result
     * @param rowLen the desired length of each row
     * @param a the first dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @param valueForNoneC the default value when array c elements are missing
     * @return a new 2D array containing the chained division results
     */
    private static int[][] dividedBy(final int len, final int rowLen, final int[][] a, final int[][] b, final int[][] c, final int valueForNoneA,
            final int valueForNoneB, final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division of two 3D integer arrays.
     * Each corresponding element is divided across all three dimensions.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{10, 20}}, {{30, 40}}};
     * int[][][] b = {{{2, 4}}, {{5, 8}}};
     * int[][][] result = Arrays.dividedBy(a, b);
     * // Returns {{{5, 5}}, {{6, 5}}}
     * </pre>
     *
     * @param a the dividend 3D array
     * @param b the divisor 3D array
     * @return a new 3D array containing the element-wise division results
     * @throws ArithmeticException if any divisor element is zero
     */
    public static int[][][] dividedBy(final int[][][] a, final int[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division of two 3D integer arrays with default values.
     * The result dimensions are based on the maximum dimensions of inputs.
     *
     * @param a the dividend 3D array
     * @param b the divisor 3D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @return a new 3D array containing the element-wise division results
     * @throws ArithmeticException if division by zero occurs
     */
    public static int[][][] dividedBy(final int[][][] a, final int[][][] b, final int valueForNoneA, final int valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Performs chained element-wise division of three 3D integer arrays.
     * Each element is divided in sequence (a[i][j][k]/b[i][j][k]/c[i][j][k]).
     *
     * @param a the first dividend 3D array
     * @param b the first divisor 3D array
     * @param c the second divisor 3D array
     * @return a new 3D array containing the chained division results
     * @throws ArithmeticException if any divisor element is zero
     */
    public static int[][][] dividedBy(final int[][][] a, final int[][][] b, final int[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Performs chained element-wise division of three 3D integer arrays with default values.
     * The result dimensions are based on the maximum dimensions of all inputs.
     *
     * @param a the first dividend 3D array
     * @param b the first divisor 3D array
     * @param c the second divisor 3D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @param valueForNoneC the default value when array c elements are missing
     * @return a new 3D array containing the chained division results
     * @throws ArithmeticException if division by zero occurs
     */
    public static int[][][] dividedBy(final int[][][] a, final int[][][] b, final int[][][] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Performs element-wise division with zero-handling for two integer arrays.
     * When a divisor element is zero, it's replaced with the defaultValueForZero.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {10, 20, 30};
     * int[] b = {2, 0, 5};
     * int[] result = Arrays.dividedBy(a, b, 1);
     * // Returns {5, 20, 6} (20/0 becomes 20/1)
     * </pre>
     *
     * @param a the dividend array
     * @param b the divisor array
     * @param defaultValueForZero the value to use when divisor element is zero
     * @return a new array containing the division results with zero-handling
     */
    public static int[] dividedBy(final int[] a, final int[] b, final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]);
        }

        return result;
    }

    /**
     * Performs element-wise division with zero-handling and default values for missing elements.
     * Combines zero-handling with support for arrays of different lengths.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {10, 20};
     * int[] b = {2, 0, 5};
     * int[] result = Arrays.dividedBy(a, b, 30, 1, 1);
     * // Returns {5, 20, 30} (index 2: 30/5=6, index 1: 20/0 becomes 20/1)
     * </pre>
     *
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA the default value when array a is shorter
     * @param valueForNoneB the default value when array b is shorter
     * @param defaultValueForZero the value to use when divisor element is zero
     * @return a new array containing the division results
     */
    public static int[] dividedBy(final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB, final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     * Internal helper method for division with zero-handling and specified length.
     *
     * @param len the desired length of the result array
     * @param a the dividend array
     * @param b the divisor array
     * @param valueForNoneA the default value when array a is shorter
     * @param valueForNoneB the default value when array b is shorter
     * @param defaultValueForZero the value to use when divisor element is zero
     * @return a new array containing the division results
     */
    private static int[] dividedBy(final int len, final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB,
            final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA / (b[i] == 0 ? defaultValueForZero : b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] / valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA / valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Performs chained element-wise division with zero-handling for three arrays.
     * When any divisor element is zero, it's replaced with defaultValueForZero.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {100, 200, 300};
     * int[] b = {2, 0, 5};
     * int[] c = {5, 10, 0};
     * int[] result = Arrays.dividedBy(a, b, c, 1);
     * // Returns {10, 20, 60} (zeros replaced with 1)
     * </pre>
     *
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param defaultValueForZero the value to use when any divisor element is zero
     * @return a new array containing the chained division results with zero-handling
     */
    public static int[] dividedBy(final int[] a, final int[] b, final int[] c, final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]);
        }

        return result;
    }

    /**
     * Performs chained element-wise division with zero-handling and default values.
     * Combines zero-handling with support for arrays of different lengths.
     *
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA the default value when array a is shorter
     * @param valueForNoneB the default value when array b is shorter
     * @param valueForNoneC the default value when array c is shorter
     * @param defaultValueForZero the value to use when any divisor element is zero
     * @return a new array containing the chained division results
     */
    public static int[] dividedBy(final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB, final int valueForNoneC,
            final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     * Internal helper method for chained division with zero-handling.
     *
     * @param len the desired length of the result array
     * @param a the dividend array
     * @param b the first divisor array
     * @param c the second divisor array
     * @param valueForNoneA the default value when array a is shorter
     * @param valueForNoneB the default value when array b is shorter
     * @param valueForNoneC the default value when array c is shorter
     * @param defaultValueForZero the value to use when any divisor element is zero
     * @return a new array containing the chained division results
     */
    private static int[] dividedBy(final int len, final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC, final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) / (i < lenB ? (b[i] == 0 ? defaultValueForZero : b[i]) : valueForNoneB)
                        / (i < lenC ? (c[i] == 0 ? defaultValueForZero : c[i]) : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division with zero-handling for two 2D arrays.
     * When any divisor element is zero, it's replaced with defaultValueForZero.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{10, 20}, {30, 40}};
     * int[][] b = {{2, 0}, {5, 8}};
     * int[][] result = Arrays.dividedBy(a, b, 1);
     * // Returns {{5, 20}, {6, 5}}
     * </pre>
     *
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @param defaultValueForZero the value to use when divisor element is zero
     * @return a new 2D array containing the division results with zero-handling
     */
    public static int[][] dividedBy(final int[][] a, final int[][] b, final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs element-wise division with zero-handling and default values for 2D arrays.
     * Combines zero-handling with support for arrays of different dimensions.
     *
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @param defaultValueForZero the value to use when divisor element is zero
     * @return a new 2D array containing the division results
     */
    public static int[][] dividedBy(final int[][] a, final int[][] b, final int valueForNoneA, final int valueForNoneB, final int defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     * Internal helper method for 2D array division with zero-handling.
     *
     * @param len the desired number of rows in the result
     * @param rowLen the desired length of each row
     * @param a the dividend 2D array
     * @param b the divisor 2D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @param defaultValueForZero the value to use when divisor element is zero
     * @return a new 2D array containing the division results
     */
    private static int[][] dividedBy(final int len, final int rowLen, final int[][] a, final int[][] b, final int valueForNoneA, final int valueForNoneB,
            final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, (int[]) null, null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Performs chained element-wise division with zero-handling for three 2D arrays.
     * When any divisor element is zero, it's replaced with defaultValueForZero.
     *
     * @param a the dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @param defaultValueForZero the value to use when any divisor element is zero
     * @return a new 2D array containing the chained division results with zero-handling
     */
    public static int[][] dividedBy(final int[][] a, final int[][] b, final int[][] c, final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs chained element-wise division with zero-handling and default values for 2D arrays.
     * Combines zero-handling with support for arrays of different dimensions.
     *
     * @param a the dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @param valueForNoneC the default value when array c elements are missing
     * @param defaultValueForZero the value to use when any divisor element is zero
     * @return a new 2D array containing the chained division results
     */
    public static int[][] dividedBy(final int[][] a, final int[][] b, final int[][] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC, final int defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     * Internal helper method for 2D array chained division with zero-handling.
     *
     * @param len the desired number of rows in the result
     * @param rowLen the desired length of each row
     * @param a the dividend 2D array
     * @param b the first divisor 2D array
     * @param c the second divisor 2D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @param valueForNoneC the default value when array c elements are missing
     * @param defaultValueForZero the value to use when any divisor element is zero
     * @return a new 2D array containing the chained division results
     */
    private static int[][] dividedBy(final int len, final int rowLen, final int[][] a, final int[][] b, final int[][] c, final int valueForNoneA,
            final int valueForNoneB, final int valueForNoneC, final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Performs element-wise division with zero-handling for two 3D arrays.
     * When any divisor element is zero, it's replaced with defaultValueForZero.
     *
     * @param a the dividend 3D array
     * @param b the divisor 3D array
     * @param defaultValueForZero the value to use when divisor element is zero
     * @return a new 3D array containing the division results with zero-handling
     */
    public static int[][][] dividedBy(final int[][][] a, final int[][][] b, final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs element-wise division with zero-handling and default values for 3D arrays.
     * Combines zero-handling with support for arrays of different dimensions.
     *
     * @param a the dividend 3D array
     * @param b the divisor 3D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @param defaultValueForZero the value to use when divisor element is zero
     * @return a new 3D array containing the division results
     */
    public static int[][][] dividedBy(final int[][][] a, final int[][][] b, final int valueForNoneA, final int valueForNoneB, final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Performs chained element-wise division with zero-handling for three 3D arrays.
     * When any divisor element is zero, it's replaced with defaultValueForZero.
     *
     * @param a the dividend 3D array
     * @param b the first divisor 3D array
     * @param c the second divisor 3D array
     * @param defaultValueForZero the value to use when any divisor element is zero
     * @return a new 3D array containing the chained division results with zero-handling
     */
    public static int[][][] dividedBy(final int[][][] a, final int[][][] b, final int[][][] c, final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Performs chained element-wise division with zero-handling and default values for 3D arrays.
     * Combines zero-handling with support for arrays of different dimensions.
     *
     * @param a the dividend 3D array
     * @param b the first divisor 3D array
     * @param c the second divisor 3D array
     * @param valueForNoneA the default value when array a elements are missing
     * @param valueForNoneB the default value when array b elements are missing
     * @param valueForNoneC the default value when array c elements are missing
     * @param defaultValueForZero the value to use when any divisor element is zero
     * @return a new 3D array containing the chained division results
     */
    public static int[][][] dividedBy(final int[][][] a, final int[][][] b, final int[][][] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC, final int defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                    defaultValueForZero);
        }

        return result;
    }

    /**
     * Applies a binary function to corresponding elements of two integer arrays, creating a new array from the results.
     * The length of the resulting array is the minimum of the lengths of the input arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {10, 20, 30};
     * int[] b = {3, 4, 5};
     * int[] result = zip(a, b, (x, y) -> x * y);
     * // result will be {30, 80, 150}
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first integer array.
     * @param b The second integer array.
     * @param zipFunction The binary function to apply to each pair of corresponding elements.
     * @return A new integer array containing the results of the zip operation.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[] zip(final int[] a, final int[] b, final Throwables.IntBiFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        return result;
    }

    /**
     * Applies a binary function to corresponding elements of two integer arrays, with specified default values for missing elements.
     * The length of the resulting array is the maximum of the lengths of the input arrays. If one array is shorter, it's virtually padded with its corresponding default value.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {1, 2};
     * int[] b = {10, 20, 30};
     * int[] result = zip(a, b, 0, 5, (x, y) -> x + y);
     * // result will be {11, 22, 35} (1+10, 2+20, 0+30)
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first integer array.
     * @param b The second integer array.
     * @param valueForNoneA The default value to use when an element is missing from array 'a'.
     * @param valueForNoneB The default value to use when an element is missing from array 'b'.
     * @param zipFunction The binary function to apply to each pair of elements.
     * @return A new integer array containing the results of the zip operation.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[] zip(final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB,
            final Throwables.IntBiFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return zip(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     *
     * @param <E>
     * @param len
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param zipFunction
     * @return
     * @throws E the e
     */
    private static <E extends Exception> int[] zip(final int len, final int[] a, final int[] b, final int valueForNoneA, final int valueForNoneB,
            final Throwables.IntBiFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zipFunction.apply(valueForNoneA, b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zipFunction.apply(a[i], valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zipFunction.apply(valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Applies a ternary function to corresponding elements of three integer arrays.
     * The length of the result is the minimum of the lengths of the input arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {1, 2, 3};
     * int[] b = {4, 5, 6};
     * int[] c = {7, 8, 9};
     * int[] result = zip(a, b, c, (x, y, z) -> x + y + z);
     * // result will be {12, 15, 18}
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first integer array.
     * @param b The second integer array.
     * @param c The third integer array.
     * @param zipFunction The ternary function to apply to each triplet of corresponding elements.
     * @return A new integer array containing the results of the zip operation.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[] zip(final int[] a, final int[] b, final int[] c, final Throwables.IntTriFunction<Integer, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Applies a ternary function to corresponding elements of three integer arrays, with specified default values.
     * The length of the result is the maximum of the lengths of the input arrays. Shorter arrays are virtually padded with their respective default values.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {1, 2};
     * int[] b = {10};
     * int[] c = {100, 200, 300};
     * int[] result = zip(a, b, c, 0, 1, 2, (x, y, z) -> x + y + z);
     * // result will be {111, 203, 303}
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first integer array.
     * @param b The second integer array.
     * @param c The third integer array.
     * @param valueForNoneA The default value for array 'a'.
     * @param valueForNoneB The default value for array 'b'.
     * @param valueForNoneC The default value for array 'c'.
     * @param zipFunction The ternary function to apply.
     * @return A new integer array with the results.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[] zip(final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC, final Throwables.IntTriFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return zip(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
    }

    /**
     *
     * @param <E>
     * @param len
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param zipFunction
     * @return
     * @throws E the e
     */
    private static <E extends Exception> int[] zip(final int len, final int[] a, final int[] b, final int[] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC, final Throwables.IntTriFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[] result = new int[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Applies a binary zip operation recursively to two 2D integer arrays.
     * The resulting 2D array's length is the minimum of the input arrays' lengths. Each sub-array is the result of zipping corresponding sub-arrays from the inputs.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{1, 2}, {3, 4}};
     * int[][] b = {{5, 6}, {7, 8}};
     * int[][] result = zip(a, b, (x, y) -> x - y);
     * // result will be {{-4, -4}, {-4, -4}}
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first 2D integer array.
     * @param b The second 2D integer array.
     * @param zipFunction The binary function to apply to elements.
     * @return A new 2D integer array with the zipped results.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[][] zip(final int[][] a, final int[][] b, final Throwables.IntBiFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a binary zip operation to two 2D integer arrays with default values for padding.
     * The dimensions of the resulting array are the maximum of the dimensions of the input arrays. Missing elements and sub-arrays are handled using the provided default values.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{1}};
     * int[][] b = {{10, 20}, {30, 40}};
     * int[][] result = zip(a, b, 0, 0, (x, y) -> x + y);
     * // result will be {{11, 20}, {30, 40}}
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first 2D integer array.
     * @param b The second 2D integer array.
     * @param valueForNoneA The default value to use for missing elements from array 'a'.
     * @param valueForNoneB The default value to use for missing elements from array 'b'.
     * @param zipFunction The binary function to apply to elements.
     * @return A new 2D integer array with the zipped and padded results.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[][] zip(final int[][] a, final int[][] b, final int valueForNoneA, final int valueForNoneB,
            final Throwables.IntBiFunction<Integer, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     *
     * @param <E>
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param zipFunction
     * @return
     * @throws E the e
     */
    private static <E extends Exception> int[][] zip(final int len, final int rowLen, final int[][] a, final int[][] b, final int valueForNoneA,
            final int valueForNoneB, final Throwables.IntBiFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zip(rowLen, null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zip(rowLen, a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zip(rowLen, null, null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Applies a ternary zip operation recursively to three 2D integer arrays.
     * The resulting 2D array's length is the minimum of the input arrays' lengths. Each sub-array is the result of zipping corresponding sub-arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{1, 2}};
     * int[][] b = {{3, 4}};
     * int[][] c = {{5, 6}};
     * int[][] result = zip(a, b, c, (x, y, z) -> x * y * z);
     * // result will be {{15, 48}}
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first 2D integer array.
     * @param b The second 2D integer array.
     * @param c The third 2D integer array.
     * @param zipFunction The ternary function to apply.
     * @return A new 2D integer array with the zipped results.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[][] zip(final int[][] a, final int[][] b, final int[][] c, final Throwables.IntTriFunction<Integer, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a ternary zip operation to three 2D integer arrays with default values for padding.
     * The dimensions of the resulting array are the maximum of the input arrays' dimensions. Missing elements and sub-arrays are handled using default values.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{1}};
     * int[][] b = {{2, 3}};
     * int[][] c = {{4, 5}, {6, 7}};
     * int[][] result = zip(a, b, c, 0, 0, 0, (x, y, z) -> x + y + z);
     * // result will be {{7, 8}, {6, 7}}
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first 2D integer array.
     * @param b The second 2D integer array.
     * @param c The third 2D integer array.
     * @param valueForNoneA Default value for 'a'.
     * @param valueForNoneB Default value for 'b'.
     * @param valueForNoneC Default value for 'c'.
     * @param zipFunction The ternary function to apply.
     * @return A new 2D integer array with the zipped and padded results.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[][] zip(final int[][] a, final int[][] b, final int[][] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC, final Throwables.IntTriFunction<Integer, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC, zipFunction);
    }

    /**
     *
     * @param <E>
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param zipFunction
     * @return
     * @throws E the e
     */
    private static <E extends Exception> int[][] zip(final int len, final int rowLen, final int[][] a, final int[][] b, final int[][] c,
            final int valueForNoneA, final int valueForNoneB, final int valueForNoneC, final Throwables.IntTriFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][] result = new int[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zip(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                        zipFunction);
            }
        }

        return result;
    }

    /**
     * Applies a binary zip operation recursively to two 3D integer arrays.
     * The resulting 3D array's length is the minimum of the input arrays' lengths. Each 2D sub-array is the result of zipping corresponding 2D sub-arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{1}}};
     * int[][][] b = {{{2}}};
     * int[][][] result = zip(a, b, (x, y) -> x + y);
     * // result will be {{{3}}}
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first 3D integer array.
     * @param b The second 3D integer array.
     * @param zipFunction The binary function to apply.
     * @return A new 3D integer array with the zipped results.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[][][] zip(final int[][][] a, final int[][][] b, final Throwables.IntBiFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a binary zip operation to two 3D integer arrays with default values for padding.
     * The resulting 3D array's length is the maximum of the input arrays' lengths. Missing elements and sub-arrays are handled using the provided default values.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{1}}};
     * int[][][] b = {{{2, 3}}, {{4}}};
     * int[][][] result = zip(a, b, 0, 0, (x, y) -> x + y);
     * // result will be {{{3, 3}}, {{4}}}
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first 3D integer array.
     * @param b The second 3D integer array.
     * @param valueForNoneA Default value for 'a'.
     * @param valueForNoneB Default value for 'b'.
     * @param zipFunction The binary function to apply.
     * @return A new 3D integer array with the zipped and padded results.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[][][] zip(final int[][][] a, final int[][][] b, final int valueForNoneA, final int valueForNoneB,
            final Throwables.IntBiFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final int[][][] result = new int[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = zip(a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = zip(null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = zip(a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Applies a ternary zip operation recursively to three 3D integer arrays.
     * The resulting 3D array's length is the minimum of the input arrays' lengths. Each 2D sub-array is the result of zipping corresponding 2D sub-arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{1}}};
     * int[][][] b = {{{2}}};
     * int[][][] c = {{{3}}};
     * int[][][] result = zip(a, b, c, (x, y, z) -> x + y + z);
     * // result will be {{{6}}}
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first 3D integer array.
     * @param b The second 3D integer array.
     * @param c The third 3D integer array.
     * @param zipFunction The ternary function to apply.
     * @return A new 3D integer array with the zipped results.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[][][] zip(final int[][][] a, final int[][][] b, final int[][][] c,
            final Throwables.IntTriFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Applies a ternary zip operation to three 3D integer arrays with default values for padding.
     * The resulting 3D array's length is the maximum of the input arrays' lengths. Missing elements are handled using default values.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{1}}};
     * int[][][] b = {{{2}}};
     * int[][][] c = {{{3}},{{4}}};
     * int[][][] result = zip(a, b, c, 0, 0, 0, (x, y, z) -> x + y + z);
     * // result will be {{{6}}, {{4}}}
     * </pre>
     *
     * @param <E> the type of exception that the zip function may throw.
     * @param a The first 3D integer array.
     * @param b The second 3D integer array.
     * @param c The third 3D integer array.
     * @param valueForNoneA Default value for 'a'.
     * @param valueForNoneB Default value for 'b'.
     * @param valueForNoneC Default value for 'c'.
     * @param zipFunction The ternary function to apply.
     * @return A new 3D integer array with the zipped and padded results.
     * @throws E If the zip function throws an exception.
     */
    public static <E extends Exception> int[][][] zip(final int[][][] a, final int[][][] b, final int[][][] c, final int valueForNoneA, final int valueForNoneB,
            final int valueForNoneC, final Throwables.IntTriFunction<Integer, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final int[][][] result = new int[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = zip(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = zip(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        return result;
    }

    /**
     * Calculates the total number of integer elements in a 2D array.
     * It handles null or empty sub-arrays gracefully.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{1, 2}, {3, 4, 5}, null, {}};
     * long count = totalCountOfElements(a);
     * // count will be 5
     * </pre>
     *
     * @param a The 2D integer array.
     * @return The total count of integer elements.
     */
    public static long totalCountOfElements(final int[][] a) {
        long count = 0;

        for (final int[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        return count;
    }

    /**
     * Calculates the total number of integer elements in a 3D array.
     * It safely handles null or empty sub-arrays at any depth.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{1}, {2, 3}}, null, {{{4, 5, 6}}}};
     * long count = totalCountOfElements(a);
     * // count will be 6
     * </pre>
     *
     * @param a The 3D integer array.
     * @return The total count of integer elements.
     */
    public static long totalCountOfElements(final int[][][] a) {
        long count = 0;

        for (final int[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final int[] ints : element) {
                if (N.isEmpty(ints)) {
                    continue;
                }

                count += ints.length;
            }
        }

        return count;
    }

    /**
     * Finds the minimum length among all sub-arrays in a 2D integer array.
     * A null sub-array is considered to have a length of 0.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{1, 2, 3}, {4, 5}, null, {6}};
     * int minLen = minSubArrayLen(a);
     * // minLen will be 0
     * </pre>
     *
     * @param a The 2D integer array.
     * @return The minimum length of a sub-array, or 0 if the input array is null or empty.
     */
    public static int minSubArrayLen(final int[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int minLen = Integer.MAX_VALUE;

        for (final int[] ae : a) {
            minLen = N.min(minLen, ae == null ? 0 : ae.length);
        }

        return minLen;
    }

    /**
     * Finds the maximum length among all sub-arrays in a 2D integer array.
     * A null sub-array is considered to have a length of 0.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{1}, {2, 3}, null, {4, 5, 6}};
     * int maxLen = maxSubArrayLen(a);
     * // maxLen will be 3
     * </pre>
     *
     * @param a The 2D integer array.
     * @return The maximum length of a sub-array, or 0 if the input array is null or empty.
     */
    public static int maxSubArrayLen(final int[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int maxLen = 0;

        for (final int[] ae : a) {
            maxLen = N.max(maxLen, ae == null ? 0 : ae.length);
        }

        return maxLen;
    }

    /**
     * Prints a string representation of an integer array to the console and returns the string.
     * Handles null and empty arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[] a = {1, 2, 3};
     * String s = println(a);
     * // Prints "[1, 2, 3]" to console and s is "[1, 2, 3]"
     * </pre>
     *
     * @param a The integer array to print.
     * @return The string representation of the array.
     */
    public static String println(final int[] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            return N.println(N.toString(a));
        }
    }

    /**
     * Prints a string representation of a 2D integer array to the console and returns the string.
     * Handles null and empty arrays/sub-arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[][] a = {{1, 2}, {3, 4}};
     * String s = println(a);
     * // Prints "[[1, 2], [3, 4]]" to console and s is "[[1, 2], [3, 4]]"
     * </pre>
     *
     * @param a The 2D integer array to print.
     * @return The string representation of the 2D array.
     */
    public static String println(final int[][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final int[] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(", ");
                            }

                            sb.append(ai[j]);
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Prints a string representation of a 3D integer array to the console and returns the string.
     * Handles null and empty arrays/sub-arrays.
     *
     * <p>Example usage:
     * <pre>
     * int[][][] a = {{{1, 2}}, {{3, 4}}};
     * String s = println(a);
     * // Prints a formatted string representation to console and returns it.
     * </pre>
     *
     * @param a The 3D integer array to print.
     * @return The string representation of the 3D array.
     */
    public static String println(final int[][][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final int[][] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(',').append(IOUtil.LINE_SEPARATOR).append("  ");
                            }

                            if (ai[j] == null) {
                                sb.append("null");
                            } else if (ai[j].length == 0) {
                                sb.append("[]");
                            } else {
                                final int[] aij = ai[j];
                                sb.append('[');

                                for (int k = 0, aijLen = aij.length; k < aijLen; k++) {
                                    if (k > 0) {
                                        sb.append(", ");
                                    }

                                    sb.append(aij[k]);
                                }

                                sb.append(']');
                            }
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            N.println(str);

            return str;
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void plus(final long[] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] += param;
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void plus(final long[][] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[] element : a) {
            plus(element, param);
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void plus(final long[][][] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[][] element : a) {
            plus(element, param);
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void minus(final long[] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] -= param;
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void minus(final long[][] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[] element : a) {
            minus(element, param);
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void minus(final long[][][] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[][] element : a) {
            minus(element, param);
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void multipliedBy(final long[] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] *= param;
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void multipliedBy(final long[][] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void multipliedBy(final long[][][] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[][] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void dividedBy(final long[] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] /= param;
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void dividedBy(final long[][] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     *
     * @param a
     * @param param
     */
    public static void dividedBy(final long[][][] a, final long param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[][] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     *
     * @param <E>
     * @param a
     * @param operator
     * @throws E the e
     */
    public static <E extends Exception> void updateAll(final long[] a, final Throwables.LongUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsLong(a[i]);
        }
    }

    /**
     *
     * @param <E>
     * @param a
     * @param operator
     * @throws E the e
     */
    public static <E extends Exception> void updateAll(final long[][] a, final Throwables.LongUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     *
     * @param <E>
     * @param a
     * @param operator
     * @throws E the e
     */
    public static <E extends Exception> void updateAll(final long[][][] a, final Throwables.LongUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[][] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     *
     * @param <E>
     * @param a
     * @param predicate
     * @param newValue
     * @throws E the e
     */
    public static <E extends Exception> void replaceIf(final long[] a, final Throwables.LongPredicate<E> predicate, final long newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
            }
        }
    }

    /**
     *
     * @param <E>
     * @param a
     * @param predicate
     * @param newValue
     * @throws E the e
     */
    public static <E extends Exception> void replaceIf(final long[][] a, final Throwables.LongPredicate<E> predicate, final long newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     *
     * @param <E>
     * @param a
     * @param predicate
     * @param newValue
     * @throws E the e
     */
    public static <E extends Exception> void replaceIf(final long[][][] a, final Throwables.LongPredicate<E> predicate, final long newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final long[][] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     *
     *
     * @param a
     * @param cols
     * @return
     * @throws IllegalArgumentException
     */
    public static long[][] reshape(final long[] a, final int cols) throws IllegalArgumentException {
        checkMForReshape(cols);

        if (N.isEmpty(a)) {
            return new long[0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, cols, RoundingMode.CEILING);
        final long[][] c = new long[n][];

        for (int i = 0, from = 0; i < n; i++, from += cols) {
            c[i] = N.copyOfRange(a, from, from + N.min(len - from, cols));
        }

        return c;
    }

    /**
     *
     *
     * @param a
     * @param rows
     * @param cols
     * @return
     * @throws IllegalArgumentException
     */
    public static long[][][] reshape(final long[] a, final int rows, final int cols) throws IllegalArgumentException {
        checkMAndLForReshape(rows, cols);

        if (N.isEmpty(a)) {
            return new long[0][0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, rows * cols, RoundingMode.CEILING);
        final long[][][] c = new long[n][][];

        for (int i = 0, from = 0; i < n; i++) {
            c[i] = new long[N.min(rows, Numbers.divide(len - from, cols, RoundingMode.CEILING))][];

            for (int j = 0, y = c[i].length; j < y; j++, from += cols) {
                c[i][j] = N.copyOfRange(a, from, from + N.min(len - from, cols));
            }
        }

        return c;
    }

    /**
     *
     * @param a
     * @return
     */
    public static long[] flatten(final long[][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_LONG_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final long[] c = new long[count];
        int from = 0;

        for (final long[] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            N.copy(element, 0, c, from, element.length);

            from += element.length;
        }

        return c;
    }

    /**
     *
     * @param a
     * @return
     */
    public static long[] flatten(final long[][][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_LONG_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final long[] c = new long[count];
        int from = 0;

        for (final long[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final long[] longs : element) {
                if (N.isEmpty(longs)) {
                    continue;
                }

                N.copy(longs, 0, c, from, longs.length);

                from += longs.length;
            }
        }

        return c;
    }

    /**
     * flatten -> execute {@code op} -> set values back.
     * <pre>
     * <code>
     * f.flatOp(a, t -> N.sort(t));
     * </code>
     * </pre>
     *
     * @param <E>
     * @param a
     * @param op
     * @throws E the e
     */
    public static <E extends Exception> void flatOp(final long[][] a, final Throwables.Consumer<? super long[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final long[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final long[] e : a) {
            if (N.notEmpty(e)) {
                N.copy(tmp, idx, e, 0, e.length);
                idx += e.length;
            }
        }
    }

    /**
     * flatten -> execute {@code op} -> set values back.
     * <pre>
     * <code>
     * f.flatOp(a, t -> N.sort(t));
     * </code>
     * </pre>
     *
     * @param <E>
     * @param a
     * @param op
     * @throws E the e
     */
    public static <E extends Exception> void flatOp(final long[][][] a, final Throwables.Consumer<? super long[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final long[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final long[][] e : a) {
            if (N.notEmpty(e)) {
                for (final long[] ee : e) {
                    if (N.notEmpty(ee)) {
                        N.copy(tmp, idx, ee, 0, ee.length);
                        idx += ee.length;
                    }
                }
            }
        }
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[] add(final long[] a, final long[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] + b[i];
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[] add(final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return add(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     *
     * @param len
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    private static long[] add(final int len, final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] + b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA + b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] + valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA + valueForNoneB;
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[] add(final long[] a, final long[] b, final long[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] + b[i] + c[i];
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[] add(final long[] a, final long[] b, final long[] c, final long valueForNoneA, final long valueForNoneB, final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return add(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     *
     * @param len
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    private static long[] add(final int len, final long[] a, final long[] b, final long[] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] + b[i] + c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) + (i < lenB ? b[i] : valueForNoneB) + (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[][] add(final long[][] a, final long[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[][] add(final long[][] a, final long[][] b, final long valueForNoneA, final long valueForNoneB) {
        return add(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     *
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    private static long[][] add(final int len, final int rowLen, final long[][] a, final long[][] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = add(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = add(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = add(rowLen, (long[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[][] add(final long[][] a, final long[][] b, final long[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[][] add(final long[][] a, final long[][] b, final long[][] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        return add(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC);
    }

    /**
     *
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    private static long[][] add(final int len, final int rowLen, final long[][] a, final long[][] b, final long[][] c, final long valueForNoneA,
            final long valueForNoneB, final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = add(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[][][] add(final long[][][] a, final long[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[][][] add(final long[][][] a, final long[][][] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = add(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = add(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = add(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[][][] add(final long[][][] a, final long[][][] b, final long[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[][][] add(final long[][][] a, final long[][][] b, final long[][][] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = add(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = add(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[] subtract(final long[] a, final long[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] - b[i];
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[] subtract(final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return subtract(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     *
     * @param len
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    private static long[] subtract(final int len, final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] - b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA - b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] - valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA - valueForNoneB;
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[] subtract(final long[] a, final long[] b, final long[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] - b[i] - c[i];
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[] subtract(final long[] a, final long[] b, final long[] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return subtract(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     *
     * @param len
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    private static long[] subtract(final int len, final long[] a, final long[] b, final long[] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] - b[i] - c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) - (i < lenB ? b[i] : valueForNoneB) - (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[][] subtract(final long[][] a, final long[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[][] subtract(final long[][] a, final long[][] b, final long valueForNoneA, final long valueForNoneB) {
        return subtract(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     *
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    private static long[][] subtract(final int len, final int rowLen, final long[][] a, final long[][] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = subtract(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = subtract(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = subtract(rowLen, (long[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[][] subtract(final long[][] a, final long[][] b, final long[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[][] subtract(final long[][] a, final long[][] b, final long[][] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        return subtract(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     *
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    private static long[][] subtract(final int len, final int rowLen, final long[][] a, final long[][] b, final long[][] c, final long valueForNoneA,
            final long valueForNoneB, final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = subtract(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[][][] subtract(final long[][][] a, final long[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[][][] subtract(final long[][][] a, final long[][][] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = subtract(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = subtract(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = subtract(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[][][] subtract(final long[][][] a, final long[][][] b, final long[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[][][] subtract(final long[][][] a, final long[][][] b, final long[][][] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = subtract(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = subtract(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[] multipliedBy(final long[] a, final long[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] * b[i];
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[] multipliedBy(final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return multipliedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     *
     * @param len
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    private static long[] multipliedBy(final int len, final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] * b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA * b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] * valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA * valueForNoneB;
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[] multipliedBy(final long[] a, final long[] b, final long[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] * b[i] * c[i];
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[] multipliedBy(final long[] a, final long[] b, final long[] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return multipliedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     *
     * @param len
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    private static long[] multipliedBy(final int len, final long[] a, final long[] b, final long[] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] * b[i] * c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) * (i < lenB ? b[i] : valueForNoneB) * (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[][] multipliedBy(final long[][] a, final long[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[][] multipliedBy(final long[][] a, final long[][] b, final long valueForNoneA, final long valueForNoneB) {
        return multipliedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     *
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    private static long[][] multipliedBy(final int len, final int rowLen, final long[][] a, final long[][] b, final long valueForNoneA,
            final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = multipliedBy(rowLen, (long[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[][] multipliedBy(final long[][] a, final long[][] b, final long[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[][] multipliedBy(final long[][] a, final long[][] b, final long[][] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        return multipliedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     *
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    private static long[][] multipliedBy(final int len, final int rowLen, final long[][] a, final long[][] b, final long[][] c, final long valueForNoneA,
            final long valueForNoneB, final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = multipliedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[][][] multipliedBy(final long[][][] a, final long[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[][][] multipliedBy(final long[][][] a, final long[][][] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = multipliedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = multipliedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[][][] multipliedBy(final long[][][] a, final long[][][] b, final long[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[][][] multipliedBy(final long[][][] a, final long[][][] b, final long[][][] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = multipliedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[] dividedBy(final long[] a, final long[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / b[i];
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[] dividedBy(final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     *
     * @param len
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    private static long[] dividedBy(final int len, final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] / b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA / b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] / valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA / valueForNoneB;
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[] dividedBy(final long[] a, final long[] b, final long[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / b[i] / c[i];
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[] dividedBy(final long[] a, final long[] b, final long[] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     *
     * @param len
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    private static long[] dividedBy(final int len, final long[] a, final long[] b, final long[] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] / b[i] / c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) / (i < lenB ? b[i] : valueForNoneB) / (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[][] dividedBy(final long[][] a, final long[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[][] dividedBy(final long[][] a, final long[][] b, final long valueForNoneA, final long valueForNoneB) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     *
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    private static long[][] dividedBy(final int len, final int rowLen, final long[][] a, final long[][] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, (long[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[][] dividedBy(final long[][] a, final long[][] b, final long[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[][] dividedBy(final long[][] a, final long[][] b, final long[][] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     *
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    private static long[][] dividedBy(final int len, final int rowLen, final long[][] a, final long[][] b, final long[][] c, final long valueForNoneA,
            final long valueForNoneB, final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @return
     */
    public static long[][][] dividedBy(final long[][][] a, final long[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @return
     */
    public static long[][][] dividedBy(final long[][][] a, final long[][][] b, final long valueForNoneA, final long valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long[][][] dividedBy(final long[][][] a, final long[][][] b, final long[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @return
     */
    public static long[][][] dividedBy(final long[][][] a, final long[][][] b, final long[][][] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param defaultValueForZero
     * @return
     */
    public static long[] dividedBy(final long[] a, final long[] b, final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param defaultValueForZero
     * @return
     */
    public static long[] dividedBy(final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB, final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     *
     * @param len
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param defaultValueForZero
     * @return
     */
    private static long[] dividedBy(final int len, final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB,
            final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA / (b[i] == 0 ? defaultValueForZero : b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] / valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA / valueForNoneB;
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param defaultValueForZero
     * @return
     */
    public static long[] dividedBy(final long[] a, final long[] b, final long[] c, final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param defaultValueForZero
     * @return
     */
    public static long[] dividedBy(final long[] a, final long[] b, final long[] c, final long valueForNoneA, final long valueForNoneB, final long valueForNoneC,
            final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     *
     * @param len
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param defaultValueForZero
     * @return
     */
    private static long[] dividedBy(final int len, final long[] a, final long[] b, final long[] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC, final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) / (i < lenB ? (b[i] == 0 ? defaultValueForZero : b[i]) : valueForNoneB)
                        / (i < lenC ? (c[i] == 0 ? defaultValueForZero : c[i]) : valueForNoneC);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param defaultValueForZero
     * @return
     */
    public static long[][] dividedBy(final long[][] a, final long[][] b, final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param defaultValueForZero
     * @return
     */
    public static long[][] dividedBy(final long[][] a, final long[][] b, final long valueForNoneA, final long valueForNoneB, final long defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     *
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param defaultValueForZero
     * @return
     */
    private static long[][] dividedBy(final int len, final int rowLen, final long[][] a, final long[][] b, final long valueForNoneA, final long valueForNoneB,
            final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, (long[]) null, null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param defaultValueForZero
     * @return
     */
    public static long[][] dividedBy(final long[][] a, final long[][] b, final long[][] c, final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param defaultValueForZero
     * @return
     */
    public static long[][] dividedBy(final long[][] a, final long[][] b, final long[][] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC, final long defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     *
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param defaultValueForZero
     * @return
     */
    private static long[][] dividedBy(final int len, final int rowLen, final long[][] a, final long[][] b, final long[][] c, final long valueForNoneA,
            final long valueForNoneB, final long valueForNoneC, final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param defaultValueForZero
     * @return
     */
    public static long[][][] dividedBy(final long[][][] a, final long[][][] b, final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param defaultValueForZero
     * @return
     */
    public static long[][][] dividedBy(final long[][][] a, final long[][][] b, final long valueForNoneA, final long valueForNoneB,
            final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param defaultValueForZero
     * @return
     */
    public static long[][][] dividedBy(final long[][][] a, final long[][][] b, final long[][][] c, final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     *
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param defaultValueForZero
     * @return
     */
    public static long[][][] dividedBy(final long[][][] a, final long[][][] b, final long[][][] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC, final long defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                    defaultValueForZero);
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[] zip(final long[] a, final long[] b, final Throwables.LongBiFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[] zip(final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB,
            final Throwables.LongBiFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return zip(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     *
     * @param <E>
     * @param len
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param zipFunction
     * @return
     * @throws E the e
     */
    private static <E extends Exception> long[] zip(final int len, final long[] a, final long[] b, final long valueForNoneA, final long valueForNoneB,
            final Throwables.LongBiFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zipFunction.apply(valueForNoneA, b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zipFunction.apply(a[i], valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zipFunction.apply(valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[] zip(final long[] a, final long[] b, final long[] c, final Throwables.LongTriFunction<Long, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[] zip(final long[] a, final long[] b, final long[] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC, final Throwables.LongTriFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return zip(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
    }

    /**
     *
     * @param <E>
     * @param len
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param zipFunction
     * @return
     * @throws E the e
     */
    private static <E extends Exception> long[] zip(final int len, final long[] a, final long[] b, final long[] c, final long valueForNoneA,
            final long valueForNoneB, final long valueForNoneC, final Throwables.LongTriFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[] result = new long[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[][] zip(final long[][] a, final long[][] b, final Throwables.LongBiFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[][] zip(final long[][] a, final long[][] b, final long valueForNoneA, final long valueForNoneB,
            final Throwables.LongBiFunction<Long, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     *
     * @param <E>
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param zipFunction
     * @return
     * @throws E the e
     */
    private static <E extends Exception> long[][] zip(final int len, final int rowLen, final long[][] a, final long[][] b, final long valueForNoneA,
            final long valueForNoneB, final Throwables.LongBiFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zip(rowLen, null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zip(rowLen, a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zip(rowLen, null, null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[][] zip(final long[][] a, final long[][] b, final long[][] c,
            final Throwables.LongTriFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[][] zip(final long[][] a, final long[][] b, final long[][] c, final long valueForNoneA, final long valueForNoneB,
            final long valueForNoneC, final Throwables.LongTriFunction<Long, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC, zipFunction);
    }

    /**
     *
     * @param <E>
     * @param len
     * @param rowLen
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param zipFunction
     * @return
     * @throws E the e
     */
    private static <E extends Exception> long[][] zip(final int len, final int rowLen, final long[][] a, final long[][] b, final long[][] c,
            final long valueForNoneA, final long valueForNoneB, final long valueForNoneC, final Throwables.LongTriFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][] result = new long[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zip(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                        zipFunction);
            }
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[][][] zip(final long[][][] a, final long[][][] b, final Throwables.LongBiFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[][][] zip(final long[][][] a, final long[][][] b, final long valueForNoneA, final long valueForNoneB,
            final Throwables.LongBiFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final long[][][] result = new long[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = zip(a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = zip(null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = zip(a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[][][] zip(final long[][][] a, final long[][][] b, final long[][][] c,
            final Throwables.LongTriFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     *
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param zipFunction
     * @return
     * @throws E the e
     */
    public static <E extends Exception> long[][][] zip(final long[][][] a, final long[][][] b, final long[][][] c, final long valueForNoneA,
            final long valueForNoneB, final long valueForNoneC, final Throwables.LongTriFunction<Long, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final long[][][] result = new long[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = zip(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = zip(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        return result;
    }

    public static long totalCountOfElements(final long[][] a) {
        long count = 0;

        for (final long[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        return count;
    }

    public static long totalCountOfElements(final long[][][] a) {
        long count = 0;

        for (final long[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final long[] longs : element) {
                if (N.isEmpty(longs)) {
                    continue;
                }

                count += longs.length;
            }
        }

        return count;
    }

    /**
     * Min sub array len.
     *
     * @param a
     * @return
     */
    public static int minSubArrayLen(final long[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int minLen = Integer.MAX_VALUE;

        for (final long[] ae : a) {
            minLen = N.min(minLen, ae == null ? 0 : ae.length);
        }

        return minLen;
    }

    /**
     * Max sub array len.
     *
     * @param a
     * @return
     */
    public static int maxSubArrayLen(final long[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int maxLen = 0;

        for (final long[] ae : a) {
            maxLen = N.max(maxLen, ae == null ? 0 : ae.length);
        }

        return maxLen;
    }

    /**
     *
     * @param a
     * @return
     */
    public static String println(final long[] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            return N.println(N.toString(a));
        }
    }

    /**
     *
     * @param a
     */
    public static String println(final long[][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final long[] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(", ");
                            }

                            sb.append(ai[j]);
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     *
     * @param a
     */
    public static String println(final long[][][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final long[][] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(',').append(IOUtil.LINE_SEPARATOR).append("  ");
                            }

                            if (ai[j] == null) {
                                sb.append("null");
                            } else if (ai[j].length == 0) {
                                sb.append("[]");
                            } else {
                                final long[] aij = ai[j];
                                sb.append('[');

                                for (int k = 0, aijLen = aij.length; k < aijLen; k++) {
                                    if (k > 0) {
                                        sb.append(", ");
                                    }

                                    sb.append(aij[k]);
                                }

                                sb.append(']');
                            }
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Adds a scalar value to each element of the specified float array in-place.
     * The modification is performed directly on the input array.
     *
     * <pre><code>
     * float[] array = {1.0f, 2.0f, 3.0f};
     * Arrays35.plus(array, 10.0f); // array becomes {11.0f, 12.0f, 13.0f}
     * </code></pre>
     *
     * @param a the array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to add to each element.
     */
    public static void plus(final float[] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] += param;
        }
    }

    /**
     * Adds a scalar value to each element of the specified 2D float array in-place.
     * This method iterates through each 1D sub-array and applies the addition.
     *
     * <pre><code>
     * float[][] matrix = {{1.0f, 2.0f}, {3.0f, 4.0f}};
     * Arrays35.plus(matrix, 10.0f); // matrix becomes {{11.0f, 12.0f}, {13.0f, 14.0f}}
     * </code></pre>
     *
     * @param a the 2D array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to add to each element.
     */
    public static void plus(final float[][] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[] element : a) {
            plus(element, param);
        }
    }

    /**
     * Adds a scalar value to each element of the specified 3D float array in-place.
     * This method recursively applies the addition to each 2D sub-array.
     *
     * <pre><code>
     * float[][][] cube = {{{1.0f}, {2.0f}}, {{3.0f}, {4.0f}}};
     * Arrays35.plus(cube, 10.0f); // cube becomes {{{11.0f}, {12.0f}}, {{13.0f}, {14.0f}}}
     * </code></pre>
     *
     * @param a the 3D array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to add to each element.
     */
    public static void plus(final float[][][] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[][] element : a) {
            plus(element, param);
        }
    }

    /**
     * Subtracts a scalar value from each element of the specified float array in-place.
     * The modification is performed directly on the input array.
     *
     * <pre><code>
     * float[] array = {11.0f, 12.0f, 13.0f};
     * Arrays35.minus(array, 10.0f); // array becomes {1.0f, 2.0f, 3.0f}
     * </code></pre>
     *
     * @param a the array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to subtract from each element.
     */
    public static void minus(final float[] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] -= param;
        }
    }

    /**
     * Subtracts a scalar value from each element of the specified 2D float array in-place.
     * This method iterates through each 1D sub-array and applies the subtraction.
     *
     * <pre><code>
     * float[][] matrix = {{11.0f, 12.0f}, {13.0f, 14.0f}};
     * Arrays35.minus(matrix, 10.0f); // matrix becomes {{1.0f, 2.0f}, {3.0f, 4.0f}}
     * </code></pre>
     *
     * @param a the 2D array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to subtract from each element.
     */
    public static void minus(final float[][] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[] element : a) {
            minus(element, param);
        }
    }

    /**
     * Subtracts a scalar value from each element of the specified 3D float array in-place.
     * This method recursively applies the subtraction to each 2D sub-array.
     *
     * <pre><code>
     * float[][][] cube = {{{11.0f}, {12.0f}}, {{13.0f}, {14.0f}}};
     * Arrays35.minus(cube, 10.0f); // cube becomes {{{1.0f}, {2.0f}}, {{3.0f}, {4.0f}}}
     * </code></pre>
     *
     * @param a the 3D array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to subtract from each element.
     */
    public static void minus(final float[][][] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[][] element : a) {
            minus(element, param);
        }
    }

    /**
     * Multiplies each element of the specified float array by a scalar value in-place.
     * The modification is performed directly on the input array.
     *
     * <pre><code>
     * float[] array = {1.0f, 2.0f, 3.0f};
     * Arrays35.multipliedBy(array, 2.0f); // array becomes {2.0f, 4.0f, 6.0f}
     * </code></pre>
     *
     * @param a the array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to multiply each element by.
     */
    public static void multipliedBy(final float[] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] *= param;
        }
    }

    /**
     * Multiplies each element of the specified 2D float array by a scalar value in-place.
     * This method iterates through each 1D sub-array and applies the multiplication.
     *
     * <pre><code>
     * float[][] matrix = {{1.0f, 2.0f}, {3.0f, 4.0f}};
     * Arrays35.multipliedBy(matrix, 2.0f); // matrix becomes {{2.0f, 4.0f}, {6.0f, 8.0f}}
     * </code></pre>
     *
     * @param a the 2D array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to multiply each element by.
     */
    public static void multipliedBy(final float[][] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     * Multiplies each element of the specified 3D float array by a scalar value in-place.
     * This method recursively applies the multiplication to each 2D sub-array.
     *
     * <pre><code>
     * float[][][] cube = {{{1.0f}, {2.0f}}, {{3.0f}, {4.0f}}};
     * Arrays35.multipliedBy(cube, 2.0f); // cube becomes {{{2.0f}, {4.0f}}, {{6.0f}, {8.0f}}}
     * </code></pre>
     *
     * @param a the 3D array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to multiply each element by.
     */
    public static void multipliedBy(final float[][][] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[][] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     * Divides each element of the specified float array by a scalar value in-place.
     * The modification is performed directly on the input array.
     *
     * <pre><code>
     * float[] array = {2.0f, 4.0f, 6.0f};
     * Arrays35.dividedBy(array, 2.0f); // array becomes {1.0f, 2.0f, 3.0f}
     * </code></pre>
     *
     * @param a the array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to divide each element by.
     */
    public static void dividedBy(final float[] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] /= param;
        }
    }

    /**
     * Divides each element of the specified 2D float array by a scalar value in-place.
     * This method iterates through each 1D sub-array and applies the division.
     *
     * <pre><code>
     * float[][] matrix = {{2.0f, 4.0f}, {6.0f, 8.0f}};
     * Arrays35.dividedBy(matrix, 2.0f); // matrix becomes {{1.0f, 2.0f}, {3.0f, 4.0f}}
     * </code></pre>
     *
     * @param a the 2D array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to divide each element by.
     */
    public static void dividedBy(final float[][] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     * Divides each element of the specified 3D float array by a scalar value in-place.
     * This method recursively applies the division to each 2D sub-array.
     *
     * <pre><code>
     * float[][][] cube = {{{2.0f}, {4.0f}}, {{6.0f}, {8.0f}}};
     * Arrays35.dividedBy(cube, 2.0f); // cube becomes {{{1.0f}, {2.0f}}, {{3.0f}, {4.0f}}}
     * </code></pre>
     *
     * @param a the 3D array to be modified. It can be {@code null} or empty, in which case the method does nothing.
     * @param param the float value to divide each element by.
     */
    public static void dividedBy(final float[][][] a, final float param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[][] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     * Updates each element of the specified float array in-place by applying a given unary operator.
     *
     * <pre><code>
     * float[] array = {1.0f, -2.0f, 3.0f};
     * Arrays35.updateAll(array, x -> Math.abs(x)); // array becomes {1.0f, 2.0f, 3.0f}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the operator.
     * @param a the array to be updated. If null or empty, the method returns immediately.
     * @param operator the unary operator to apply to each element.
     * @throws E if the operator throws an exception.
     */
    public static <E extends Exception> void updateAll(final float[] a, final Throwables.FloatUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsFloat(a[i]);
        }
    }

    /**
     * Updates each element of the specified 2D float array in-place by applying a given unary operator.
     *
     * <pre><code>
     * float[][] matrix = {{1.0f, -2.0f}, {-3.0f, 4.0f}};
     * Arrays35.updateAll(matrix, x -> x * x); // matrix becomes {{1.0f, 4.0f}, {9.0f, 16.0f}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the operator.
     * @param a the 2D array to be updated. If null or empty, the method returns immediately.
     * @param operator the unary operator to apply to each element.
     * @throws E if the operator throws an exception.
     */
    public static <E extends Exception> void updateAll(final float[][] a, final Throwables.FloatUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Updates each element of the specified 3D float array in-place by applying a given unary operator.
     *
     * <pre><code>
     * float[][][] cube = {{{-1.0f}}, {{2.0f}}};
     * Arrays35.updateAll(cube, x -> -x); // cube becomes {{{1.0f}}, {{-2.0f}}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the operator.
     * @param a the 3D array to be updated. If null or empty, the method returns immediately.
     * @param operator the unary operator to apply to each element.
     * @throws E if the operator throws an exception.
     */
    public static <E extends Exception> void updateAll(final float[][][] a, final Throwables.FloatUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[][] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Replaces each element of a float array with the specified new value if it satisfies the given predicate.
     * The modification is done in-place.
     *
     * <pre><code>
     * float[] array = {1.0f, -2.0f, 3.0f, -4.0f};
     * Arrays35.replaceIf(array, x -> x < 0, 0.0f); // array becomes {1.0f, 0.0f, 3.0f, 0.0f}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the predicate.
     * @param a the array to be modified.
     * @param predicate the condition to test for each element.
     * @param newValue the value to be placed in the array if the predicate is true.
     * @throws E if the predicate throws an exception.
     */
    public static <E extends Exception> void replaceIf(final float[] a, final Throwables.FloatPredicate<E> predicate, final float newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
            }
        }
    }

    /**
     * Replaces each element of a 2D float array with the specified new value if it satisfies the given predicate.
     * The modification is done in-place.
     *
     * <pre><code>
     * float[][] matrix = {{1.0f, -2.0f}, {0.0f, -4.0f}};
     * Arrays35.replaceIf(matrix, x -> x <= 0, 99.0f); // matrix becomes {{1.0f, 99.0f}, {99.0f, 99.0f}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the predicate.
     * @param a the 2D array to be modified.
     * @param predicate the condition to test for each element.
     * @param newValue the value to be placed in the array if the predicate is true.
     * @throws E if the predicate throws an exception.
     */
    public static <E extends Exception> void replaceIf(final float[][] a, final Throwables.FloatPredicate<E> predicate, final float newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Replaces each element of a 3D float array with the specified new value if it satisfies the given predicate.
     * The modification is done in-place.
     *
     * <pre><code>
     * float[][][] cube = {{{1f, -2f}}, {{-3f, 4f}}};
     * Arrays35.replaceIf(cube, x -> x > 0, 0.0f); // cube becomes {{{0.0f, -2.0f}}, {{-3.0f, 0.0f}}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the predicate.
     * @param a the 3D array to be modified.
     * @param predicate the condition to test for each element.
     * @param newValue the value to be placed in the array if the predicate is true.
     * @throws E if the predicate throws an exception.
     */
    public static <E extends Exception> void replaceIf(final float[][][] a, final Throwables.FloatPredicate<E> predicate, final float newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final float[][] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Reshapes a 1D float array into a 2D float array with the specified number of columns.
     * The last row of the resulting 2D array may have fewer elements if the length of the
     * input array is not a multiple of {@code cols}.
     *
     * <pre><code>
     * float[] array = {1, 2, 3, 4, 5, 6, 7};
     * float[][] matrix = Arrays35.reshape(array, 3); // returns {{1, 2, 3}, {4, 5, 6}, {7}}
     * </code></pre>
     *
     * @param a the 1D array to reshape.
     * @param cols the number of columns in the new 2D array.
     * @return a new 2D array containing the elements of the input array.
     * @throws IllegalArgumentException if {@code cols} is not positive.
     */
    public static float[][] reshape(final float[] a, final int cols) throws IllegalArgumentException {
        checkMForReshape(cols);

        if (N.isEmpty(a)) {
            return new float[0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, cols, RoundingMode.CEILING);
        final float[][] c = new float[n][];

        for (int i = 0, from = 0; i < n; i++, from += cols) {
            c[i] = N.copyOfRange(a, from, from + N.min(len - from, cols));
        }

        return c;
    }

    /**
     * Reshapes a 1D float array into a 3D float array with the specified number of rows and columns.
     * The last sub-array may be smaller if the total number of elements is not a multiple
     * of {@code rows * cols}.
     *
     * <pre><code>
     * float[] array = {1, 2, 3, 4, 5, 6, 7};
     * float[][][] cube = Arrays35.reshape(array, 2, 2); // returns {{{1,2},{3,4}},{{5,6},{7}}}
     * </code></pre>
     *
     * @param a the 1D array to reshape.
     * @param rows the number of rows in each 2D sub-array.
     * @param cols the number of columns in each 2D sub-array.
     * @return a new 3D array containing the elements of the input array.
     * @throws IllegalArgumentException if {@code rows} or {@code cols} are not positive.
     */
    public static float[][][] reshape(final float[] a, final int rows, final int cols) throws IllegalArgumentException {
        checkMAndLForReshape(rows, cols);

        if (N.isEmpty(a)) {
            return new float[0][0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, rows * cols, RoundingMode.CEILING);
        final float[][][] c = new float[n][][];

        for (int i = 0, from = 0; i < n; i++) {
            c[i] = new float[N.min(rows, Numbers.divide(len - from, cols, RoundingMode.CEILING))][];

            for (int j = 0, y = c[i].length; j < y; j++, from += cols) {
                c[i][j] = N.copyOfRange(a, from, from + N.min(len - from, cols));
            }
        }

        return c;
    }

    /**
     * Flattens a 2D float array into a new 1D float array.
     * This method concatenates all sub-arrays into a single array.
     * Null or empty sub-arrays are skipped.
     *
     * <pre><code>
     * float[][] matrix = {{1.0f, 2.0f}, {3.0f, 4.0f}};
     * float[] array = Arrays35.flatten(matrix); // returns {1.0f, 2.0f, 3.0f, 4.0f}
     * </code></pre>
     *
     * @param a the 2D array to flatten.
     * @return a new 1D array containing all elements from the 2D array.
     */
    public static float[] flatten(final float[][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_FLOAT_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final float[] c = new float[count];
        int from = 0;

        for (final float[] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            N.copy(element, 0, c, from, element.length);

            from += element.length;
        }

        return c;
    }

    /**
     * Flattens a 3D float array into a new 1D float array.
     * This method concatenates all innermost sub-arrays into a single array.
     * Null or empty sub-arrays at any level are skipped.
     *
     * <pre><code>
     * float[][][] cube = {{{1.0f}, {2.0f}}, {{3.0f}, {4.0f}}};
     * float[] array = Arrays35.flatten(cube); // returns {1.0f, 2.0f, 3.0f, 4.0f}
     * </code></pre>
     *
     * @param a the 3D array to flatten.
     * @return a new 1D array containing all elements from the 3D array.
     */
    public static float[] flatten(final float[][][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_FLOAT_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final float[] c = new float[count];
        int from = 0;

        for (final float[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final float[] floats : element) {
                if (N.isEmpty(floats)) {
                    continue;
                }

                N.copy(floats, 0, c, from, floats.length);

                from += floats.length;
            }
        }

        return c;
    }

    /**
     * Flattens a 2D array, performs a specified operation on the resulting 1D array,
     * and then copies the modified elements back into the original 2D array in-place.
     * This is useful for applying operations like sorting to the entire set of elements
     * in a multi-dimensional array.
     *
     * <pre><code>
     * float[][] matrix = {{4.0f, 1.0f}, {3.0f, 2.0f}};
     * Arrays35.flatOp(matrix, N::sort); // matrix becomes {{1.0f, 2.0f}, {3.0f, 4.0f}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the operation.
     * @param a the 2D array to operate on.
     * @param op the operation to perform on the flattened array.
     * @throws E if the operation throws an exception.
     */
    public static <E extends Exception> void flatOp(final float[][] a, final Throwables.Consumer<? super float[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final float[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final float[] e : a) {
            if (N.notEmpty(e)) {
                N.copy(tmp, idx, e, 0, e.length);
                idx += e.length;
            }
        }
    }

    /**
     * Flattens a 3D array, performs a specified operation on the resulting 1D array,
     * and then copies the modified elements back into the original 3D array in-place.
     * This is useful for applying operations like sorting to the entire set of elements
     * in a multi-dimensional array.
     *
     * <pre><code>
     * float[][][] cube = {{{4.0f, 1.0f}}, {{3.0f, 2.0f}}};
     * Arrays35.flatOp(cube, N::sort); // cube becomes {{{1.0f, 2.0f}}, {{3.0f, 4.0f}}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the operation.
     * @param a the 3D array to operate on.
     * @param op the operation to perform on the flattened array.
     * @throws E if the operation throws an exception.
     */
    public static <E extends Exception> void flatOp(final float[][][] a, final Throwables.Consumer<? super float[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final float[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final float[][] e : a) {
            if (N.notEmpty(e)) {
                for (final float[] ee : e) {
                    if (N.notEmpty(ee)) {
                        N.copy(tmp, idx, ee, 0, ee.length);
                        idx += ee.length;
                    }
                }
            }
        }
    }

    /**
     * Adds two float arrays element-wise.
     * The resulting array's length will be the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * float[] a = {1.0f, 2.0f, 3.0f};
     * float[] b = {4.0f, 5.0f};
     * float[] result = Arrays35.add(a, b); // result is {5.0f, 7.0f}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @return a new array containing the element-wise sum.
     */
    public static float[] add(final float[] a, final float[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] + b[i];
        }

        return result;
    }

    /**
     * Adds two float arrays element-wise, providing default values for elements in arrays
     * that are shorter than the other. The resulting array's length will be the maximum
     * of the lengths of the input arrays.
     *
     * <pre><code>
     * float[] a = {1.0f, 2.0f, 3.0f};
     * float[] b = {4.0f, 5.0f};
     * float[] result = Arrays35.add(a, b, 0.0f, 10.0f); // result is {5.0f, 7.0f, 13.0f}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA the default value to use if array {@code a} is shorter.
     * @param valueForNoneB the default value to use if array {@code b} is shorter.
     * @return a new array containing the element-wise sum.
     */
    public static float[] add(final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return add(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper to add two float arrays with a specified result length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new array with the sum.
     */
    private static float[] add(final int len, final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] + b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA + b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] + valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA + valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Adds three float arrays element-wise.
     * The resulting array's length will be the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * float[] a = {1, 2, 3};
     * float[] b = {4, 5, 6};
     * float[] c = {7, 8};
     * float[] result = Arrays35.add(a, b, c); // result is {12, 15}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @return a new array containing the element-wise sum.
     */
    public static float[] add(final float[] a, final float[] b, final float[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] + b[i] + c[i];
        }

        return result;
    }

    /**
     * Adds three float arrays element-wise, providing default values for shorter arrays.
     * The resulting array's length will be the maximum of the lengths of the input arrays.
     *
     * <pre><code>
     * float[] a = {1, 2};
     * float[] b = {3, 4, 5};
     * float[] c = {6};
     * float[] result = Arrays35.add(a, b, c, 0f, 0f, 0f); // result is {10, 6, 5}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA the default value to use if array {@code a} has missing elements.
     * @param valueForNoneB the default value to use if array {@code b} has missing elements.
     * @param valueForNoneC the default value to use if array {@code c} has missing elements.
     * @return a new array containing the element-wise sum.
     */
    public static float[] add(final float[] a, final float[] b, final float[] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return add(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper to add three float arrays with a specified result length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new array with the sum.
     */
    private static float[] add(final int len, final float[] a, final float[] b, final float[] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] + b[i] + c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) + (i < lenB ? b[i] : valueForNoneB) + (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Adds two 2D float arrays element-wise.
     * The operation is applied sub-array by sub-array. The dimensions of the resulting
     * array are determined by the minimum dimensions of the input arrays.
     *
     * <pre><code>
     * float[][] a = {{1, 2}, {3, 4}};
     * float[][] b = {{5, 6}, {7, 8}};
     * float[][] result = Arrays35.add(a, b); // result is {{6, 8}, {10, 12}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @return a new 2D array containing the element-wise sum.
     */
    public static float[][] add(final float[][] a, final float[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     * Adds two 2D float arrays element-wise, providing default values for missing elements
     * in ragged or shorter arrays. The resulting array's dimensions are the maximum of the
     * input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{1}, {2, 3}};
     * float[][] b = {{4, 5}};
     * float[][] result = Arrays35.add(a, b, 0f, 0f); // result is {{5, 5}, {2, 3}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA the default value for missing elements from array {@code a}.
     * @param valueForNoneB the default value for missing elements from array {@code b}.
     * @return a new 2D array containing the element-wise sum.
     */
    public static float[][] add(final float[][] a, final float[][] b, final float valueForNoneA, final float valueForNoneB) {
        return add(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper to add two 2D float arrays with specified result dimensions.
     *
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new 2D array with the sum.
     */
    private static float[][] add(final int len, final int rowLen, final float[][] a, final float[][] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = add(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = add(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = add(rowLen, (float[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Adds three 2D float arrays element-wise.
     * The operation is applied sub-array by sub-array. The dimensions of the resulting
     * array are determined by the minimum dimensions of the input arrays.
     *
     * <pre><code>
     * float[][] a = {{1}};
     * float[][] b = {{2, 3}};
     * float[][] c = {{4, 5}};
     * float[][] result = Arrays35.add(a, b, c); // result is {{7}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @return a new 2D array containing the element-wise sum.
     */
    public static float[][] add(final float[][] a, final float[][] b, final float[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Adds three 2D float arrays element-wise with default values for missing elements.
     * The resulting array's dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{1}};
     * float[][] b = {{2, 3}};
     * float[][] c = {{4, 5}, {6}};
     * float[][] result = Arrays35.add(a, b, c, 0f, 0f, 0f); // result is {{7, 8}, {6}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @return a new 2D array containing the element-wise sum.
     */
    public static float[][] add(final float[][] a, final float[][] b, final float[][] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        return add(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC);
    }

    /**
     * Private helper to add three 2D float arrays with specified result dimensions.
     *
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new 2D array with the sum.
     */
    private static float[][] add(final int len, final int rowLen, final float[][] a, final float[][] b, final float[][] c, final float valueForNoneA,
            final float valueForNoneB, final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = add(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Adds two 3D float arrays element-wise.
     * The operation is applied recursively. The dimensions of the resulting array are
     * determined by the minimum dimensions of the input arrays.
     *
     * <pre><code>
     * float[][][] a = {{{1, 2}}, {{3}}};
     * float[][][] b = {{{4, 5}}, {{6}}};
     * float[][][] result = Arrays35.add(a, b); // result is {{{5, 7}}, {{9}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @return a new 3D array containing the element-wise sum.
     */
    public static float[][][] add(final float[][][] a, final float[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     * Adds two 3D float arrays element-wise with default values for missing elements.
     * The resulting array's dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{1}}};
     * float[][][] b = {{{2}}, {{3, 4}}};
     * float[][][] result = Arrays35.add(a, b, 0f, 0f); // result is {{{3}}, {{3, 4}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @return a new 3D array containing the element-wise sum.
     */
    public static float[][][] add(final float[][][] a, final float[][][] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = add(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = add(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = add(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Adds three 3D float arrays element-wise.
     * The operation is applied recursively. The dimensions of the resulting array are
     * determined by the minimum dimensions of the input arrays.
     *
     * <pre><code>
     * float[][][] a = {{{1}}};
     * float[][][] b = {{{2}}};
     * float[][][] c = {{{3}}};
     * float[][][] result = Arrays35.add(a, b, c); // result is {{{6}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @return a new 3D array containing the element-wise sum.
     */
    public static float[][][] add(final float[][][] a, final float[][][] b, final float[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Adds three 3D float arrays element-wise with default values for missing elements.
     * The resulting array's dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{1}}};
     * float[][][] b = {{{2}},{{3}}};
     * float[][][] c = {{{4}},{{5}},{{6}}};
     * float[][][] result = Arrays35.add(a,b,c,0f,0f,0f); // result is {{{7}},{{8}},{{6}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @return a new 3D array containing the element-wise sum.
     */
    public static float[][][] add(final float[][][] a, final float[][][] b, final float[][][] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = add(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = add(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Subtracts the second float array from the first, element-wise.
     * The resulting array's length will be the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * float[] a = {10.0f, 9.0f, 8.0f};
     * float[] b = {1.0f, 2.0f};
     * float[] result = Arrays35.subtract(a, b); // result is {9.0f, 7.0f}
     * </code></pre>
     *
     * @param a the array to subtract from.
     * @param b the array to subtract.
     * @return a new array containing the element-wise difference.
     */
    public static float[] subtract(final float[] a, final float[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] - b[i];
        }

        return result;
    }

    /**
     * Subtracts two float arrays element-wise, providing default values for shorter arrays.
     * The resulting array's length will be the maximum of the lengths of the input arrays.
     *
     * <pre><code>
     * float[] a = {10.0f, 9.0f};
     * float[] b = {1.0f, 2.0f, 3.0f};
     * float[] result = Arrays35.subtract(a, b, 100.0f, 0.0f); // result is {9.0f, 7.0f, 100.0f}
     * </code></pre>
     *
     * @param a the first array (minuend).
     * @param b the second array (subtrahend).
     * @param valueForNoneA the default value to use if array {@code a} is shorter.
     * @param valueForNoneB the default value to use if array {@code b} is shorter.
     * @return a new array containing the element-wise difference.
     */
    public static float[] subtract(final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return subtract(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper to subtract two float arrays with a specified result length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new array with the difference.
     */
    private static float[] subtract(final int len, final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] - b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA - b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] - valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA - valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Subtracts the second and third float arrays from the first, element-wise.
     * The resulting array's length will be the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * float[] a = {10, 20, 30};
     * float[] b = {1, 2};
     * float[] c = {3, 4};
     * float[] result = Arrays35.subtract(a, b, c); // result is {6, 14}
     * </code></pre>
     *
     * @param a the array to subtract from.
     * @param b the second array to subtract.
     * @param c the third array to subtract.
     * @return a new array containing the element-wise difference.
     */
    public static float[] subtract(final float[] a, final float[] b, final float[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] - b[i] - c[i];
        }

        return result;
    }

    /**
     * Subtracts two arrays from a third element-wise, with default values for shorter arrays.
     * The resulting array's length is the maximum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {10, 20};
     * float[] b = {1, 2, 3};
     * float[] c = {4};
     * float[] result = Arrays35.subtract(a, b, c, 0f, 0f, 0f); // result is {5, 18, -3}
     * </code></pre>
     *
     * @param a the first array (minuend).
     * @param b the second array (subtrahend).
     * @param c the third array (subtrahend).
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @return a new array with the result.
     */
    public static float[] subtract(final float[] a, final float[] b, final float[] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return subtract(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper to subtract two arrays from a third with a specified result length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new array with the difference.
     */
    private static float[] subtract(final int len, final float[] a, final float[] b, final float[] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] - b[i] - c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) - (i < lenB ? b[i] : valueForNoneB) - (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Subtracts the second 2D array from the first, element-wise.
     * Dimensions of the result are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{10, 9}, {8, 7}};
     * float[][] b = {{1, 2}, {3, 4}};
     * float[][] result = Arrays35.subtract(a, b); // result is {{9, 7}, {5, 3}}
     * </code></pre>
     *
     * @param a the 2D array to subtract from.
     * @param b the 2D array to subtract.
     * @return a new 2D array with the element-wise difference.
     */
    public static float[][] subtract(final float[][] a, final float[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     * Subtracts two 2D arrays element-wise, with default values for missing elements.
     * Dimensions of the result are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{10}, {9, 8}};
     * float[][] b = {{1, 2}};
     * float[][] result = Arrays35.subtract(a, b, 0f, 0f); // result is {{9, -2}, {9, 8}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @return a new 2D array with the element-wise difference.
     */
    public static float[][] subtract(final float[][] a, final float[][] b, final float valueForNoneA, final float valueForNoneB) {
        return subtract(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper to subtract two 2D float arrays with specified result dimensions.
     *
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new 2D array with the difference.
     */
    private static float[][] subtract(final int len, final int rowLen, final float[][] a, final float[][] b, final float valueForNoneA,
            final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = subtract(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = subtract(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = subtract(rowLen, (float[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Subtracts the second and third 2D arrays from the first, element-wise.
     * Dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{10, 20}, {30, 40}};
     * float[][] b = {{1, 2}};
     * float[][] c = {{3, 4}};
     * float[][] result = Arrays35.subtract(a, b, c); // result is {{6, 14}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @return a new 2D array with the element-wise difference.
     */
    public static float[][] subtract(final float[][] a, final float[][] b, final float[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Subtracts two 2D arrays from a third element-wise, with default values for missing elements.
     * Dimensions of the result are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{10}};
     * float[][] b = {{1, 2}};
     * float[][] c = {{3, 4}, {5}};
     * float[][] result = Arrays35.subtract(a, b, c, 0f, 0f, 0f); // result is {{6, -6}, {-5}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @return a new 2D array with the result.
     */
    public static float[][] subtract(final float[][] a, final float[][] b, final float[][] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        return subtract(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper to subtract two 2D arrays from a third with specified result dimensions.
     *
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new 2D array with the difference.
     */
    private static float[][] subtract(final int len, final int rowLen, final float[][] a, final float[][] b, final float[][] c, final float valueForNoneA,
            final float valueForNoneB, final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = subtract(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Subtracts the second 3D array from the first, element-wise.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{10, 9}}, {{8}}};
     * float[][][] b = {{{1, 2}}, {{3}}};
     * float[][][] result = Arrays35.subtract(a, b); // result is {{{9, 7}}, {{5}}}
     * </code></pre>
     *
     * @param a the 3D array to subtract from.
     * @param b the 3D array to subtract.
     * @return a new 3D array with the element-wise difference.
     */
    public static float[][][] subtract(final float[][][] a, final float[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     * Subtracts two 3D arrays element-wise, with default values for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{10}}};
     * float[][][] b = {{{1}}, {{2, 3}}};
     * float[][][] result = Arrays35.subtract(a, b, 0f, 0f); // result is {{{9}}, {{-2, -3}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @return a new 3D array with the element-wise difference.
     */
    public static float[][][] subtract(final float[][][] a, final float[][][] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = subtract(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = subtract(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = subtract(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Subtracts the second and third 3D arrays from the first, element-wise.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{10}}};
     * float[][][] b = {{{1}}};
     * float[][][] c = {{{2}}};
     * float[][][] result = Arrays35.subtract(a, b, c); // result is {{{7}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @return a new 3D array with the element-wise difference.
     */
    public static float[][][] subtract(final float[][][] a, final float[][][] b, final float[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Subtracts two 3D arrays from a third, with default values for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{10}}};
     * float[][][] b = {{{1}},{{2}}};
     * float[][][] c = {{{3}},{{4}},{{5}}};
     * float[][][] result = Arrays35.subtract(a,b,c,0f,0f,0f); // result is {{{6}},{{-6}},{{-5}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @return a new 3D array with the result.
     */
    public static float[][][] subtract(final float[][][] a, final float[][][] b, final float[][][] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = subtract(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = subtract(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Multiplies two float arrays element-wise.
     * The resulting array's length is the minimum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {1.0f, 2.0f, 3.0f};
     * float[] b = {4.0f, 5.0f};
     * float[] result = Arrays35.multipliedBy(a, b); // result is {4.0f, 10.0f}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @return a new array containing the element-wise product.
     */
    public static float[] multipliedBy(final float[] a, final float[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] * b[i];
        }

        return result;
    }

    /**
     * Multiplies two float arrays element-wise, with default values for shorter arrays.
     * The resulting array's length is the maximum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {1.0f, 2.0f, 3.0f};
     * float[] b = {4.0f, 5.0f};
     * float[] result = Arrays35.multipliedBy(a, b, 1.0f, 10.0f); // result is {4.0f, 10.0f, 30.0f}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value if array {@code a} is shorter.
     * @param valueForNoneB default value if array {@code b} is shorter.
     * @return a new array containing the element-wise product.
     */
    public static float[] multipliedBy(final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return multipliedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper to multiply two float arrays with a specified result length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new array with the product.
     */
    private static float[] multipliedBy(final int len, final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] * b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA * b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] * valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA * valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Multiplies three float arrays element-wise.
     * The resulting array's length is the minimum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {1, 2, 3};
     * float[] b = {4, 5};
     * float[] c = {6, 7, 8};
     * float[] result = Arrays35.multipliedBy(a, b, c); // result is {24, 70}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @return a new array containing the element-wise product.
     */
    public static float[] multipliedBy(final float[] a, final float[] b, final float[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] * b[i] * c[i];
        }

        return result;
    }

    /**
     * Multiplies three float arrays element-wise, with default values for shorter arrays.
     * The resulting array's length is the maximum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {1, 2};
     * float[] b = {3, 4, 5};
     * float[] c = {6};
     * float[] result = Arrays35.multipliedBy(a, b, c, 1f, 1f, 1f); // result is {18, 8, 5}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for missing elements in array {@code a}.
     * @param valueForNoneB default value for missing elements in array {@code b}.
     * @param valueForNoneC default value for missing elements in array {@code c}.
     * @return a new array with the result.
     */
    public static float[] multipliedBy(final float[] a, final float[] b, final float[] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return multipliedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper to multiply three float arrays with a specified result length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new array with the product.
     */
    private static float[] multipliedBy(final int len, final float[] a, final float[] b, final float[] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] * b[i] * c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) * (i < lenB ? b[i] : valueForNoneB) * (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Multiplies two 2D float arrays element-wise.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{1, 2}, {3, 4}};
     * float[][] b = {{5, 6}};
     * float[][] result = Arrays35.multipliedBy(a, b); // result is {{5, 12}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @return a new 2D array with the element-wise product.
     */
    public static float[][] multipliedBy(final float[][] a, final float[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Multiplies two 2D arrays element-wise, with default values for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{2}, {3, 4}};
     * float[][] b = {{5, 6}};
     * float[][] result = Arrays35.multipliedBy(a, b, 1f, 1f); // result is {{10, 6}, {3, 4}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @return a new 2D array with the element-wise product.
     */
    public static float[][] multipliedBy(final float[][] a, final float[][] b, final float valueForNoneA, final float valueForNoneB) {
        return multipliedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper to multiply two 2D float arrays with specified result dimensions.
     *
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new 2D array with the product.
     */
    private static float[][] multipliedBy(final int len, final int rowLen, final float[][] a, final float[][] b, final float valueForNoneA,
            final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = multipliedBy(rowLen, (float[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Multiplies three 2D float arrays element-wise.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{1, 2}};
     * float[][] b = {{3, 4}};
     * float[][] c = {{5, 6}};
     * float[][] result = Arrays35.multipliedBy(a, b, c); // result is {{15, 48}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @return a new 2D array with the element-wise product.
     */
    public static float[][] multipliedBy(final float[][] a, final float[][] b, final float[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Multiplies three 2D arrays element-wise, with default values for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{1}};
     * float[][] b = {{2, 3}};
     * float[][] c = {{4, 5}, {6}};
     * float[][] result = Arrays35.multipliedBy(a, b, c, 1f, 1f, 1f); // result is {{8, 15}, {6}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @return a new 2D array with the result.
     */
    public static float[][] multipliedBy(final float[][] a, final float[][] b, final float[][] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        return multipliedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper to multiply three 2D float arrays with specified result dimensions.
     *
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new 2D array with the product.
     */
    private static float[][] multipliedBy(final int len, final int rowLen, final float[][] a, final float[][] b, final float[][] c, final float valueForNoneA,
            final float valueForNoneB, final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = multipliedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Multiplies two 3D float arrays element-wise.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{1, 2}}, {{3}}};
     * float[][][] b = {{{4, 5}}, {{6}}};
     * float[][][] result = Arrays35.multipliedBy(a, b); // result is {{{4, 10}}, {{18}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @return a new 3D array with the element-wise product.
     */
    public static float[][][] multipliedBy(final float[][][] a, final float[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Multiplies two 3D arrays element-wise, with default values for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{1}}};
     * float[][][] b = {{{2}}, {{3, 4}}};
     * float[][][] result = Arrays35.multipliedBy(a, b, 1f, 1f); // result is {{{2}}, {{3, 4}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @return a new 3D array with the element-wise product.
     */
    public static float[][][] multipliedBy(final float[][][] a, final float[][][] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = multipliedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = multipliedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Multiplies three 3D float arrays element-wise.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{1}}};
     * float[][][] b = {{{2}}};
     * float[][][] c = {{{3}}};
     * float[][][] result = Arrays35.multipliedBy(a, b, c); // result is {{{6}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @return a new 3D array with the element-wise product.
     */
    public static float[][][] multipliedBy(final float[][][] a, final float[][][] b, final float[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Multiplies three 3D arrays element-wise, with default values for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{1}}};
     * float[][][] b = {{{2}},{{3}}};
     * float[][][] c = {{{4}},{{5}},{{6}}};
     * float[][][] result = Arrays35.multipliedBy(a,b,c,1f,1f,1f); // result is {{{8}},{{15}},{{6}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @return a new 3D array with the result.
     */
    public static float[][][] multipliedBy(final float[][][] a, final float[][][] b, final float[][][] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = multipliedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Divides the first float array by the second, element-wise.
     * The resulting array's length is the minimum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {10.0f, 12.0f, 14.0f};
     * float[] b = {2.0f, 3.0f};
     * float[] result = Arrays35.dividedBy(a, b); // result is {5.0f, 4.0f}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the divisor array.
     * @return a new array containing the element-wise quotient.
     */
    public static float[] dividedBy(final float[] a, final float[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / b[i];
        }

        return result;
    }

    /**
     * Divides two float arrays element-wise, with default values for shorter arrays.
     * The resulting array's length is the maximum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {10.0f, 12.0f};
     * float[] b = {2.0f, 3.0f, 4.0f};
     * float[] result = Arrays35.dividedBy(a, b, 20.0f, 1.0f); // result is {5.0f, 4.0f, 20.0f}
     * </code></pre>
     *
     * @param a the first array (dividend).
     * @param b the second array (divisor).
     * @param valueForNoneA default value if array {@code a} is shorter.
     * @param valueForNoneB default value if array {@code b} is shorter.
     * @return a new array containing the element-wise quotient.
     */
    public static float[] dividedBy(final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper to divide two float arrays with a specified result length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new array with the quotient.
     */
    private static float[] dividedBy(final int len, final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] / b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA / b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] / valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA / valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Divides the first float array by the second and then by the third, element-wise.
     * The resulting array's length is the minimum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {120, 180};
     * float[] b = {2, 3};
     * float[] c = {10, 6};
     * float[] result = Arrays35.dividedBy(a, b, c); // result is {6, 10}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the first divisor array.
     * @param c the second divisor array.
     * @return a new array containing the final quotient.
     */
    public static float[] dividedBy(final float[] a, final float[] b, final float[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / b[i] / c[i];
        }

        return result;
    }

    /**
     * Divides arrays element-wise, with default values for shorter arrays.
     * The resulting array's length is the maximum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {120};
     * float[] b = {2, 3};
     * float[] c = {10, 6, 5};
     * float[] result = Arrays35.dividedBy(a, b, c, 180f, 1f, 1f); // result is {6, 60, 36}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the first divisor array.
     * @param c the second divisor array.
     * @param valueForNoneA default value for missing elements in array {@code a}.
     * @param valueForNoneB default value for missing elements in array {@code b}.
     * @param valueForNoneC default value for missing elements in array {@code c}.
     * @return a new array with the result.
     */
    public static float[] dividedBy(final float[] a, final float[] b, final float[] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper to divide three float arrays with a specified result length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new array with the quotient.
     */
    private static float[] dividedBy(final int len, final float[] a, final float[] b, final float[] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] / b[i] / c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) / (i < lenB ? b[i] : valueForNoneB) / (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Divides the first 2D array by the second, element-wise.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{10, 12}, {14, 16}};
     * float[][] b = {{2, 3}};
     * float[][] result = Arrays35.dividedBy(a, b); // result is {{5, 4}}
     * </code></pre>
     *
     * @param a the dividend 2D array.
     * @param b the divisor 2D array.
     * @return a new 2D array with the element-wise quotient.
     */
    public static float[][] dividedBy(final float[][] a, final float[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Divides two 2D arrays element-wise, with default values for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{10}, {12, 14}};
     * float[][] b = {{2, 4}};
     * float[][] result = Arrays35.dividedBy(a, b, 1f, 1f); // result is {{5, 0.25}, {12, 14}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @return a new 2D array with the element-wise quotient.
     */
    public static float[][] dividedBy(final float[][] a, final float[][] b, final float valueForNoneA, final float valueForNoneB) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper to divide two 2D float arrays with specified result dimensions.
     *
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new 2D array with the quotient.
     */
    private static float[][] dividedBy(final int len, final int rowLen, final float[][] a, final float[][] b, final float valueForNoneA,
            final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, (float[]) null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Divides the first 2D array by the second and then by the third, element-wise.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{120, 180}};
     * float[][] b = {{2, 3}};
     * float[][] c = {{10, 6}};
     * float[][] result = Arrays35.dividedBy(a, b, c); // result is {{6, 10}}
     * </code></pre>
     *
     * @param a the dividend 2D array.
     * @param b the first divisor 2D array.
     * @param c the second divisor 2D array.
     * @return a new 2D array with the final quotient.
     */
    public static float[][] dividedBy(final float[][] a, final float[][] b, final float[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Divides 2D arrays element-wise, with default values for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{120}};
     * float[][] b = {{2, 3}};
     * float[][] c = {{10, 6}, {5}};
     * float[][] result = Arrays35.dividedBy(a, b, c, 180f, 1f, 1f); // result is {{6, 60}, {36}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @return a new 2D array with the result.
     */
    public static float[][] dividedBy(final float[][] a, final float[][] b, final float[][] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper to divide three 2D float arrays with specified result dimensions.
     *
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new 2D array with the quotient.
     */
    private static float[][] dividedBy(final int len, final int rowLen, final float[][] a, final float[][] b, final float[][] c, final float valueForNoneA,
            final float valueForNoneB, final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Divides the first 3D array by the second, element-wise.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{10, 12}}, {{14}}};
     * float[][][] b = {{{2, 3}}, {{7}}};
     * float[][][] result = Arrays35.dividedBy(a, b); // result is {{{5, 4}}, {{2}}}
     * </code></pre>
     *
     * @param a the dividend 3D array.
     * @param b the divisor 3D array.
     * @return a new 3D array with the element-wise quotient.
     */
    public static float[][][] dividedBy(final float[][][] a, final float[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Divides two 3D arrays element-wise, with default values for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{10}}};
     * float[][][] b = {{{2}}, {{4, 5}}};
     * float[][][] result = Arrays35.dividedBy(a, b, 1f, 1f); // result is {{{5}}, {{1, 0.2}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @return a new 3D array with the element-wise quotient.
     */
    public static float[][][] dividedBy(final float[][][] a, final float[][][] b, final float valueForNoneA, final float valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Divides the first 3D array by the second and then by the third, element-wise.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{120}}};
     * float[][][] b = {{{2}}};
     * float[][][] c = {{{10}}};
     * float[][][] result = Arrays35.dividedBy(a, b, c); // result is {{{6}}}
     * </code></pre>
     *
     * @param a the dividend 3D array.
     * @param b the first divisor 3D array.
     * @param c the second divisor 3D array.
     * @return a new 3D array with the final quotient.
     */
    public static float[][][] dividedBy(final float[][][] a, final float[][][] b, final float[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Divides 3D arrays element-wise, with default values for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{120}}};
     * float[][][] b = {{{2}},{{1}}};
     * float[][][] c = {{{10}},{{6}},{{5}}};
     * float[][][] result = Arrays35.dividedBy(a,b,c,180f,1f,1f); // result is {{{6}},{{180}},{{36}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @return a new 3D array with the result.
     */
    public static float[][][] dividedBy(final float[][][] a, final float[][][] b, final float[][][] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Divides two float arrays element-wise, using a default value for division by zero.
     * The length of the result is the minimum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {10.0f, 20.0f};
     * float[] b = {2.0f, 0.0f};
     * float[] result = Arrays35.dividedBy(a, b, 1.0f); // result is {5.0f, 20.0f}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the divisor array.
     * @param defaultValueForZero the value to use as the divisor when an element in {@code b} is zero.
     * @return a new array with the element-wise quotient.
     */
    public static float[] dividedBy(final float[] a, final float[] b, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]);
        }

        return result;
    }

    /**
     * Divides two float arrays element-wise, with defaults for shorter arrays and for division by zero.
     * The result length is the maximum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {10.0f};
     * float[] b = {2.0f, 0.0f};
     * float[] result = Arrays35.dividedBy(a, b, 20f, 1f, 10f); // result is {5.0f, 2.0f}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the divisor array.
     * @param valueForNoneA default value if array {@code a} is shorter.
     * @param valueForNoneB default value if array {@code b} is shorter.
     * @param defaultValueForZero the value to use as the divisor when an element in {@code b} is zero.
     * @return a new array with the element-wise quotient.
     */
    public static float[] dividedBy(final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     * Private helper to divide two float arrays with a specified result length and zero-division handling.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param defaultValueForZero default value for divisor if zero.
     * @return a new array with the quotient.
     */
    private static float[] dividedBy(final int len, final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB,
            final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA / (b[i] == 0 ? defaultValueForZero : b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] / valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA / valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Divides arrays element-wise with a default for division by zero.
     * Result length is the minimum of input array lengths.
     *
     * <pre><code>
     * float[] a = {120, 180};
     * float[] b = {2, 0};
     * float[] c = {10, 6};
     * float[] result = Arrays35.dividedBy(a, b, c, 1f); // result is {6, 30}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the first divisor array.
     * @param c the second divisor array.
     * @param defaultValueForZero value to use when a divisor element is zero.
     * @return a new array with the result.
     */
    public static float[] dividedBy(final float[] a, final float[] b, final float[] c, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]);
        }

        return result;
    }

    /**
     * Divides arrays element-wise with defaults for short arrays and zero division.
     * Result length is the maximum of input array lengths.
     *
     * <pre><code>
     * float[] a = {120};
     * float[] b = {2, 0};
     * float[] c = {10, 6, 5};
     * float[] result = Arrays35.dividedBy(a, b, c, 180f, 1f, 1f, 1f); // result is {6, 30, 36}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the first divisor array.
     * @param c the second divisor array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @param defaultValueForZero value to use when a divisor element is zero.
     * @return a new array with the result.
     */
    public static float[] dividedBy(final float[] a, final float[] b, final float[] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     * Private helper to divide three float arrays with a specified result length and zero-division handling.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @param defaultValueForZero default value for divisor if zero.
     * @return a new array with the quotient.
     */
    private static float[] dividedBy(final int len, final float[] a, final float[] b, final float[] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) / (i < lenB ? (b[i] == 0 ? defaultValueForZero : b[i]) : valueForNoneB)
                        / (i < lenC ? (c[i] == 0 ? defaultValueForZero : c[i]) : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Divides two 2D arrays element-wise, with a default for division by zero.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{10, 20}};
     * float[][] b = {{2, 0}};
     * float[][] result = Arrays35.dividedBy(a, b, 1f); // result is {{5, 20}}
     * </code></pre>
     *
     * @param a the dividend 2D array.
     * @param b the divisor 2D array.
     * @param defaultValueForZero value to use when a divisor element is zero.
     * @return a new 2D array with the quotient.
     */
    public static float[][] dividedBy(final float[][] a, final float[][] b, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Divides two 2D arrays element-wise, with defaults for missing elements and zero division.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{10}};
     * float[][] b = {{2, 0}};
     * float[][] result = Arrays35.dividedBy(a, b, 20f, 1f, 10f); // result is {{5, 2}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param defaultValueForZero value to use when a divisor element is zero.
     * @return a new 2D array with the quotient.
     */
    public static float[][] dividedBy(final float[][] a, final float[][] b, final float valueForNoneA, final float valueForNoneB,
            final float defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     * Private helper to divide two 2D float arrays with specified dimensions and zero-division handling.
     *
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param defaultValueForZero default value for divisor if zero.
     * @return a new 2D array with the quotient.
     */
    private static float[][] dividedBy(final int len, final int rowLen, final float[][] a, final float[][] b, final float valueForNoneA,
            final float valueForNoneB, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, (float[]) null, null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Divides 2D arrays element-wise with a default for division by zero.
     * Result dimensions are the minimum of input array dimensions.
     *
     * <pre><code>
     * float[][] a = {{120, 180}};
     * float[][] b = {{2, 0}};
     * float[][] c = {{10, 6}};
     * float[][] result = Arrays35.dividedBy(a, b, c, 1f); // result is {{6, 30}}
     * </code></pre>
     *
     * @param a the dividend 2D array.
     * @param b the first divisor 2D array.
     * @param c the second divisor 2D array.
     * @param defaultValueForZero value to use when a divisor element is zero.
     * @return a new 2D array with the result.
     */
    public static float[][] dividedBy(final float[][] a, final float[][] b, final float[][] c, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Divides 2D arrays element-wise with defaults for missing elements and zero division.
     * Result dimensions are the maximum of input array dimensions.
     *
     * <pre><code>
     * float[][] a = {{120}};
     * float[][] b = {{2, 0}};
     * float[][] c = {{10, 6}, {5}};
     * float[][] result = Arrays35.dividedBy(a, b, c, 180f, 1f, 1f, 1f); // result is {{6, 30}, {36}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @param defaultValueForZero value to use when a divisor element is zero.
     * @return a new 2D array with the result.
     */
    public static float[][] dividedBy(final float[][] a, final float[][] b, final float[][] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC, final float defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     * Private helper to divide three 2D float arrays with specified dimensions and zero-division handling.
     *
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @param defaultValueForZero default value for divisor if zero.
     * @return a new 2D array with the quotient.
     */
    private static float[][] dividedBy(final int len, final int rowLen, final float[][] a, final float[][] b, final float[][] c, final float valueForNoneA,
            final float valueForNoneB, final float valueForNoneC, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Divides two 3D arrays element-wise, with a default for division by zero.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{10, 20}}};
     * float[][][] b = {{{2, 0}}};
     * float[][][] result = Arrays35.dividedBy(a, b, 1f); // result is {{{5, 20}}}
     * </code></pre>
     *
     * @param a the dividend 3D array.
     * @param b the divisor 3D array.
     * @param defaultValueForZero value to use when a divisor element is zero.
     * @return a new 3D array with the quotient.
     */
    public static float[][][] dividedBy(final float[][][] a, final float[][][] b, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Divides two 3D arrays element-wise, with defaults for missing elements and zero division.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{10}}};
     * float[][][] b = {{{2}}, {{0, 5}}};
     * float[][][] result = Arrays35.dividedBy(a, b, 20f, 1f, 10f); // result is {{{5}}, {{2, 0.2}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param defaultValueForZero value to use when a divisor element is zero.
     * @return a new 3D array with the quotient.
     */
    public static float[][][] dividedBy(final float[][][] a, final float[][][] b, final float valueForNoneA, final float valueForNoneB,
            final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Divides 3D arrays element-wise with a default for division by zero.
     * Result dimensions are the minimum of input array dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{120}}};
     * float[][][] b = {{{2}}};
     * float[][][] c = {{{0}}};
     * float[][][] result = Arrays35.dividedBy(a, b, c, 10f); // result is {{{6}}}
     * </code></pre>
     *
     * @param a the dividend 3D array.
     * @param b the first divisor 3D array.
     * @param c the second divisor 3D array.
     * @param defaultValueForZero value to use when a divisor element is zero.
     * @return a new 3D array with the result.
     */
    public static float[][][] dividedBy(final float[][][] a, final float[][][] b, final float[][][] c, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Divides 3D arrays element-wise with defaults for missing elements and zero division.
     * Result dimensions are the maximum of input array dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{120}}};
     * float[][][] b = {{{2}},{{0}}};
     * float[][][] c = {{{10}},{{6}},{{5}}};
     * float[][][] result = Arrays35.dividedBy(a,b,c,180f,1f,1f,1f); // result is {{{6}},{{30}},{{36}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @param defaultValueForZero value to use when a divisor element is zero.
     * @return a new 3D array with the result.
     */
    public static float[][][] dividedBy(final float[][][] a, final float[][][] b, final float[][][] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC, final float defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                    defaultValueForZero);
        }

        return result;
    }

    /**
     * Combines two float arrays into one by applying a binary function to each pair of elements.
     * The length of the result is the minimum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {1, 2, 3};
     * float[] b = {4, 5, 6};
     * float[] result = Arrays35.zip(a, b, (x, y) -> x + y); // result is {5, 7, 9}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first array.
     * @param b the second array.
     * @param zipFunction the function to apply to each pair of elements.
     * @return a new array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[] zip(final float[] a, final float[] b, final Throwables.FloatBiFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        return result;
    }

    /**
     * Combines two float arrays with a binary function, providing default values for shorter arrays.
     * The result length is the maximum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {1, 2, 3};
     * float[] b = {4, 5};
     * float[] result = Arrays35.zip(a, b, 0f, 10f, (x, y) -> x + y); // result is {5, 7, 13}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value if array {@code a} is shorter.
     * @param valueForNoneB default value if array {@code b} is shorter.
     * @param zipFunction the function to apply to each pair of elements.
     * @return a new array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[] zip(final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB,
            final Throwables.FloatBiFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return zip(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Private helper to zip two float arrays with a specified result length.
     *
     * @param <E> the type of exception.
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param zipFunction the function to combine elements.
     * @return a new array with zipped results.
     * @throws E if the function throws.
     */
    private static <E extends Exception> float[] zip(final int len, final float[] a, final float[] b, final float valueForNoneA, final float valueForNoneB,
            final Throwables.FloatBiFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zipFunction.apply(valueForNoneA, b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zipFunction.apply(a[i], valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zipFunction.apply(valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Combines three float arrays using a trinary function.
     * The result length is the minimum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {1, 2};
     * float[] b = {3, 4};
     * float[] c = {5, 6};
     * float[] result = Arrays35.zip(a, b, c, (x, y, z) -> x + y + z); // result is {9, 12}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param zipFunction the function to apply to each triplet of elements.
     * @return a new array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[] zip(final float[] a, final float[] b, final float[] c, final Throwables.FloatTriFunction<Float, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Combines three float arrays with a trinary function, providing defaults for shorter arrays.
     * The result length is the maximum of the input array lengths.
     *
     * <pre><code>
     * float[] a = {1, 2, 3};
     * float[] b = {4, 5};
     * float[] c = {6};
     * float[] result = Arrays35.zip(a, b, c, 0f, 0f, 0f, (x,y,z) -> x+y+z); // result is {11, 7, 3}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for missing elements in array {@code a}.
     * @param valueForNoneB default value for missing elements in array {@code b}.
     * @param valueForNoneC default value for missing elements in array {@code c}.
     * @param zipFunction the function to apply to each triplet of elements.
     * @return a new array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[] zip(final float[] a, final float[] b, final float[] c, final float valueForNoneA, final float valueForNoneB,
            final float valueForNoneC, final Throwables.FloatTriFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return zip(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
    }

    /**
     * Private helper to zip three float arrays with a specified result length.
     *
     * @param <E> the type of exception.
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @param zipFunction the function to combine elements.
     * @return a new array with zipped results.
     * @throws E if the function throws.
     */
    private static <E extends Exception> float[] zip(final int len, final float[] a, final float[] b, final float[] c, final float valueForNoneA,
            final float valueForNoneB, final float valueForNoneC, final Throwables.FloatTriFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[] result = new float[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Combines two 2D float arrays using a binary function.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{1, 2}};
     * float[][] b = {{3, 4}};
     * float[][] result = Arrays35.zip(a, b, (x,y) -> x*y); // result is {{3, 8}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param zipFunction the function to apply to each pair of elements.
     * @return a new 2D array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[][] zip(final float[][] a, final float[][] b, final Throwables.FloatBiFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines two 2D float arrays with a binary function, providing defaults for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{1}};
     * float[][] b = {{2, 3}};
     * float[][] result = Arrays35.zip(a, b, 0f, 10f, (x,y) -> x+y); // result is {{3, 13}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param zipFunction the function to apply to each pair of elements.
     * @return a new 2D array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[][] zip(final float[][] a, final float[][] b, final float valueForNoneA, final float valueForNoneB,
            final Throwables.FloatBiFunction<Float, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Private helper to zip two 2D float arrays with specified dimensions.
     *
     * @param <E> the type of exception.
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param zipFunction the function to combine elements.
     * @return a new 2D array with zipped results.
     * @throws E if the function throws.
     */
    private static <E extends Exception> float[][] zip(final int len, final int rowLen, final float[][] a, final float[][] b, final float valueForNoneA,
            final float valueForNoneB, final Throwables.FloatBiFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zip(rowLen, null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zip(rowLen, a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zip(rowLen, null, null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines three 2D float arrays using a trinary function.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{1}};
     * float[][] b = {{2, 3}};
     * float[][] c = {{4, 5}};
     * float[][] result = Arrays35.zip(a, b, c, (x,y,z) -> x+y+z); // result is {{7}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param zipFunction the function to apply to each triplet of elements.
     * @return a new 2D array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[][] zip(final float[][] a, final float[][] b, final float[][] c,
            final Throwables.FloatTriFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines three 2D float arrays with a trinary function, providing defaults for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][] a = {{1}};
     * float[][] b = {{2, 3}};
     * float[][] c = {{4, 5}, {6}};
     * float[][] result = Arrays35.zip(a,b,c,0f,0f,0f, (x,y,z)->x+y+z); // result is {{7, 8}, {6}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @param zipFunction the function to apply to each triplet of elements.
     * @return a new 2D array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[][] zip(final float[][] a, final float[][] b, final float[][] c, final float valueForNoneA,
            final float valueForNoneB, final float valueForNoneC, final Throwables.FloatTriFunction<Float, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC, zipFunction);
    }

    /**
     * Private helper to zip three 2D float arrays with specified dimensions.
     *
     * @param <E> the type of exception.
     * @param len the number of rows in the result.
     * @param rowLen the number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @param zipFunction the function to combine elements.
     * @return a new 2D array with zipped results.
     * @throws E if the function throws.
     */
    private static <E extends Exception> float[][] zip(final int len, final int rowLen, final float[][] a, final float[][] b, final float[][] c,
            final float valueForNoneA, final float valueForNoneB, final float valueForNoneC, final Throwables.FloatTriFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][] result = new float[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zip(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                        zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines two 3D float arrays using a binary function.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{1, 2}}};
     * float[][][] b = {{{3, 4}}};
     * float[][][] result = Arrays35.zip(a, b, (x,y) -> x*y); // result is {{{3, 8}}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param zipFunction the function to apply to each pair of elements.
     * @return a new 3D array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[][][] zip(final float[][][] a, final float[][][] b, final Throwables.FloatBiFunction<Float, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines two 3D float arrays with a binary function, providing defaults for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{1}}};
     * float[][][] b = {{{2}}, {{3, 4}}};
     * float[][][] result = Arrays35.zip(a, b, 0f, 10f, (x,y) -> x+y); // result is {{{3}}, {{13, 14}}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param zipFunction the function to apply to each pair of elements.
     * @return a new 3D array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[][][] zip(final float[][][] a, final float[][][] b, final float valueForNoneA, final float valueForNoneB,
            final Throwables.FloatBiFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final float[][][] result = new float[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = zip(a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = zip(null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = zip(a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines three 3D float arrays using a trinary function.
     * Result dimensions are the minimum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{1}}};
     * float[][][] b = {{{2, 3}}};
     * float[][][] c = {{{4, 5}}};
     * float[][][] result = Arrays35.zip(a, b, c, (x,y,z) -> x+y+z); // result is {{{7}}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @param zipFunction the function to apply to each triplet of elements.
     * @return a new 3D array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[][][] zip(final float[][][] a, final float[][][] b, final float[][][] c,
            final Throwables.FloatTriFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines three 3D float arrays with a trinary function, providing defaults for missing elements.
     * Result dimensions are the maximum of the input arrays' dimensions.
     *
     * <pre><code>
     * float[][][] a = {{{1}}};
     * float[][][] b = {{{2}},{{3}}};
     * float[][][] c = {{{4}},{{5}},{{6}}};
     * float[][][] result = Arrays35.zip(a,b,c,0f,0f,0f,(x,y,z)->x+y+z); // result is {{{7}},{{8}},{{6}}}
     * </code></pre>
     *
     * @param <E> the type of exception that can be thrown by the zip function.
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @param valueForNoneA default value for missing elements from array {@code a}.
     * @param valueForNoneB default value for missing elements from array {@code b}.
     * @param valueForNoneC default value for missing elements from array {@code c}.
     * @param zipFunction the function to apply to each triplet of elements.
     * @return a new 3D array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> float[][][] zip(final float[][][] a, final float[][][] b, final float[][][] c, final float valueForNoneA,
            final float valueForNoneB, final float valueForNoneC, final Throwables.FloatTriFunction<Float, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final float[][][] result = new float[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = zip(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = zip(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        return result;
    }

    /**
     * Calculates the total number of elements in a 2D float array.
     * This method sums the lengths of all sub-arrays.
     *
     * <pre><code>
     * float[][] matrix = {{1.0f}, {2.0f, 3.0f}, null};
     * long count = Arrays35.totalCountOfElements(matrix); // count is 3
     * </code></pre>
     *
     * @param a the 2D array to count elements in.
     * @return the total count of elements.
     */
    public static long totalCountOfElements(final float[][] a) {
        long count = 0;

        for (final float[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        return count;
    }

    /**
     * Calculates the total number of elements in a 3D float array.
     * This method recursively sums the lengths of all innermost sub-arrays.
     *
     * <pre><code>
     * float[][][] cube = {{{1.0f}}, {{2.0f, 3.0f}, null}, null};
     * long count = Arrays35.totalCountOfElements(cube); // count is 3
     * </code></pre>
     *
     * @param a the 3D array to count elements in.
     * @return the total count of elements.
     */
    public static long totalCountOfElements(final float[][][] a) {
        long count = 0;

        for (final float[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final float[] floats : element) {
                if (N.isEmpty(floats)) {
                    continue;
                }

                count += floats.length;
            }
        }

        return count;
    }

    /**
     * Finds the minimum length of any sub-array within a 2D float array.
     * Returns 0 for null or empty input array, or if a sub-array is null.
     *
     * <pre><code>
     * float[][] matrix = {{1.0f, 2.0f}, {3.0f}, null};
     * int minLen = Arrays35.minSubArrayLen(matrix); // minLen is 0
     * </code></pre>
     *
     * @param a the 2D array to inspect.
     * @return the minimum sub-array length found.
     */
    public static int minSubArrayLen(final float[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int minLen = Integer.MAX_VALUE;

        for (final float[] ae : a) {
            minLen = N.min(minLen, ae == null ? 0 : ae.length);
        }

        return minLen;
    }

    /**
     * Finds the maximum length of any sub-array within a 2D float array.
     * Returns 0 for null or empty input array. A null sub-array has a length of 0.
     *
     * <pre><code>
     * float[][] matrix = {{1.0f}, {2.0f, 3.0f, 4.0f}, null};
     * int maxLen = Arrays35.maxSubArrayLen(matrix); // maxLen is 3
     * </code></pre>
     *
     * @param a the 2D array to inspect.
     * @return the maximum sub-array length found.
     */
    public static int maxSubArrayLen(final float[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int maxLen = 0;

        for (final float[] ae : a) {
            maxLen = N.max(maxLen, ae == null ? 0 : ae.length);
        }

        return maxLen;
    }

    /**
     * Converts a float array to a string, prints it to the console, and returns the string.
     * Handles null arrays gracefully.
     *
     * <pre><code>
     * float[] array = {1.1f, 2.2f, 3.3f};
     * String s = Arrays35.println(array); // Prints "[1.1, 2.2, 3.3]" and returns it.
     * </code></pre>
     *
     * @param a the array to print.
     * @return the string representation of the array, followed by a newline.
     */
    public static String println(final float[] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            return N.println(N.toString(a));
        }
    }

    /**
     * Converts a 2D float array to a formatted string, prints it to the console, and returns the string.
     * Handles null arrays and null sub-arrays gracefully.
     *
     * <pre><code>
     * float[][] matrix = {{1.1f, 2.2f}, {3.3f}};
     * String s = Arrays35.println(matrix); // Prints "[[1.1, 2.2],\n [3.3]]" (example) and returns it.
     * </code></pre>
     *
     * @param a the 2D array to print.
     * @return the formatted string representation of the array, followed by a newline.
     */
    public static String println(final float[][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final float[] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(", ");
                            }

                            sb.append(ai[j]);
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Converts a 3D float array to a formatted string, prints it to the console, and returns the string.
     * Handles null arrays and null sub-arrays gracefully.
     *
     * <pre><code>
     * float[][][] cube = {{{1.1f}}, {{2.2f, 3.3f}}};
     * String s = Arrays35.println(cube); // Prints a formatted 3D representation and returns it.
     * </code></pre>
     *
     * @param a the 3D array to print.
     * @return the formatted string representation of the array, followed by a newline.
     */
    public static String println(final float[][][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final float[][] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(',').append(IOUtil.LINE_SEPARATOR).append("  ");
                            }

                            if (ai[j] == null) {
                                sb.append("null");
                            } else if (ai[j].length == 0) {
                                sb.append("[]");
                            } else {
                                final float[] aij = ai[j];
                                sb.append('[');

                                for (int k = 0, aijLen = aij.length; k < aijLen; k++) {
                                    if (k > 0) {
                                        sb.append(", ");
                                    }

                                    sb.append(aij[k]);
                                }

                                sb.append(']');
                            }
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Adds a scalar value to each element of the specified array in-place.
     * If the array is null or empty, the method returns without any modification.
     *
     * <pre><code>
     * double[] array = {1.0, 2.0, 3.0};
     * Arrays37.plus(array, 5.0);
     * // array is now {6.0, 7.0, 8.0}
     * </code></pre>
     *
     * @param a the array to be modified.
     * @param param the double value to add to each element.
     */
    public static void plus(final double[] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] += param;
        }
    }

    /**
     * Adds a scalar value to each element of the specified 2D array in-place.
     * This method iterates through each sub-array and applies the addition.
     * If the array or its sub-arrays are null or empty, they are skipped.
     *
     * <pre><code>
     * double[][] matrix = {{1.0, 2.0}, {3.0, 4.0}};
     * Arrays37.plus(matrix, 10.0);
     * // matrix is now {{11.0, 12.0}, {13.0, 14.0}}
     * </code></pre>
     *
     * @param a the 2D array to be modified.
     * @param param the double value to add to each element.
     */
    public static void plus(final double[][] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[] element : a) {
            plus(element, param);
        }
    }

    /**
     * Adds a scalar value to each element of the specified 3D array in-place.
     * This method recursively calls the plus operation for each 2D sub-array.
     * If the array or its sub-arrays are null or empty, they are skipped.
     *
     * <pre><code>
     * double[][][] cube = {{{1.0}, {2.0}}, {{3.0}, {4.0}}};
     * Arrays37.plus(cube, 100.0);
     * // cube is now {{{101.0}, {102.0}}, {{103.0}, {104.0}}}
     * </code></pre>
     *
     * @param a the 3D array to be modified.
     * @param param the double value to add to each element.
     */
    public static void plus(final double[][][] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[][] element : a) {
            plus(element, param);
        }
    }

    /**
     * Subtracts a scalar value from each element of the specified array in-place.
     * If the array is null or empty, the method returns without any modification.
     *
     * <pre><code>
     * double[] array = {10.0, 20.0, 30.0};
     * Arrays37.minus(array, 5.0);
     * // array is now {5.0, 15.0, 25.0}
     * </code></pre>
     *
     * @param a the array to be modified.
     * @param param the double value to subtract from each element.
     */
    public static void minus(final double[] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] -= param;
        }
    }

    /**
     * Subtracts a scalar value from each element of the specified 2D array in-place.
     * This method iterates through each sub-array and applies the subtraction.
     * If the array or its sub-arrays are null or empty, they are skipped.
     *
     * <pre><code>
     * double[][] matrix = {{10.0, 20.0}, {30.0, 40.0}};
     * Arrays37.minus(matrix, 10.0);
     * // matrix is now {{0.0, 10.0}, {20.0, 30.0}}
     * </code></pre>
     *
     * @param a the 2D array to be modified.
     * @param param the double value to subtract from each element.
     */
    public static void minus(final double[][] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[] element : a) {
            minus(element, param);
        }
    }

    /**
     * Subtracts a scalar value from each element of the specified 3D array in-place.
     * This method recursively calls the minus operation for each 2D sub-array.
     * If the array or its sub-arrays are null or empty, they are skipped.
     *
     * <pre><code>
     * double[][][] cube = {{{10.0}, {20.0}}, {{30.0}, {40.0}}};
     * Arrays37.minus(cube, 10.0);
     * // cube is now {{{0.0}, {10.0}}, {{20.0}, {30.0}}}
     * </code></pre>
     *
     * @param a the 3D array to be modified.
     * @param param the double value to subtract from each element.
     */
    public static void minus(final double[][][] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[][] element : a) {
            minus(element, param);
        }
    }

    /**
     * Multiplies each element of the specified array by a scalar value in-place.
     * If the array is null or empty, the method returns without any modification.
     *
     * <pre><code>
     * double[] array = {1.0, 2.0, 3.0};
     * Arrays37.multipliedBy(array, 3.0);
     * // array is now {3.0, 6.0, 9.0}
     * </code></pre>
     *
     * @param a the array to be modified.
     * @param param the double value to multiply each element by.
     */
    public static void multipliedBy(final double[] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] *= param;
        }
    }

    /**
     * Multiplies each element of the specified 2D array by a scalar value in-place.
     * This method iterates through each sub-array and applies the multiplication.
     * If the array or its sub-arrays are null or empty, they are skipped.
     *
     * <pre><code>
     * double[][] matrix = {{1.0, 2.0}, {3.0, 4.0}};
     * Arrays37.multipliedBy(matrix, 2.5);
     * // matrix is now {{2.5, 5.0}, {7.5, 10.0}}
     * </code></pre>
     *
     * @param a the 2D array to be modified.
     * @param param the double value to multiply each element by.
     */
    public static void multipliedBy(final double[][] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     * Multiplies each element of the specified 3D array by a scalar value in-place.
     * This method recursively calls the multiplication operation for each 2D sub-array.
     * If the array or its sub-arrays are null or empty, they are skipped.
     *
     * <pre><code>
     * double[][][] cube = {{{1.0}, {2.0}}, {{3.0}, {4.0}}};
     * Arrays37.multipliedBy(cube, 1.5);
     * // cube is now {{{1.5}, {3.0}}, {{4.5}, {6.0}}}
     * </code></pre>
     *
     * @param a the 3D array to be modified.
     * @param param the double value to multiply each element by.
     */
    public static void multipliedBy(final double[][][] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[][] element : a) {
            multipliedBy(element, param);
        }
    }

    /**
     * Divides each element of the specified array by a scalar value in-place.
     * If the array is null or empty, the method returns without any modification.
     *
     * <pre><code>
     * double[] array = {10.0, 20.0, 30.0};
     * Arrays37.dividedBy(array, 2.0);
     * // array is now {5.0, 10.0, 15.0}
     * </code></pre>
     *
     * @param a the array to be modified.
     * @param param the double value to divide each element by.
     */
    public static void dividedBy(final double[] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] /= param;
        }
    }

    /**
     * Divides each element of the specified 2D array by a scalar value in-place.
     * This method iterates through each sub-array and applies the division.
     * If the array or its sub-arrays are null or empty, they are skipped.
     *
     * <pre><code>
     * double[][] matrix = {{10.0, 20.0}, {30.0, 40.0}};
     * Arrays37.dividedBy(matrix, 10.0);
     * // matrix is now {{1.0, 2.0}, {3.0, 4.0}}
     * </code></pre>
     *
     * @param a the 2D array to be modified.
     * @param param the double value to divide each element by.
     */
    public static void dividedBy(final double[][] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     * Divides each element of the specified 3D array by a scalar value in-place.
     * This method recursively calls the division operation for each 2D sub-array.
     * If the array or its sub-arrays are null or empty, they are skipped.
     *
     * <pre><code>
     * double[][][] cube = {{{10.0}, {20.0}}, {{30.0}, {40.0}}};
     * Arrays37.dividedBy(cube, 2.0);
     * // cube is now {{{5.0}, {10.0}}, {{15.0}, {20.0}}}
     * </code></pre>
     *
     * @param a the 3D array to be modified.
     * @param param the double value to divide each element by.
     */
    public static void dividedBy(final double[][][] a, final double param) {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[][] element : a) {
            dividedBy(element, param);
        }
    }

    /**
     * Updates each element of the specified array in-place by applying a unary operator.
     *
     * <pre><code>
     * double[] array = {1.0, -2.0, 3.0};
     * Arrays37.updateAll(array, x -> Math.abs(x));
     * // array is now {1.0, 2.0, 3.0}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the operator.
     * @param a the array to be updated.
     * @param operator the unary operator to apply to each element.
     * @throws E if the operator throws an exception.
     */
    public static <E extends Exception> void updateAll(final double[] a, final Throwables.DoubleUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsDouble(a[i]);
        }
    }

    /**
     * Updates each element of the specified 2D array in-place by applying a unary operator.
     *
     * <pre><code>
     * double[][] matrix = {{1.0, 4.0}, {9.0, 16.0}};
     * Arrays37.updateAll(matrix, x -> Math.sqrt(x));
     * // matrix is now {{1.0, 2.0}, {3.0, 4.0}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the operator.
     * @param a the 2D array to be updated.
     * @param operator the unary operator to apply to each element.
     * @throws E if the operator throws an exception.
     */
    public static <E extends Exception> void updateAll(final double[][] a, final Throwables.DoubleUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Updates each element of the specified 3D array in-place by applying a unary operator.
     *
     * <pre><code>
     * double[][][] cube = {{{1.1}, {2.8}}, {{3.3}, {4.6}}};
     * Arrays37.updateAll(cube, x -> Math.round(x));
     * // cube is now {{{1.0}, {3.0}}, {{3.0}, {5.0}}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the operator.
     * @param a the 3D array to be updated.
     * @param operator the unary operator to apply to each element.
     * @throws E if the operator throws an exception.
     */
    public static <E extends Exception> void updateAll(final double[][][] a, final Throwables.DoubleUnaryOperator<E> operator) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[][] element : a) {
            updateAll(element, operator);
        }
    }

    /**
     * Replaces each element of the array with the specified new value if it satisfies the given predicate.
     *
     * <pre><code>
     * double[] array = {1.0, -2.0, 3.0, -4.0};
     * Arrays37.replaceIf(array, x -> x < 0, 0.0);
     * // array is now {1.0, 0.0, 3.0, 0.0}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the predicate.
     * @param a the array to be modified.
     * @param predicate a predicate to apply to each element to determine if it should be replaced.
     * @param newValue the value to be placed into the array.
     * @throws E if the predicate throws an exception.
     */
    public static <E extends Exception> void replaceIf(final double[] a, final Throwables.DoublePredicate<E> predicate, final double newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
            }
        }
    }

    /**
     * Replaces each element of the 2D array with the specified new value if it satisfies the given predicate.
     *
     * <pre><code>
     * double[][] matrix = {{1.0, -2.0}, {Double.NaN, 4.0}};
     * Arrays37.replaceIf(matrix, x -> Double.isNaN(x), 0.0);
     * // matrix is now {{1.0, -2.0}, {0.0, 4.0}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the predicate.
     * @param a the 2D array to be modified.
     * @param predicate a predicate to apply to each element to determine if it should be replaced.
     * @param newValue the value to be placed into the array.
     * @throws E if the predicate throws an exception.
     */
    public static <E extends Exception> void replaceIf(final double[][] a, final Throwables.DoublePredicate<E> predicate, final double newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Replaces each element of the 3D array with the specified new value if it satisfies the given predicate.
     *
     * <pre><code>
     * double[][][] cube = {{{1.0}, {Double.POSITIVE_INFINITY}}, {{3.0}, {-4.0}}};
     * Arrays37.replaceIf(cube, x -> !Double.isFinite(x), -1.0);
     * // cube is now {{{1.0}, {-1.0}}, {{3.0}, {-4.0}}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the predicate.
     * @param a the 3D array to be modified.
     * @param predicate a predicate to apply to each element to determine if it should be replaced.
     * @param newValue the value to be placed into the array.
     * @throws E if the predicate throws an exception.
     */
    public static <E extends Exception> void replaceIf(final double[][][] a, final Throwables.DoublePredicate<E> predicate, final double newValue) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        for (final double[][] element : a) {
            replaceIf(element, predicate, newValue);
        }
    }

    /**
     * Reshapes a 1D array into a 2D array with the specified number of columns.
     * The number of rows is determined by dividing the total number of elements by the number of columns.
     * The last row may be shorter if the total number of elements is not a multiple of {@code cols}.
     *
     * <pre><code>
     * double[] array = {1, 2, 3, 4, 5, 6, 7};
     * double[][] matrix = Arrays37.reshape(array, 3);
     * // matrix is now {{1, 2, 3}, {4, 5, 6}, {7}}
     * </code></pre>
     *
     * @param a the 1D array to reshape.
     * @param cols the number of columns in the new 2D array.
     * @return a new 2D array.
     * @throws IllegalArgumentException if {@code cols} is not positive.
     */
    public static double[][] reshape(final double[] a, final int cols) throws IllegalArgumentException {
        checkMForReshape(cols);

        if (N.isEmpty(a)) {
            return new double[0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, cols, RoundingMode.CEILING);
        final double[][] c = new double[n][];

        for (int i = 0, from = 0; i < n; i++, from += cols) {
            c[i] = N.copyOfRange(a, from, from + N.min(len - from, cols));
        }

        return c;
    }

    /**
     * Reshapes a 1D array into a 3D array with the specified number of rows and columns.
     * The dimensions of the resulting array are determined based on the total element count.
     * The last sub-arrays may be shorter if the total count is not a multiple of {@code rows * cols}.
     *
     * <pre><code>
     * double[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
     * double[][][] cube = Arrays37.reshape(array, 2, 3);
     * // cube is now {{{1, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10}}}
     * </code></pre>
     *
     * @param a the 1D array to reshape.
     * @param rows the number of rows in each 2D slice.
     * @param cols the number of columns in each 2D slice.
     * @return a new 3D array.
     * @throws IllegalArgumentException if {@code rows} or {@code cols} are not positive.
     */
    public static double[][][] reshape(final double[] a, final int rows, final int cols) throws IllegalArgumentException {
        checkMAndLForReshape(rows, cols);

        if (N.isEmpty(a)) {
            return new double[0][0][0];
        }

        final int len = a.length;
        final int n = Numbers.divide(len, rows * cols, RoundingMode.CEILING);
        final double[][][] c = new double[n][][];

        for (int i = 0, from = 0; i < n; i++) {
            c[i] = new double[N.min(rows, Numbers.divide(len - from, cols, RoundingMode.CEILING))][];

            for (int j = 0, y = c[i].length; j < y; j++, from += cols) {
                c[i][j] = N.copyOfRange(a, from, from + N.min(len - from, cols));
            }
        }

        return c;
    }

    /**
     * Flattens a 2D array into a 1D array by concatenating its rows.
     * Null or empty sub-arrays are skipped.
     *
     * <pre><code>
     * double[][] matrix = {{1.0, 2.0}, {3.0, 4.0}};
     * double[] array = Arrays37.flatten(matrix);
     * // array is now {1.0, 2.0, 3.0, 4.0}
     * </code></pre>
     *
     * @param a the 2D array to flatten.
     * @return a new 1D array containing all elements from the input array.
     */
    public static double[] flatten(final double[][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_DOUBLE_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final double[] c = new double[count];
        int from = 0;

        for (final double[] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            N.copy(element, 0, c, from, element.length);

            from += element.length;
        }

        return c;
    }

    /**
     * Flattens a 3D array into a 1D array by concatenating its elements in order.
     * Null or empty sub-arrays are skipped.
     *
     * <pre><code>
     * double[][][] cube = {{{1.0}, {2.0, 3.0}}, {{4.0}}};
     * double[] array = Arrays37.flatten(cube);
     * // array is now {1.0, 2.0, 3.0, 4.0}
     * </code></pre>
     *
     * @param a the 3D array to flatten.
     * @return a new 1D array containing all elements from the input array.
     */
    public static double[] flatten(final double[][][] a) {
        if (N.isEmpty(a)) {
            return N.EMPTY_DOUBLE_ARRAY;
        }

        final int count = Numbers.toIntExact(totalCountOfElements(a));

        final double[] c = new double[count];
        int from = 0;

        for (final double[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final double[] doubles : element) {
                if (N.isEmpty(doubles)) {
                    continue;
                }

                N.copy(doubles, 0, c, from, doubles.length);

                from += doubles.length;
            }
        }

        return c;
    }

    /**
     * Flattens a 2D array, performs an operation on the resulting 1D array,
     * and then copies the modified elements back into the original 2D array.
     * This allows for operations like sorting across the entire 2D array.
     * The modification happens in-place on the original 2D array.
     *
     * <pre><code>
     * double[][] matrix = {{5.0, 2.0}, {8.0, 1.0}};
     * Arrays37.flatOp(matrix, arr -> N.sort(arr));
     * // matrix is now {{1.0, 2.0}, {5.0, 8.0}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the operation.
     * @param a the 2D array to operate on.
     * @param op the operation to perform on the flattened array.
     * @throws E if the operation throws an exception.
     */
    public static <E extends Exception> void flatOp(final double[][] a, final Throwables.Consumer<? super double[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final double[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final double[] e : a) {
            if (N.notEmpty(e)) {
                N.copy(tmp, idx, e, 0, e.length);
                idx += e.length;
            }
        }
    }

    /**
     * Flattens a 3D array, performs an operation on the resulting 1D array,
     * and then copies the modified elements back into the original 3D array.
     * This allows for operations like sorting across the entire 3D array.
     * The modification happens in-place on the original 3D array.
     *
     * <pre><code>
     * double[][][] cube = {{{9.0, 2.0}}, {{5.0}, {1.0}}};
     * Arrays37.flatOp(cube, arr -> N.sort(arr));
     * // cube is now {{{1.0, 2.0}}, {{5.0}, {9.0}}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the operation.
     * @param a the 3D array to operate on.
     * @param op the operation to perform on the flattened array.
     * @throws E if the operation throws an exception.
     */
    public static <E extends Exception> void flatOp(final double[][][] a, final Throwables.Consumer<? super double[], E> op) throws E {
        if (N.isEmpty(a)) {
            return;
        }

        final double[] tmp = flatten(a);

        op.accept(tmp);

        int idx = 0;

        for (final double[][] e : a) {
            if (N.notEmpty(e)) {
                for (final double[] ee : e) {
                    if (N.notEmpty(ee)) {
                        N.copy(tmp, idx, ee, 0, ee.length);
                        idx += ee.length;
                    }
                }
            }
        }
    }

    /**
     * Adds two arrays element-wise. The resulting array will have a length
     * equal to the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {1, 2, 3};
     * double[] b = {4, 5, 6, 7};
     * double[] result = Arrays37.add(a, b);
     * // result is {5, 7, 9}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @return a new array containing the element-wise sum.
     */
    public static double[] add(final double[] a, final double[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] + b[i];
        }

        return result;
    }

    /**
     * Adds two arrays element-wise, providing default values for missing elements if the arrays
     * have different lengths. The resulting array will have a length equal to the maximum
     * of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {1, 2};
     * double[] b = {10, 20, 30};
     * double[] result = Arrays37.add(a, b, 0.0, 0.0);
     * // result is {11, 22, 30}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA the default value to use for elements missing from array {@code a}.
     * @param valueForNoneB the default value to use for elements missing from array {@code b}.
     * @return a new array containing the element-wise sum.
     */
    public static double[] add(final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return add(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper method to perform element-wise addition on two arrays up to a specified length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new array with the results.
     */
    private static double[] add(final int len, final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] + b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA + b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] + valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA + valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Adds three arrays element-wise. The resulting array will have a length
     * equal to the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {1, 2, 3};
     * double[] b = {4, 5, 6};
     * double[] c = {7, 8, 9};
     * double[] result = Arrays37.add(a, b, c);
     * // result is {12, 15, 18}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @return a new array containing the element-wise sum.
     */
    public static double[] add(final double[] a, final double[] b, final double[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] + b[i] + c[i];
        }

        return result;
    }

    /**
     * Adds three arrays element-wise, providing default values for missing elements if the arrays
     * have different lengths. The resulting array will have a length equal to the maximum
     * of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {1};
     * double[] b = {10, 20};
     * double[] c = {100, 200, 300};
     * double[] result = Arrays37.add(a, b, c, 0, 0, 0);
     * // result is {111, 220, 300}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA the default value to use for elements missing from array {@code a}.
     * @param valueForNoneB the default value to use for elements missing from array {@code b}.
     * @param valueForNoneC the default value to use for elements missing from array {@code c}.
     * @return a new array containing the element-wise sum.
     */
    public static double[] add(final double[] a, final double[] b, final double[] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return add(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper method to perform element-wise addition on three arrays up to a specified length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new array with the results.
     */
    private static double[] add(final int len, final double[] a, final double[] b, final double[] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] + b[i] + c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) + (i < lenB ? b[i] : valueForNoneB) + (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Adds two 2D arrays element-wise. The operation is applied row by row.
     * The resulting 2D array will have a number of rows equal to the minimum
     * of the input arrays. Each resulting row's length is the minimum of the
     * corresponding input rows.
     *
     * <pre><code>
     * double[][] a = {{1, 2}, {3, 4}};
     * double[][] b = {{5, 6}, {7, 8}};
     * double[][] result = Arrays37.add(a, b);
     * // result is {{6, 8}, {10, 12}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @return a new 2D array containing the element-wise sum.
     */
    public static double[][] add(final double[][] a, final double[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     * Adds two 2D arrays element-wise, providing default values for missing elements
     * in ragged or unequally sized arrays. The resulting array dimensions will be the
     * maximum of the input array dimensions.
     *
     * <pre><code>
     * double[][] a = {{1}, {2, 3}};
     * double[][] b = {{10, 20}, {30}};
     * double[][] result = Arrays37.add(a, b, 0, 0);
     * // result is {{11, 20}, {32, 3}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA the default value for elements missing from array {@code a}.
     * @param valueForNoneB the default value for elements missing from array {@code b}.
     * @return a new 2D array containing the element-wise sum.
     */
    public static double[][] add(final double[][] a, final double[][] b, final double valueForNoneA, final double valueForNoneB) {
        return add(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper for adding two 2D arrays with default values.
     *
     * @param len number of rows in the result.
     * @param rowLen max number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new 2D array.
     */
    private static double[][] add(final int len, final int rowLen, final double[][] a, final double[][] b, final double valueForNoneA,
            final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = add(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = add(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = add(rowLen, null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Adds three 2D arrays element-wise. The operation is applied row by row.
     * The resulting 2D array will have a number of rows equal to the minimum
     * of the input arrays. Each resulting row's length is the minimum of the
     * corresponding input rows.
     *
     * <pre><code>
     * double[][] a = {{1, 1}, {1, 1}};
     * double[][] b = {{2, 2}, {2, 2}};
     * double[][] c = {{3, 3}, {3, 3}};
     * double[][] result = Arrays37.add(a, b, c);
     * // result is {{6, 6}, {6, 6}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @return a new 2D array containing the element-wise sum.
     */
    public static double[][] add(final double[][] a, final double[][] b, final double[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Adds three 2D arrays element-wise, providing default values for missing elements.
     * The resulting array dimensions will be the maximum of the input array dimensions.
     *
     * <pre><code>
     * double[][] a = {{1}};
     * double[][] b = {{10, 20}};
     * double[][] c = {{100, 200}, {300}};
     * double[][] result = Arrays37.add(a, b, c, 0, 0, 0);
     * // result is {{111, 220}, {300}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA the default value for elements missing from array {@code a}.
     * @param valueForNoneB the default value for elements missing from array {@code b}.
     * @param valueForNoneC the default value for elements missing from array {@code c}.
     * @return a new 2D array containing the element-wise sum.
     */
    public static double[][] add(final double[][] a, final double[][] b, final double[][] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC) {
        return add(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC);
    }

    /**
     * Private helper for adding three 2D arrays with default values.
     *
     * @param len number of rows in the result.
     * @param rowLen max number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new 2D array.
     */
    private static double[][] add(final int len, final int rowLen, final double[][] a, final double[][] b, final double[][] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = add(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = add(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Adds two 3D arrays element-wise. The operation is applied recursively.
     * The resulting 3D array's dimensions are truncated to the minimum of the
     * corresponding dimensions of the input arrays.
     *
     * <pre><code>
     * double[][][] a = {{{1}}};
     * double[][][] b = {{{2}}};
     * double[][][] result = Arrays37.add(a, b);
     * // result is {{{3}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @return a new 3D array containing the element-wise sum.
     */
    public static double[][][] add(final double[][][] a, final double[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i]);
        }

        return result;
    }

    /**
     * Adds two 3D arrays element-wise, providing default values for missing elements.
     * The resulting array dimensions will be the maximum of the input array dimensions.
     *
     * <pre><code>
     * double[][][] a = {{{1}, {2}}};
     * double[][][] b = {{{10}}, {{30}}};
     * double[][][] result = Arrays37.add(a, b, 0, 0);
     * // result is {{{11}, {2}}, {{30}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param valueForNoneA the default value for elements missing from array {@code a}.
     * @param valueForNoneB the default value for elements missing from array {@code b}.
     * @return a new 3D array containing the element-wise sum.
     */
    public static double[][][] add(final double[][][] a, final double[][][] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = add(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = add(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = add(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Adds three 3D arrays element-wise. The operation is applied recursively.
     * The resulting 3D array's dimensions are truncated to the minimum of the
     * corresponding dimensions of the input arrays.
     *
     * <pre><code>
     * double[][][] a = {{{1}}};
     * double[][][] b = {{{2}}};
     * double[][][] c = {{{3}}};
     * double[][][] result = Arrays37.add(a, b, c);
     * // result is {{{6}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @return a new 3D array containing the element-wise sum.
     */
    public static double[][][] add(final double[][][] a, final double[][][] b, final double[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = add(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Adds three 3D arrays element-wise, providing default values for missing elements.
     * The resulting array dimensions will be the maximum of the input array dimensions.
     *
     * <pre><code>
     * double[][][] a = {{{1}}};
     * double[][][] b = {{{10}}, {{20}}};
     * double[][][] c = {{{100}}, {{200}}, {{300}}};
     * double[][][] result = Arrays37.add(a, b, c, 0, 0, 0);
     * // result is {{{111}}, {{220}}, {{300}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @param valueForNoneA the default value for elements missing from array {@code a}.
     * @param valueForNoneB the default value for elements missing from array {@code b}.
     * @param valueForNoneC the default value for elements missing from array {@code c}.
     * @return a new 3D array containing the element-wise sum.
     */
    public static double[][][] add(final double[][][] a, final double[][][] b, final double[][][] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = add(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = add(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Subtracts the second array from the first, element-wise. The resulting array will have a length
     * equal to the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {10, 20, 30};
     * double[] b = {1, 2, 3, 4};
     * double[] result = Arrays37.subtract(a, b);
     * // result is {9, 18, 27}
     * </code></pre>
     *
     * @param a the array to subtract from (minuend).
     * @param b the array to subtract (subtrahend).
     * @return a new array containing the element-wise difference.
     */
    public static double[] subtract(final double[] a, final double[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] - b[i];
        }

        return result;
    }

    /**
     * Subtracts two arrays element-wise, providing default values for missing elements if the arrays
     * have different lengths. The resulting array will have a length equal to the maximum
     * of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {100, 200};
     * double[] b = {10, 20, 30};
     * double[] result = Arrays37.subtract(a, b, 0, 0);
     * // result is {90, 180, -30}
     * </code></pre>
     *
     * @param a the minuend array.
     * @param b the subtrahend array.
     * @param valueForNoneA the default value to use for elements missing from array {@code a}.
     * @param valueForNoneB the default value to use for elements missing from array {@code b}.
     * @return a new array containing the element-wise difference.
     */
    public static double[] subtract(final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return subtract(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper method to perform element-wise subtraction on two arrays up to a specified length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new array with the results.
     */
    private static double[] subtract(final int len, final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] - b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA - b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] - valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA - valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Subtracts the second and third arrays from the first, element-wise. The resulting
     * array will have a length equal to the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {100, 200, 300};
     * double[] b = {10, 20, 30};
     * double[] c = {1, 2, 3};
     * double[] result = Arrays37.subtract(a, b, c);
     * // result is {89, 178, 267}
     * </code></pre>
     *
     * @param a the array to subtract from (minuend).
     * @param b the second array to subtract (subtrahend).
     * @param c the third array to subtract (subtrahend).
     * @return a new array containing the element-wise difference.
     */
    public static double[] subtract(final double[] a, final double[] b, final double[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] - b[i] - c[i];
        }

        return result;
    }

    /**
     * Subtracts two arrays from a third element-wise, providing default values for missing elements
     * if the arrays have different lengths. The resulting array will have a length equal to the maximum
     * of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {100};
     * double[] b = {10, 20};
     * double[] c = {1, 2, 3};
     * double[] result = Arrays37.subtract(a, b, c, 0, 0, 0);
     * // result is {89, -22, -3}
     * </code></pre>
     *
     * @param a the minuend array.
     * @param b the second subtrahend array.
     * @param c the third subtrahend array.
     * @param valueForNoneA the default value to use for elements missing from array {@code a}.
     * @param valueForNoneB the default value to use for elements missing from array {@code b}.
     * @param valueForNoneC the default value to use for elements missing from array {@code c}.
     * @return a new array containing the element-wise difference.
     */
    public static double[] subtract(final double[] a, final double[] b, final double[] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return subtract(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper method to perform element-wise subtraction on three arrays up to a specified length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new array with the results.
     */
    private static double[] subtract(final int len, final double[] a, final double[] b, final double[] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] - b[i] - c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) - (i < lenB ? b[i] : valueForNoneB) - (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Subtracts the second 2D array from the first, element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{10, 20}, {30, 40}};
     * double[][] b = {{1, 2}, {3, 4}};
     * double[][] result = Arrays37.subtract(a, b);
     * // result is {{9, 18}, {27, 36}}
     * </code></pre>
     *
     * @param a the minuend 2D array.
     * @param b the subtrahend 2D array.
     * @return a new 2D array containing the element-wise difference.
     */
    public static double[][] subtract(final double[][] a, final double[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     * Subtracts two 2D arrays element-wise, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{100}, {200, 300}};
     * double[][] b = {{10, 20}, {30}};
     * double[][] result = Arrays37.subtract(a, b, 0, 0);
     * // result is {{90, -20}, {170, 300}}
     * </code></pre>
     *
     * @param a the minuend 2D array.
     * @param b the subtrahend 2D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @return a new 2D array with the results.
     */
    public static double[][] subtract(final double[][] a, final double[][] b, final double valueForNoneA, final double valueForNoneB) {
        return subtract(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper for subtracting two 2D arrays with default values.
     *
     * @param len number of rows in the result.
     * @param rowLen max number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new 2D array.
     */
    private static double[][] subtract(final int len, final int rowLen, final double[][] a, final double[][] b, final double valueForNoneA,
            final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = subtract(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = subtract(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = subtract(rowLen, null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Subtracts the second and third 2D arrays from the first, element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{10, 10}, {10, 10}};
     * double[][] b = {{1, 1}, {1, 1}};
     * double[][] c = {{2, 2}, {2, 2}};
     * double[][] result = Arrays37.subtract(a, b, c);
     * // result is {{7, 7}, {7, 7}}
     * </code></pre>
     *
     * @param a the minuend 2D array.
     * @param b the second subtrahend 2D array.
     * @param c the third subtrahend 2D array.
     * @return a new 2D array containing the element-wise difference.
     */
    public static double[][] subtract(final double[][] a, final double[][] b, final double[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Subtracts two 2D arrays from a third element-wise, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{100}};
     * double[][] b = {{10}, {20}};
     * double[][] c = {{1, 2}, {3, 4}};
     * double[][] result = Arrays37.subtract(a, b, c, 0, 0, 0);
     * // result is {{89, -2}, {-23, -4}}
     * </code></pre>
     *
     * @param a the minuend 2D array.
     * @param b the second subtrahend 2D array.
     * @param c the third subtrahend 2D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @param valueForNoneC default value for elements missing from {@code c}.
     * @return a new 2D array with the results.
     */
    public static double[][] subtract(final double[][] a, final double[][] b, final double[][] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC) {
        return subtract(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper for subtracting three 2D arrays with default values.
     *
     * @param len number of rows in the result.
     * @param rowLen max number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new 2D array.
     */
    private static double[][] subtract(final int len, final int rowLen, final double[][] a, final double[][] b, final double[][] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = subtract(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = subtract(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Subtracts the second 3D array from the first, element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{10}}};
     * double[][][] b = {{{3}}};
     * double[][][] result = Arrays37.subtract(a, b);
     * // result is {{{7}}}
     * </code></pre>
     *
     * @param a the minuend 3D array.
     * @param b the subtrahend 3D array.
     * @return a new 3D array containing the element-wise difference.
     */
    public static double[][][] subtract(final double[][][] a, final double[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i]);
        }

        return result;
    }

    /**
     * Subtracts two 3D arrays element-wise, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{100}}, {{200}}};
     * double[][][] b = {{{10, 20}}};
     * double[][][] result = Arrays37.subtract(a, b, 0.0, 0.0);
     * // result is {{{90.0, -20.0}}}, {{{200.0}}}
     * </code></pre>
     *
     * @param a the minuend 3D array.
     * @param b the subtrahend 3D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @return a new 3D array with the results.
     */
    public static double[][][] subtract(final double[][][] a, final double[][][] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = subtract(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = subtract(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = subtract(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Subtracts the second and third 3D arrays from the first, element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{10}}};
     * double[][][] b = {{{3}}};
     * double[][][] c = {{{1}}};
     * double[][][] result = Arrays37.subtract(a, b, c);
     * // result is {{{6}}}
     * </code></pre>
     *
     * @param a the minuend 3D array.
     * @param b the second subtrahend 3D array.
     * @param c the third subtrahend 3D array.
     * @return a new 3D array containing the element-wise difference.
     */
    public static double[][][] subtract(final double[][][] a, final double[][][] b, final double[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = subtract(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Subtracts two 3D arrays from a third element-wise, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{100}}};
     * double[][][] b = {{{10}}, {{20}}};
     * double[][][] c = {{{1}}, {{2}}, {{3}}};
     * double[][][] result = Arrays37.subtract(a, b, c, 0, 0, 0);
     * // result is {{{89}}, {{-22}}, {{-3}}}
     * </code></pre>
     *
     * @param a the minuend 3D array.
     * @param b the second subtrahend 3D array.
     * @param c the third subtrahend 3D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @param valueForNoneC default value for elements missing from {@code c}.
     * @return a new 3D array with the results.
     */
    public static double[][][] subtract(final double[][][] a, final double[][][] b, final double[][][] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = subtract(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = subtract(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Multiplies two arrays element-wise. The resulting array will have a length
     * equal to the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {1, 2, 3};
     * double[] b = {4, 5, 6, 7};
     * double[] result = Arrays37.multipliedBy(a, b);
     * // result is {4, 10, 18}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @return a new array containing the element-wise product.
     */
    public static double[] multipliedBy(final double[] a, final double[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] * b[i];
        }

        return result;
    }

    /**
     * Multiplies two arrays element-wise, providing default values for missing elements if the arrays
     * have different lengths. The resulting array will have a length equal to the maximum
     * of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {1, 2};
     * double[] b = {10, 20, 30};
     * double[] result = Arrays37.multipliedBy(a, b, 1, 1);
     * // result is {10, 40, 30}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA the default value to use for elements missing from array {@code a}.
     * @param valueForNoneB the default value to use for elements missing from array {@code b}.
     * @return a new array containing the element-wise product.
     */
    public static double[] multipliedBy(final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return multipliedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper method to perform element-wise multiplication on two arrays up to a specified length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new array with the results.
     */
    private static double[] multipliedBy(final int len, final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] * b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA * b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] * valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA * valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Multiplies three arrays element-wise. The resulting array will have a length
     * equal to the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {1, 2, 3};
     * double[] b = {4, 5, 6};
     * double[] c = {1, 2, 1};
     * double[] result = Arrays37.multipliedBy(a, b, c);
     * // result is {4, 20, 18}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @return a new array containing the element-wise product.
     */
    public static double[] multipliedBy(final double[] a, final double[] b, final double[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] * b[i] * c[i];
        }

        return result;
    }

    /**
     * Multiplies three arrays element-wise, providing default values for missing elements if the arrays
     * have different lengths. The resulting array will have a length equal to the maximum
     * of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {1};
     * double[] b = {10, 20};
     * double[] c = {1, 2, 3};
     * double[] result = Arrays37.multipliedBy(a, b, c, 1, 1, 1);
     * // result is {10, 40, 3}
     * </code></pre>
     *
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA the default value to use for elements missing from array {@code a}.
     * @param valueForNoneB the default value to use for elements missing from array {@code b}.
     * @param valueForNoneC the default value to use for elements missing from array {@code c}.
     * @return a new array containing the element-wise product.
     */
    public static double[] multipliedBy(final double[] a, final double[] b, final double[] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return multipliedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper method to perform element-wise multiplication on three arrays up to a specified length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new array with the results.
     */
    private static double[] multipliedBy(final int len, final double[] a, final double[] b, final double[] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] * b[i] * c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) * (i < lenB ? b[i] : valueForNoneB) * (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Multiplies two 2D arrays element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{1, 2}, {3, 4}};
     * double[][] b = {{5, 6}, {7, 8}};
     * double[][] result = Arrays37.multipliedBy(a, b);
     * // result is {{5, 12}, {21, 32}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @return a new 2D array containing the element-wise product.
     */
    public static double[][] multipliedBy(final double[][] a, final double[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Multiplies two 2D arrays element-wise, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{2}, {3, 4}};
     * double[][] b = {{10, 20}, {30}};
     * double[][] result = Arrays37.multipliedBy(a, b, 1, 1);
     * // result is {{20, 20}, {90, 4}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @return a new 2D array with the results.
     */
    public static double[][] multipliedBy(final double[][] a, final double[][] b, final double valueForNoneA, final double valueForNoneB) {
        return multipliedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper for multiplying two 2D arrays with default values.
     *
     * @param len number of rows in the result.
     * @param rowLen max number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new 2D array.
     */
    private static double[][] multipliedBy(final int len, final int rowLen, final double[][] a, final double[][] b, final double valueForNoneA,
            final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = multipliedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = multipliedBy(rowLen, null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Multiplies three 2D arrays element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{1, 1}, {1, 1}};
     * double[][] b = {{2, 2}, {2, 2}};
     * double[][] c = {{3, 4}, {5, 6}};
     * double[][] result = Arrays37.multipliedBy(a, b, c);
     * // result is {{6, 8}, {10, 12}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @return a new 2D array containing the element-wise product.
     */
    public static double[][] multipliedBy(final double[][] a, final double[][] b, final double[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Multiplies three 2D arrays element-wise, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{2}};
     * double[][] b = {{3}, {4}};
     * double[][] c = {{5, 6}, {7, 8}};
     * double[][] result = Arrays37.multipliedBy(a, b, c, 1, 1, 1);
     * // result is {{30, 6}, {28, 8}}
     * </code></pre>
     *
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @param valueForNoneC default value for elements missing from {@code c}.
     * @return a new 2D array with the results.
     */
    public static double[][] multipliedBy(final double[][] a, final double[][] b, final double[][] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC) {
        return multipliedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper for multiplying three 2D arrays with default values.
     *
     * @param len number of rows in the result.
     * @param rowLen max number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new 2D array.
     */
    private static double[][] multipliedBy(final int len, final int rowLen, final double[][] a, final double[][] b, final double[][] c,
            final double valueForNoneA, final double valueForNoneB, final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = multipliedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = multipliedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Multiplies two 3D arrays element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{2}}};
     * double[][][] b = {{{3}}};
     * double[][][] result = Arrays37.multipliedBy(a, b);
     * // result is {{{6}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @return a new 3D array containing the element-wise product.
     */
    public static double[][][] multipliedBy(final double[][][] a, final double[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Multiplies two 3D arrays element-wise, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{2}}, {{3}}};
     * double[][][] b = {{{10, 20}}};
     * double[][][] result = Arrays37.multipliedBy(a, b, 1.0, 1.0);
     * // result is {{{20.0, 20.0}}}, {{{3.0}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @return a new 3D array with the results.
     */
    public static double[][][] multipliedBy(final double[][][] a, final double[][][] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = multipliedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = multipliedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Multiplies three 3D arrays element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{2}}};
     * double[][][] b = {{{3}}};
     * double[][][] c = {{{4}}};
     * double[][][] result = Arrays37.multipliedBy(a, b, c);
     * // result is {{{24}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @return a new 3D array containing the element-wise product.
     */
    public static double[][][] multipliedBy(final double[][][] a, final double[][][] b, final double[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Multiplies three 3D arrays element-wise, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{2}}};
     * double[][][] b = {{{3}}, {{4}}};
     * double[][][] c = {{{5}}, {{6}}, {{7}}};
     * double[][][] result = Arrays37.multipliedBy(a, b, c, 1, 1, 1);
     * // result is {{{30}}, {{24}}, {{7}}}
     * </code></pre>
     *
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @param valueForNoneC default value for elements missing from {@code c}.
     * @return a new 3D array with the results.
     */
    public static double[][][] multipliedBy(final double[][][] a, final double[][][] b, final double[][][] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = multipliedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = multipliedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Divides the first array by the second, element-wise. The resulting array will have a length
     * equal to the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {10, 20, 30};
     * double[] b = {2, 5, 6, 7};
     * double[] result = Arrays37.dividedBy(a, b);
     * // result is {5, 4, 5}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the divisor array.
     * @return a new array containing the element-wise quotient.
     */
    public static double[] dividedBy(final double[] a, final double[] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / b[i];
        }

        return result;
    }

    /**
     * Divides two arrays element-wise, providing default values for missing elements if the arrays
     * have different lengths. The resulting array will have a length equal to the maximum
     * of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {100, 200};
     * double[] b = {10, 20, 30};
     * double[] result = Arrays37.dividedBy(a, b, 1.0, 1.0);
     * // result is {10.0, 10.0, 1.0/30.0}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the divisor array.
     * @param valueForNoneA the default value to use for elements missing from array {@code a}.
     * @param valueForNoneB the default value to use for elements missing from array {@code b}.
     * @return a new array containing the element-wise quotient.
     */
    public static double[] dividedBy(final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper method to perform element-wise division on two arrays up to a specified length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new array with the results.
     */
    private static double[] dividedBy(final int len, final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] / b[i];
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA / b[i];
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] / valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA / valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Divides the first array by the second and then by the third, element-wise. The resulting
     * array will have a length equal to the minimum of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {100, 200, 300};
     * double[] b = {10, 20, 30};
     * double[] c = {2, 5, 1};
     * double[] result = Arrays37.dividedBy(a, b, c);
     * // result is {5, 2, 10}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the second array (divisor).
     * @param c the third array (divisor).
     * @return a new array containing the element-wise quotient.
     */
    public static double[] dividedBy(final double[] a, final double[] b, final double[] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / b[i] / c[i];
        }

        return result;
    }

    /**
     * Divides the first array by the second and third arrays element-wise, providing default
     * values for missing elements. The resulting array will have a length equal to the maximum
     * of the lengths of the input arrays.
     *
     * <pre><code>
     * double[] a = {100};
     * double[] b = {10, 20};
     * double[] c = {1, 2, 3};
     * double[] result = Arrays37.dividedBy(a, b, c, 1.0, 1.0, 1.0);
     * // result is {10.0, 1.0/20.0/2.0, 1.0/1.0/3.0}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the second divisor array.
     * @param c the third divisor array.
     * @param valueForNoneA the default value for elements missing from array {@code a}.
     * @param valueForNoneB the default value for elements missing from array {@code b}.
     * @param valueForNoneC the default value for elements missing from array {@code c}.
     * @return a new array containing the element-wise quotient.
     */
    public static double[] dividedBy(final double[] a, final double[] b, final double[] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper method to perform element-wise division on three arrays up to a specified length.
     *
     * @param len the length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new array with the results.
     */
    private static double[] dividedBy(final int len, final double[] a, final double[] b, final double[] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] / b[i] / c[i];
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) / (i < lenB ? b[i] : valueForNoneB) / (i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Divides the first 2D array by the second, element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{10, 20}, {30, 40}};
     * double[][] b = {{2, 5}, {3, 8}};
     * double[][] result = Arrays37.dividedBy(a, b);
     * // result is {{5, 4}, {10, 5}}
     * </code></pre>
     *
     * @param a the dividend 2D array.
     * @param b the divisor 2D array.
     * @return a new 2D array containing the element-wise quotient.
     */
    public static double[][] dividedBy(final double[][] a, final double[][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Divides two 2D arrays element-wise, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{100}, {200, 300}};
     * double[][] b = {{10, 20}, {40}};
     * double[][] result = Arrays37.dividedBy(a, b, 1, 1);
     * // result is {{10.0, 1.0/20.0}, {5.0, 300.0/1.0}}
     * </code></pre>
     *
     * @param a the dividend 2D array.
     * @param b the divisor 2D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @return a new 2D array with the results.
     */
    public static double[][] dividedBy(final double[][] a, final double[][] b, final double valueForNoneA, final double valueForNoneB) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB);
    }

    /**
     * Private helper for dividing two 2D arrays with default values.
     *
     * @param len number of rows in the result.
     * @param rowLen max number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @return a new 2D array.
     */
    private static double[][] dividedBy(final int len, final int rowLen, final double[][] a, final double[][] b, final double valueForNoneA,
            final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, null, null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Divides the first 2D array by the second and then by the third, element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{100, 100}, {100, 100}};
     * double[][] b = {{10, 5}, {2, 1}};
     * double[][] c = {{2, 5}, {2, 10}};
     * double[][] result = Arrays37.dividedBy(a, b, c);
     * // result is {{5, 4}, {25, 10}}
     * </code></pre>
     *
     * @param a the dividend 2D array.
     * @param b the second divisor 2D array.
     * @param c the third divisor 2D array.
     * @return a new 2D array containing the element-wise quotient.
     */
    public static double[][] dividedBy(final double[][] a, final double[][] b, final double[][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Divides the first 2D array by the second and third, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{100}};
     * double[][] b = {{10}, {5}};
     * double[][] c = {{2, 1}, {1, 1}};
     * double[][] result = Arrays37.dividedBy(a, b, c, 1, 1, 1);
     * // result is {{5, 1}, {1/5, 1}}
     * </code></pre>
     *
     * @param a the dividend 2D array.
     * @param b the second divisor 2D array.
     * @param c the third divisor 2D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @param valueForNoneC default value for elements missing from {@code c}.
     * @return a new 2D array with the results.
     */
    public static double[][] dividedBy(final double[][] a, final double[][] b, final double[][] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC);
    }

    /**
     * Private helper for dividing three 2D arrays with default values.
     *
     * @param len number of rows in the result.
     * @param rowLen max number of columns in the result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default value for a.
     * @param valueForNoneB default value for b.
     * @param valueForNoneC default value for c.
     * @return a new 2D array.
     */
    private static double[][] dividedBy(final int len, final int rowLen, final double[][] a, final double[][] b, final double[][] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Divides the first 3D array by the second, element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{10}}};
     * double[][][] b = {{{2}}};
     * double[][][] result = Arrays37.dividedBy(a, b);
     * // result is {{{5}}}
     * </code></pre>
     *
     * @param a the dividend 3D array.
     * @param b the divisor 3D array.
     * @return a new 3D array containing the element-wise quotient.
     */
    public static double[][][] dividedBy(final double[][][] a, final double[][][] b) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i]);
        }

        return result;
    }

    /**
     * Divides two 3D arrays element-wise, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{100}}, {{200}}};
     * double[][][] b = {{{10, 2}}};
     * double[][][] result = Arrays37.dividedBy(a, b, 1.0, 1.0);
     * // result is {{{10.0, 0.5}}}, {{{200.0}}}
     * </code></pre>
     *
     * @param a the dividend 3D array.
     * @param b the divisor 3D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @return a new 3D array with the results.
     */
    public static double[][][] dividedBy(final double[][][] a, final double[][][] b, final double valueForNoneA, final double valueForNoneB) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Divides the first 3D array by the second and then by the third, element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{100}}};
     * double[][][] b = {{{10}}};
     * double[][][] c = {{{2}}};
     * double[][][] result = Arrays37.dividedBy(a, b, c);
     * // result is {{{5}}}
     * </code></pre>
     *
     * @param a the dividend 3D array.
     * @param b the second divisor 3D array.
     * @param c the third divisor 3D array.
     * @return a new 3D array containing the element-wise quotient.
     */
    public static double[][][] dividedBy(final double[][][] a, final double[][][] b, final double[][][] c) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Divides the first 3D array by the second and third, with default values for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{100}}};
     * double[][][] b = {{{10}}, {{5}}};
     * double[][][] c = {{{2}}, {{1}}, {{4}}};
     * double[][][] result = Arrays37.dividedBy(a, b, c, 1, 1, 1);
     * // result is {{{5}}, {{0.2}}, {{0.25}}}
     * </code></pre>
     *
     * @param a the dividend 3D array.
     * @param b the second divisor 3D array.
     * @param c the third divisor 3D array.
     * @param valueForNoneA default value for elements missing from {@code a}.
     * @param valueForNoneB default value for elements missing from {@code b}.
     * @param valueForNoneC default value for elements missing from {@code c}.
     * @return a new 3D array with the results.
     */
    public static double[][][] dividedBy(final double[][][] a, final double[][][] b, final double[][][] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC);
        }

        return result;
    }

    /**
     * Divides the first array by the second, element-wise, using a default value for the divisor
     * when an element in the divisor array is zero. The length of the result is the minimum
     * of the input array lengths.
     *
     * <pre><code>
     * double[] a = {10, 20, 30};
     * double[] b = {2, 0, 3};
     * double[] result = Arrays37.dividedBy(a, b, 1.0);
     * // result is {5, 20, 10}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the divisor array.
     * @param defaultValueForZero the value to use as the divisor when an element in {@code b} is 0.
     * @return a new array containing the element-wise quotient.
     */
    public static double[] dividedBy(final double[] a, final double[] b, final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]);
        }

        return result;
    }

    /**
     * Divides two arrays element-wise, handling missing elements and division by zero.
     * The length of the result is the maximum of the input array lengths.
     *
     * <pre><code>
     * double[] a = {100, 200};
     * double[] b = {10, 0, 30};
     * double[] result = Arrays37.dividedBy(a, b, 1.0, 1.0, 1.0);
     * // result is {10.0, 200.0, 1.0/30.0}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the divisor array.
     * @param valueForNoneA the default value for elements missing from array {@code a}.
     * @param valueForNoneB the default value for elements missing from array {@code b}.
     * @param defaultValueForZero the value to use as the divisor when an element in {@code b} is 0.
     * @return a new array containing the element-wise quotient.
     */
    public static double[] dividedBy(final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB,
            final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return dividedBy(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     * Private helper for dividing two arrays with default values and zero handling.
     *
     * @param len length of the result array.
     * @param a the dividend array.
     * @param b the divisor array.
     * @param valueForNoneA default for missing elements in a.
     * @param valueForNoneB default for missing elements in b.
     * @param defaultValueForZero default for division by zero.
     * @return a new array with the results.
     */
    private static double[] dividedBy(final int len, final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB,
            final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = valueForNoneA / (b[i] == 0 ? defaultValueForZero : b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = a[i] / valueForNoneB;
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = valueForNoneA / valueForNoneB;
            }
        }

        return result;
    }

    /**
     * Divides the first array by the second and third, element-wise, handling division by zero.
     * The length of the result is the minimum of the input array lengths.
     *
     * <pre><code>
     * double[] a = {100, 200, 300};
     * double[] b = {10, 0, 30};
     * double[] c = {2, 5, 0};
     * double[] result = Arrays37.dividedBy(a, b, c, 1.0);
     * // result is {5.0, 40.0, 10.0}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the second array (divisor).
     * @param c the third array (divisor).
     * @param defaultValueForZero the value to use as the divisor when an element in {@code b} or {@code c} is 0.
     * @return a new array containing the element-wise quotient.
     */
    public static double[] dividedBy(final double[] a, final double[] b, final double[] c, final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]);
        }

        return result;
    }

    /**
     * Divides the first array by the second and third, handling missing elements and division by zero.
     * The length of the result is the maximum of the input array lengths.
     *
     * <pre><code>
     * double[] a = {100};
     * double[] b = {10, 0};
     * double[] c = {2, 5, 3};
     * double[] result = Arrays37.dividedBy(a, b, c, 1, 1, 1, 1);
     * // result is {5.0, 1.0/1.0/5.0, 1.0/1.0/3.0}
     * </code></pre>
     *
     * @param a the dividend array.
     * @param b the second divisor array.
     * @param c the third divisor array.
     * @param valueForNoneA default value for missing elements in a.
     * @param valueForNoneB default value for missing elements in b.
     * @param valueForNoneC default value for missing elements in c.
     * @param defaultValueForZero default value for division by zero.
     * @return a new array containing the element-wise quotient.
     */
    public static double[] dividedBy(final double[] a, final double[] b, final double[] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC, final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return dividedBy(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     * Private helper for dividing three arrays with defaults and zero handling.
     *
     * @param len length of result array.
     * @param a dividend array.
     * @param b first divisor.
     * @param c second divisor.
     * @param valueForNoneA default for a.
     * @param valueForNoneB default for b.
     * @param valueForNoneC default for c.
     * @param defaultValueForZero default for division by zero.
     * @return a new array.
     */
    private static double[] dividedBy(final int len, final double[] a, final double[] b, final double[] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC, final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = a[i] / (b[i] == 0 ? defaultValueForZero : b[i]) / (c[i] == 0 ? defaultValueForZero : c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = (i < lenA ? a[i] : valueForNoneA) / (i < lenB ? (b[i] == 0 ? defaultValueForZero : b[i]) : valueForNoneB)
                        / (i < lenC ? (c[i] == 0 ? defaultValueForZero : c[i]) : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Divides a 2D array by another, element-wise, handling division by zero.
     * The dimensions are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{10, 20}, {30, 40}};
     * double[][] b = {{2, 0}, {3, 8}};
     * double[][] result = Arrays37.dividedBy(a, b, 1.0);
     * // result is {{5, 20}, {10, 5}}
     * </code></pre>
     *
     * @param a the dividend 2D array.
     * @param b the divisor 2D array.
     * @param defaultValueForZero the value to use as the divisor when an element in {@code b} is 0.
     * @return a new 2D array with the results.
     */
    public static double[][] dividedBy(final double[][] a, final double[][] b, final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Divides two 2D arrays element-wise, handling missing elements and division by zero.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{100}, {200, 300}};
     * double[][] b = {{10, 0}, {40}};
     * double[][] result = Arrays37.dividedBy(a, b, 1, 1, 1);
     * // result is {{10, 1}, {5, 300}}
     * </code></pre>
     *
     * @param a the dividend 2D array.
     * @param b the divisor 2D array.
     * @param valueForNoneA default value for missing elements in a.
     * @param valueForNoneB default value for missing elements in b.
     * @param defaultValueForZero default value for division by zero.
     * @return a new 2D array with the results.
     */
    public static double[][] dividedBy(final double[][] a, final double[][] b, final double valueForNoneA, final double valueForNoneB,
            final double defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, defaultValueForZero);
    }

    /**
     * Private helper for dividing two 2D arrays with defaults and zero handling.
     *
     * @param len number of rows in result.
     * @param rowLen max number of columns in result.
     * @param a dividend array.
     * @param b divisor array.
     * @param valueForNoneA default for a.
     * @param valueForNoneB default for b.
     * @param defaultValueForZero default for division by zero.
     * @return a new 2D array.
     */
    private static double[][] dividedBy(final int len, final int rowLen, final double[][] a, final double[][] b, final double valueForNoneA,
            final double valueForNoneB, final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = dividedBy(rowLen, null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = dividedBy(rowLen, a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = dividedBy(rowLen, null, null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Divides the first 2D array by the second and third, handling division by zero.
     * The dimensions are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{100, 100}};
     * double[][] b = {{10, 0}};
     * double[][] c = {{2, 5}};
     * double[][] result = Arrays37.dividedBy(a, b, c, 1.0);
     * // result is {{5, 20}}
     * </code></pre>
     *
     * @param a the dividend 2D array.
     * @param b the second divisor 2D array.
     * @param c the third divisor 2D array.
     * @param defaultValueForZero default value for division by zero.
     * @return a new 2D array with the results.
     */
    public static double[][] dividedBy(final double[][] a, final double[][] b, final double[][] c, final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Divides the first 2D array by the second and third, handling missing elements and division by zero.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{100}};
     * double[][] b = {{10}, {0}};
     * double[][] c = {{2, 1}, {1, 1}};
     * double[][] result = Arrays37.dividedBy(a, b, c, 1, 1, 1, 1);
     * // result is {{5, 1}, {1, 1}}
     * </code></pre>
     *
     * @param a dividend 2D array.
     * @param b first divisor 2D array.
     * @param c second divisor 2D array.
     * @param valueForNoneA default for missing elements in a.
     * @param valueForNoneB default for missing elements in b.
     * @param valueForNoneC default for missing elements in c.
     * @param defaultValueForZero default for division by zero.
     * @return a new 2D array with the results.
     */
    public static double[][] dividedBy(final double[][] a, final double[][] b, final double[][] c, final double valueForNoneA, final double valueForNoneB,
            final double valueForNoneC, final double defaultValueForZero) {
        return dividedBy(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA,
                valueForNoneB, valueForNoneC, defaultValueForZero);
    }

    /**
     * Private helper for dividing three 2D arrays with defaults and zero handling.
     *
     * @param len number of rows in result.
     * @param rowLen max number of columns in result.
     * @param a dividend array.
     * @param b first divisor.
     * @param c second divisor.
     * @param valueForNoneA default for a.
     * @param valueForNoneB default for b.
     * @param valueForNoneC default for c.
     * @param defaultValueForZero default for division by zero.
     * @return a new 2D array.
     */
    private static double[][] dividedBy(final int len, final int rowLen, final double[][] a, final double[][] b, final double[][] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC, final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = dividedBy(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = dividedBy(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB,
                        valueForNoneC, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Divides a 3D array by another, element-wise, handling division by zero.
     * The dimensions are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{100}}};
     * double[][][] b = {{{0}}};
     * double[][][] result = Arrays37.dividedBy(a, b, 1.0);
     * // result is {{{100}}}
     * </code></pre>
     *
     * @param a the dividend 3D array.
     * @param b the divisor 3D array.
     * @param defaultValueForZero the value to use as the divisor when an element in {@code b} is 0.
     * @return a new 3D array with the results.
     */
    public static double[][][] dividedBy(final double[][][] a, final double[][][] b, final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Divides two 3D arrays element-wise, handling missing elements and division by zero.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{100}}, {{200}}};
     * double[][][] b = {{{10, 0}}};
     * double[][][] result = Arrays37.dividedBy(a, b, 1.0, 1.0, 1.0);
     * // result is {{{10.0, 1.0}}}, {{{200.0}}}
     * </code></pre>
     *
     * @param a the dividend 3D array.
     * @param b the divisor 3D array.
     * @param valueForNoneA default value for missing elements in a.
     * @param valueForNoneB default value for missing elements in b.
     * @param defaultValueForZero default value for division by zero.
     * @return a new 3D array with the results.
     */
    public static double[][][] dividedBy(final double[][][] a, final double[][][] b, final double valueForNoneA, final double valueForNoneB,
            final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = dividedBy(null, b[i], valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = dividedBy(a[i], null, valueForNoneA, valueForNoneB, defaultValueForZero);
            }
        }

        return result;
    }

    /**
     * Divides the first 3D array by the second and third, handling division by zero.
     * The dimensions are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{100}}};
     * double[][][] b = {{{10}}};
     * double[][][] c = {{{0}}};
     * double[][][] result = Arrays37.dividedBy(a, b, c, 1.0);
     * // result is {{{10}}}
     * </code></pre>
     *
     * @param a the dividend 3D array.
     * @param b the second divisor 3D array.
     * @param c the third divisor 3D array.
     * @param defaultValueForZero default value for division by zero.
     * @return a new 3D array with the results.
     */
    public static double[][][] dividedBy(final double[][][] a, final double[][][] b, final double[][][] c, final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], defaultValueForZero);
        }

        return result;
    }

    /**
     * Divides the first 3D array by the second and third, handling missing elements and division by zero.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{100}}};
     * double[][][] b = {{{10}}, {{0}}};
     * double[][][] c = {{{2}}, {{5}}, {{3}}};
     * double[][][] result = Arrays37.dividedBy(a, b, c, 1, 1, 1, 1);
     * // result is {{{5.0}}, {{1.0/1.0/5.0}}, {{1.0/1.0/3.0}}}
     * </code></pre>
     *
     * @param a dividend 3D array.
     * @param b first divisor 3D array.
     * @param c second divisor 3D array.
     * @param valueForNoneA default for missing elements in a.
     * @param valueForNoneB default for missing elements in b.
     * @param valueForNoneC default for missing elements in c.
     * @param defaultValueForZero default for division by zero.
     * @return a new 3D array with the results.
     */
    public static double[][][] dividedBy(final double[][][] a, final double[][][] b, final double[][][] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC, final double defaultValueForZero) {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = dividedBy(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, defaultValueForZero);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = dividedBy(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                    defaultValueForZero);
        }

        return result;
    }

    /**
     * Combines two arrays into one by applying a binary function to corresponding elements.
     * The length of the result is the minimum of the input array lengths.
     *
     * <pre><code>
     * double[] a = {1, 2, 3};
     * double[] b = {4, 5, 6};
     * double[] result = Arrays37.zip(a, b, (x, y) -> Math.pow(x, y));
     * // result is {1.0, 32.0, 729.0}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first array.
     * @param b the second array.
     * @param zipFunction the function to apply to each pair of elements.
     * @return a new array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[] zip(final double[] a, final double[] b, final Throwables.DoubleBiFunction<Double, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[N.min(lenA, lenB)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        return result;
    }

    /**
     * Combines two arrays into one by applying a binary function, with defaults for missing elements.
     * The length of the result is the maximum of the input array lengths.
     *
     * <pre><code>
     * double[] a = {1, 2};
     * double[] b = {10, 20, 30};
     * double[] result = Arrays37.zip(a, b, 0.0, 0.0, (x, y) -> x + y);
     * // result is {11, 22, 30}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default value for missing elements in a.
     * @param valueForNoneB default value for missing elements in b.
     * @param zipFunction the function to apply to each pair of elements.
     * @return a new array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[] zip(final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB,
            final Throwables.DoubleBiFunction<Double, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        return zip(N.max(lenA, lenB), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Private helper to zip two arrays with defaults.
     *
     * @param len length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param valueForNoneA default for a.
     * @param valueForNoneB default for b.
     * @param zipFunction the combination function.
     * @return a new array.
     * @throws E if the zip function throws an exception.
     */
    private static <E extends Exception> double[] zip(final int len, final double[] a, final double[] b, final double valueForNoneA, final double valueForNoneB,
            final Throwables.DoubleBiFunction<Double, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zipFunction.apply(valueForNoneA, b[i]);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zipFunction.apply(a[i], valueForNoneB);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zipFunction.apply(valueForNoneA, valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Combines three arrays into one by applying a ternary function to corresponding elements.
     * The length of the result is the minimum of the input array lengths.
     *
     * <pre><code>
     * double[] a = {1, 2, 3};
     * double[] b = {4, 5, 6};
     * double[] c = {7, 8, 9};
     * double[] result = Arrays37.zip(a, b, c, (x, y, z) -> x + y + z);
     * // result is {12, 15, 18}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param zipFunction the function to apply to each triplet of elements.
     * @return a new array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[] zip(final double[] a, final double[] b, final double[] c,
            final Throwables.DoubleTriFunction<Double, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[N.min(lenA, lenB, lenC)];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Combines three arrays into one by applying a ternary function, with defaults for missing elements.
     * The length of the result is the maximum of the input array lengths.
     *
     * <pre><code>
     * double[] a = {1};
     * double[] b = {10, 20};
     * double[] c = {100, 200, 300};
     * double[] result = Arrays37.zip(a, b, c, 0, 0, 0, (x, y, z) -> x + y + z);
     * // result is {111, 220, 300}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default value for missing elements in a.
     * @param valueForNoneB default value for missing elements in b.
     * @param valueForNoneC default value for missing elements in c.
     * @param zipFunction the function to apply to each triplet of elements.
     * @return a new array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[] zip(final double[] a, final double[] b, final double[] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC, final Throwables.DoubleTriFunction<Double, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        return zip(N.max(lenA, lenB, lenC), a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
    }

    /**
     * Private helper to zip three arrays with defaults.
     *
     * @param len length of the result array.
     * @param a the first array.
     * @param b the second array.
     * @param c the third array.
     * @param valueForNoneA default for a.
     * @param valueForNoneB default for b.
     * @param valueForNoneC default for c.
     * @param zipFunction the combination function.
     * @return a new array.
     * @throws E if the zip function throws an exception.
     */
    private static <E extends Exception> double[] zip(final int len, final double[] a, final double[] b, final double[] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC, final Throwables.DoubleTriFunction<Double, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[] result = new double[len];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Combines two 2D arrays into one by applying a binary function element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{1, 2}, {3, 4}};
     * double[][] b = {{5, 6}, {7, 8}};
     * double[][] result = Arrays37.zip(a, b, (x, y) -> x * y);
     * // result is {{5, 12}, {21, 32}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param zipFunction the function to apply to each pair of elements.
     * @return a new 2D array with the combined results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[][] zip(final double[][] a, final double[][] b, final Throwables.DoubleBiFunction<Double, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[N.min(lenA, lenB)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines two 2D arrays using a binary function, with defaults for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{1}, {2, 3}};
     * double[][] b = {{10, 20}, {30}};
     * double[][] result = Arrays37.zip(a, b, 0, 0, (x, y) -> x + y);
     * // result is {{11, 20}, {32, 3}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default for missing elements in a.
     * @param valueForNoneB default for missing elements in b.
     * @param zipFunction the function to apply.
     * @return a new 2D array with the results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[][] zip(final double[][] a, final double[][] b, final double valueForNoneA, final double valueForNoneB,
            final Throwables.DoubleBiFunction<Double, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)), a, b, valueForNoneA, valueForNoneB, zipFunction);
    }

    /**
     * Private helper to zip two 2D arrays with defaults.
     *
     * @param len number of rows in result.
     * @param rowLen max number of columns in result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param valueForNoneA default for a.
     * @param valueForNoneB default for b.
     * @param zipFunction the combination function.
     * @return a new 2D array.
     * @throws E if the zip function throws an exception.
     */
    private static <E extends Exception> double[][] zip(final int len, final int rowLen, final double[][] a, final double[][] b, final double valueForNoneA,
            final double valueForNoneB, final Throwables.DoubleBiFunction<Double, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB && lenA < len) {
            for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                result[i] = zip(rowLen, null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA && lenB < len) {
            for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                result[i] = zip(rowLen, a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        if (N.max(lenA, lenB) < len) {
            for (int i = N.max(lenA, lenB); i < len; i++) {
                result[i] = zip(rowLen, null, null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines three 2D arrays into one by applying a ternary function element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{1, 1}};
     * double[][] b = {{2, 2}};
     * double[][] c = {{3, 3}};
     * double[][] result = Arrays37.zip(a, b, c, (x, y, z) -> x + y + z);
     * // result is {{6, 6}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param zipFunction the function to apply.
     * @return a new 2D array with the results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[][] zip(final double[][] a, final double[][] b, final double[][] c,
            final Throwables.DoubleTriFunction<Double, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[N.min(lenA, lenB, lenC)][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines three 2D arrays using a ternary function, with defaults for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][] a = {{1}};
     * double[][] b = {{10}, {20}};
     * double[][] c = {{100, 200}, {300}};
     * double[][] result = Arrays37.zip(a, b, c, 0, 0, 0, (x, y, z) -> x+y+z);
     * // result is {{111, 200}, {320}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default for missing elements in a.
     * @param valueForNoneB default for missing elements in b.
     * @param valueForNoneC default for missing elements in c.
     * @param zipFunction the function to apply.
     * @return a new 2D array with the results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[][] zip(final double[][] a, final double[][] b, final double[][] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC, final Throwables.DoubleTriFunction<Double, E> zipFunction) throws E {
        return zip(N.max(N.len(a), N.len(b), N.len(c)), N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), a, b, c, valueForNoneA, valueForNoneB,
                valueForNoneC, zipFunction);
    }

    /**
     * Private helper to zip three 2D arrays with defaults.
     *
     * @param len number of rows in result.
     * @param rowLen max number of columns in result.
     * @param a the first 2D array.
     * @param b the second 2D array.
     * @param c the third 2D array.
     * @param valueForNoneA default for a.
     * @param valueForNoneB default for b.
     * @param valueForNoneC default for c.
     * @param zipFunction the combination function.
     * @return a new 2D array.
     * @throws E if the zip function throws an exception.
     */
    private static <E extends Exception> double[][] zip(final int len, final int rowLen, final double[][] a, final double[][] b, final double[][] c,
            final double valueForNoneA, final double valueForNoneB, final double valueForNoneC, final Throwables.DoubleTriFunction<Double, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][] result = new double[len][];

        for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
            result[i] = zip(rowLen, a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        if (N.min(lenA, lenB, lenC) < len) {
            for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                result[i] = zip(rowLen, i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                        zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines two 3D arrays into one by applying a binary function element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{1}}};
     * double[][][] b = {{{2}}};
     * double[][][] result = Arrays37.zip(a, b, (x, y) -> x + y);
     * // result is {{{3}}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param zipFunction the function to apply.
     * @return a new 3D array with the results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[][][] zip(final double[][][] a, final double[][][] b, final Throwables.DoubleBiFunction<Double, E> zipFunction)
            throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.min(lenA, lenB)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines two 3D arrays using a binary function, with defaults for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{1}}, {{2}}};
     * double[][][] b = {{{10, 20}}};
     * double[][][] result = Arrays37.zip(a, b, 0.0, 0.0, (x, y) -> x + y);
     * // result is {{{11.0, 20.0}}}, {{{2.0}}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param valueForNoneA default for missing elements in a.
     * @param valueForNoneB default for missing elements in b.
     * @param zipFunction the function to apply.
     * @return a new 3D array with the results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[][][] zip(final double[][][] a, final double[][][] b, final double valueForNoneA, final double valueForNoneB,
            final Throwables.DoubleBiFunction<Double, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);

        final double[][][] result = new double[N.max(lenA, lenB)][][];

        for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
            result[i] = zip(a[i], b[i], valueForNoneA, valueForNoneB, zipFunction);
        }

        if (lenA < lenB) {
            for (int i = lenA; i < lenB; i++) {
                result[i] = zip(null, b[i], valueForNoneA, valueForNoneB, zipFunction);
            }
        } else if (lenB < lenA) {
            for (int i = lenB; i < lenA; i++) {
                result[i] = zip(a[i], null, valueForNoneA, valueForNoneB, zipFunction);
            }
        }

        return result;
    }

    /**
     * Combines three 3D arrays into one by applying a ternary function element-wise.
     * The dimensions of the result are truncated to the minimum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{1}}};
     * double[][][] b = {{{2}}};
     * double[][][] c = {{{3}}};
     * double[][][] result = Arrays37.zip(a, b, c, (x, y, z) -> x + y + z);
     * // result is {{{6}}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @param zipFunction the function to apply.
     * @return a new 3D array with the results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[][][] zip(final double[][][] a, final double[][][] b, final double[][][] c,
            final Throwables.DoubleTriFunction<Double, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.min(lenA, lenB, lenC)][][];

        for (int i = 0, len = result.length; i < len; i++) {
            result[i] = zip(a[i], b[i], c[i], zipFunction);
        }

        return result;
    }

    /**
     * Combines three 3D arrays using a ternary function, with defaults for missing elements.
     * The dimensions of the result are the maximum of the inputs.
     *
     * <pre><code>
     * double[][][] a = {{{1}}};
     * double[][][] b = {{{10}}, {{20}}};
     * double[][][] c = {{{100}}, {{200}}, {{300}}};
     * double[][][] result = Arrays37.zip(a, b, c, 0, 0, 0, (x, y, z) -> x+y+z);
     * // result is {{{111}}, {{220}}, {{300}}}
     * </code></pre>
     *
     * @param <E> the type of exception that may be thrown by the function.
     * @param a the first 3D array.
     * @param b the second 3D array.
     * @param c the third 3D array.
     * @param valueForNoneA default for missing elements in a.
     * @param valueForNoneB default for missing elements in b.
     * @param valueForNoneC default for missing elements in c.
     * @param zipFunction the function to apply.
     * @return a new 3D array with the results.
     * @throws E if the zip function throws an exception.
     */
    public static <E extends Exception> double[][][] zip(final double[][][] a, final double[][][] b, final double[][][] c, final double valueForNoneA,
            final double valueForNoneB, final double valueForNoneC, final Throwables.DoubleTriFunction<Double, E> zipFunction) throws E {
        final int lenA = N.len(a);
        final int lenB = N.len(b);
        final int lenC = N.len(c);

        final double[][][] result = new double[N.max(lenA, lenB, lenC)][][];

        for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
            result[i] = zip(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
            result[i] = zip(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction);
        }

        return result;
    }

    /**
     * Calculates the total number of double elements in a jagged 2D array.
     *
     * <pre><code>
     * double[][] matrix = {{1, 2}, {3, 4, 5}, null, {}};
     * long count = Arrays37.totalCountOfElements(matrix);
     * // count is 5
     * </code></pre>
     *
     * @param a the 2D array.
     * @return the total count of elements.
     */
    public static long totalCountOfElements(final double[][] a) {
        long count = 0;

        for (final double[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        return count;
    }

    /**
     * Calculates the total number of double elements in a jagged 3D array.
     *
     * <pre><code>
     * double[][][] cube = {{{1}, {2, 3}}, null, {{{4}}}};
     * long count = Arrays37.totalCountOfElements(cube);
     * // count is 4
     * </code></pre>
     *
     * @param a the 3D array.
     * @return the total count of elements.
     */
    public static long totalCountOfElements(final double[][][] a) {
        long count = 0;

        for (final double[][] element : a) {
            if (N.isEmpty(element)) {
                continue;
            }

            for (final double[] doubles : element) {
                if (N.isEmpty(doubles)) {
                    continue;
                }

                count += doubles.length;
            }
        }

        return count;
    }

    /**
     * Finds the minimum length of any sub-array in a 2D array.
     * A null sub-array is considered to have a length of 0.
     *
     * <pre><code>
     * double[][] matrix = {{1, 2, 3}, {4, 5}, null};
     * int minLen = Arrays37.minSubArrayLen(matrix);
     * // minLen is 0
     * </code></pre>
     *
     * @param a the 2D array.
     * @return the minimum sub-array length, or 0 if the input array is null or empty.
     */
    public static int minSubArrayLen(final double[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int minLen = Integer.MAX_VALUE;

        for (final double[] ae : a) {
            minLen = N.min(minLen, ae == null ? 0 : ae.length);
        }

        return minLen;
    }

    /**
     * Finds the maximum length of any sub-array in a 2D array.
     * A null sub-array is considered to have a length of 0.
     *
     * <pre><code>
     * double[][] matrix = {{1, 2, 3}, {4, 5}, null};
     * int maxLen = Arrays37.maxSubArrayLen(matrix);
     * // maxLen is 3
     * </code></pre>
     *
     * @param a the 2D array.
     * @return the maximum sub-array length, or 0 if the input array is null or empty.
     */
    public static int maxSubArrayLen(final double[][] a) {
        if (N.isEmpty(a)) {
            return 0;
        }

        int maxLen = 0;

        for (final double[] ae : a) {
            maxLen = N.max(maxLen, ae == null ? 0 : ae.length);
        }

        return maxLen;
    }

    /**
     * Prints the contents of a 1D double array to the console, followed by a new line.
     * Handles null and empty arrays gracefully.
     *
     * <pre><code>
     * double[] array = {1.1, 2.2, 3.3};
     * Arrays37.println(array); // Prints "[1.1, 2.2, 3.3]"
     * </code></pre>
     *
     * @param a the array to print.
     * @return The string that was printed to the console.
     */
    public static String println(final double[] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            return N.println(N.toString(a));
        }
    }

    /**
     * Prints the contents of a 2D double array to the console, followed by a new line.
     * Provides a formatted string representation for readability.
     *
     * <pre><code>
     * double[][] matrix = {{1.0, 2.0}, {3.0, 4.0}};
     * Arrays37.println(matrix); // Prints "[[1.0, 2.0],\n [3.0, 4.0]]" (format may vary)
     * </code></pre>
     *
     * @param a the 2D array to print.
     * @return The string that was printed to the console.
     */
    public static String println(final double[][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final double[] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(", ");
                            }

                            sb.append(ai[j]);
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Prints the contents of a 3D double array to the console, followed by a new line.
     * Provides a formatted string representation for readability.
     *
     * <pre><code>
     * double[][][] cube = {{{1.0}, {2.0}}, {{3.0}, {4.0}}};
     * Arrays37.println(cube); // Prints a formatted representation of the 3D array.
     * </code></pre>
     *
     * @param a the 3D array to print.
     * @return The string that was printed to the console.
     */
    public static String println(final double[][][] a) {
        if (a == null) {
            return N.println("null");
        } else if (a.length == 0) {
            return N.println("[]");
        } else {
            final int len = a.length;
            final StringBuilder sb = Objectory.createStringBuilder();
            String str = null;

            try {
                sb.append('[');

                for (int i = 0; i < len; i++) {
                    if (i > 0) {
                        sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                    }

                    if (a[i] == null) {
                        sb.append("null");
                    } else if (a[i].length == 0) {
                        sb.append("[]");
                    } else {
                        final double[][] ai = a[i];
                        sb.append('[');

                        for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                            if (j > 0) {
                                sb.append(',').append(IOUtil.LINE_SEPARATOR).append("  ");
                            }

                            if (ai[j] == null) {
                                sb.append("null");
                            } else if (ai[j].length == 0) {
                                sb.append("[]");
                            } else {
                                final double[] aij = ai[j];
                                sb.append('[');

                                for (int k = 0, aijLen = aij.length; k < aijLen; k++) {
                                    if (k > 0) {
                                        sb.append(", ");
                                    }

                                    sb.append(aij[k]);
                                }

                                sb.append(']');
                            }
                        }

                        sb.append(']');
                    }
                }

                sb.append(']');
                str = sb.toString();
            } finally {
                Objectory.recycle(sb);
            }

            return N.println(str);
        }
    }

    /**
     * Converts an array of bytes to an array of booleans. A byte value greater than 0
     * is converted to {@code true}, otherwise {@code false}.
     *
     * <pre><code>
     * byte[] bytes = {1, 0, -1, 5};
     * boolean[] bools = Arrays37.toBoolean(bytes);
     * // bools is {true, false, false, true}
     * </code></pre>
     *
     * @param a the array of bytes to convert.
     * @return a new boolean array, or null if the input is null.
     */
    public static boolean[] toBoolean(final byte[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final boolean[] result = new boolean[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i] > 0;
        }

        return result;
    }

    /**
     * Converts a 2D array of bytes to a 2D array of booleans.
     *
     * @param a the 2D array of bytes to convert.
     * @return a new 2D boolean array, or null if the input is null.
     * @see #toBoolean(byte[])
     */
    public static boolean[][] toBoolean(final byte[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final boolean[][] result = new boolean[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toBoolean(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of bytes to a 3D array of booleans.
     *
     * @param a the 3D array of bytes to convert.
     * @return a new 3D boolean array, or null if the input is null.
     * @see #toBoolean(byte[][])
     */
    public static boolean[][][] toBoolean(final byte[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final boolean[][][] result = new boolean[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toBoolean(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of integers to an array of booleans. An integer value greater than 0
     * is converted to {@code true}, otherwise {@code false}.
     *
     * <pre><code>
     * int[] ints = {1, 0, -1, 5};
     * boolean[] bools = Arrays37.toBoolean(ints);
     * // bools is {true, false, false, true}
     * </code></pre>
     *
     * @param a the array of integers to convert.
     * @return a new boolean array, or null if the input is null.
     */
    public static boolean[] toBoolean(final int[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final boolean[] result = new boolean[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i] > 0;
        }

        return result;
    }

    /**
     * Converts a 2D array of integers to a 2D array of booleans.
     *
     * @param a the 2D array of integers to convert.
     * @return a new 2D boolean array, or null if the input is null.
     * @see #toBoolean(int[])
     */
    public static boolean[][] toBoolean(final int[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final boolean[][] result = new boolean[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toBoolean(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of integers to a 3D array of booleans.
     *
     * @param a the 3D array of integers to convert.
     * @return a new 3D boolean array, or null if the input is null.
     * @see #toBoolean(int[][])
     */
    public static boolean[][][] toBoolean(final int[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final boolean[][][] result = new boolean[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toBoolean(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of integers to an array of chars by casting.
     *
     * <pre><code>
     * int[] ints = {65, 66, 67};
     * char[] chars = Arrays37.toChar(ints);
     * // chars is {'A', 'B', 'C'}
     * </code></pre>
     *
     * @param a the array of integers to convert.
     * @return a new char array, or null if the input is null.
     */
    public static char[] toChar(final int[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final char[] result = new char[len];

        for (int i = 0; i < len; i++) {
            result[i] = (char) a[i];
        }

        return result;
    }

    /**
     * Converts a 2D array of integers to a 2D array of chars.
     *
     * @param a the 2D array of integers to convert.
     * @return a new 2D char array, or null if the input is null.
     * @see #toChar(int[])
     */
    public static char[][] toChar(final int[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final char[][] result = new char[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toChar(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of integers to a 3D array of chars.
     *
     * @param a the 3D array of integers to convert.
     * @return a new 3D char array, or null if the input is null.
     * @see #toChar(int[][])
     */
    public static char[][][] toChar(final int[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final char[][][] result = new char[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toChar(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of booleans to an array of bytes.
     * {@code true} becomes 1, and {@code false} becomes 0.
     *
     * <pre><code>
     * boolean[] bools = {true, false, true};
     * byte[] bytes = Arrays37.toByte(bools);
     * // bytes is {1, 0, 1}
     * </code></pre>
     *
     * @param a the array of booleans to convert.
     * @return a new byte array, or null if the input is null.
     */
    public static byte[] toByte(final boolean[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final byte[] result = new byte[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i] ? BYTE_1 : BYTE_0;
        }

        return result;
    }

    /**
     * Converts a 2D array of booleans to a 2D array of bytes.
     *
     * @param a the 2D array of booleans to convert.
     * @return a new 2D byte array, or null if the input is null.
     * @see #toByte(boolean[])
     */
    public static byte[][] toByte(final boolean[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final byte[][] result = new byte[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toByte(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of booleans to a 3D array of bytes.
     *
     * @param a the 3D array of booleans to convert.
     * @return a new 3D byte array, or null if the input is null.
     * @see #toByte(boolean[][])
     */
    public static byte[][][] toByte(final boolean[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final byte[][][] result = new byte[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toByte(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of bytes to an array of shorts by casting.
     *
     * <pre><code>
     * byte[] bytes = {10, 20, 30};
     * short[] shorts = Arrays37.toShort(bytes);
     * // shorts is {10, 20, 30}
     * </code></pre>
     *
     * @param a the array of bytes to convert.
     * @return a new short array, or null if the input is null.
     */
    public static short[] toShort(final byte[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final short[] result = new short[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a 2D array of bytes to a 2D array of shorts.
     *
     * @param a the 2D array of bytes to convert.
     * @return a new 2D short array, or null if the input is null.
     * @see #toShort(byte[])
     */
    public static short[][] toShort(final byte[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final short[][] result = new short[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toShort(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of bytes to a 3D array of shorts.
     *
     * @param a the 3D array of bytes to convert.
     * @return a new 3D short array, or null if the input is null.
     * @see #toShort(byte[][])
     */
    public static short[][][] toShort(final byte[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final short[][][] result = new short[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toShort(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of booleans to an array of integers.
     * {@code true} becomes 1, and {@code false} becomes 0.
     *
     * <pre><code>
     * boolean[] bools = {true, false, true};
     * int[] ints = Arrays37.toInt(bools);
     * // ints is {1, 0, 1}
     * </code></pre>
     *
     * @param a the array of booleans to convert.
     * @return a new integer array, or null if the input is null.
     */
    public static int[] toInt(final boolean[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i] ? 1 : 0;
        }

        return result;
    }

    /**
     * Converts a 2D array of booleans to a 2D array of integers.
     *
     * @param a the 2D array of booleans to convert.
     * @return a new 2D integer array, or null if the input is null.
     * @see #toInt(boolean[])
     */
    public static int[][] toInt(final boolean[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][] result = new int[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of booleans to a 3D array of integers.
     *
     * @param a the 3D array of booleans to convert.
     * @return a new 3D integer array, or null if the input is null.
     * @see #toInt(boolean[][])
     */
    public static int[][][] toInt(final boolean[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][][] result = new int[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of chars to an array of integers by casting.
     *
     * <pre><code>
     * char[] chars = {'A', 'B', 'C'};
     * int[] ints = Arrays37.toInt(chars);
     * // ints is {65, 66, 67}
     * </code></pre>
     *
     * @param a the array of chars to convert.
     * @return a new integer array, or null if the input is null.
     */
    public static int[] toInt(final char[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a 2D array of chars to a 2D array of integers.
     *
     * @param a the 2D array of chars to convert.
     * @return a new 2D integer array, or null if the input is null.
     * @see #toInt(char[])
     */
    public static int[][] toInt(final char[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][] result = new int[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of chars to a 3D array of integers.
     *
     * @param a the 3D array of chars to convert.
     * @return a new 3D integer array, or null if the input is null.
     * @see #toInt(char[][])
     */
    public static int[][][] toInt(final char[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][][] result = new int[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of bytes to an array of integers by casting.
     *
     * <pre><code>
     * byte[] bytes = {10, 20, 30};
     * int[] ints = Arrays37.toInt(bytes);
     * // ints is {10, 20, 30}
     * </code></pre>
     *
     * @param a the array of bytes to convert.
     * @return a new integer array, or null if the input is null.
     */
    public static int[] toInt(final byte[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a 2D array of bytes to a 2D array of integers.
     *
     * @param a the 2D array of bytes to convert.
     * @return a new 2D integer array, or null if the input is null.
     * @see #toInt(byte[])
     */
    public static int[][] toInt(final byte[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][] result = new int[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of bytes to a 3D array of integers.
     *
     * @param a the 3D array of bytes to convert.
     * @return a new 3D integer array, or null if the input is null.
     * @see #toInt(byte[][])
     */
    public static int[][][] toInt(final byte[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][][] result = new int[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of shorts to an array of integers by casting.
     *
     * <pre><code>
     * short[] shorts = {100, 200, 300};
     * int[] ints = Arrays37.toInt(shorts);
     * // ints is {100, 200, 300}
     * </code></pre>
     *
     * @param a the array of shorts to convert.
     * @return a new integer array, or null if the input is null.
     */
    public static int[] toInt(final short[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a 2D array of shorts to a 2D array of integers.
     *
     * @param a the 2D array of shorts to convert.
     * @return a new 2D integer array, or null if the input is null.
     * @see #toInt(short[])
     */
    public static int[][] toInt(final short[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][] result = new int[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of shorts to a 3D array of integers.
     *
     * @param a the 3D array of shorts to convert.
     * @return a new 3D integer array, or null if the input is null.
     * @see #toInt(short[][])
     */
    public static int[][][] toInt(final short[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][][] result = new int[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of floats to an array of integers by casting (truncating).
     *
     * <pre><code>
     * float[] floats = {1.1f, 2.9f, -3.5f};
     * int[] ints = Arrays37.toInt(floats);
     * // ints is {1, 2, -3}
     * </code></pre>
     *
     * @param a the array of floats to convert.
     * @return a new integer array, or null if the input is null.
     */
    public static int[] toInt(final float[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = (int) a[i];
        }

        return result;
    }

    /**
     * Converts a 2D array of floats to a 2D array of integers.
     *
     * @param a the 2D array of floats to convert.
     * @return a new 2D integer array, or null if the input is null.
     * @see #toInt(float[])
     */
    public static int[][] toInt(final float[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][] result = new int[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of floats to a 3D array of integers.
     *
     * @param a the 3D array of floats to convert.
     * @return a new 3D integer array, or null if the input is null.
     * @see #toInt(float[][])
     */
    public static int[][][] toInt(final float[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][][] result = new int[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of doubles to an array of integers by casting (truncating).
     *
     * <pre><code>
     * double[] doubles = {1.1, 2.9, -3.5};
     * int[] ints = Arrays37.toInt(doubles);
     * // ints is {1, 2, -3}
     * </code></pre>
     *
     * @param a the array of doubles to convert.
     * @return a new integer array, or null if the input is null.
     */
    public static int[] toInt(final double[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = (int) a[i];
        }

        return result;
    }

    /**
     * Converts a 2D array of doubles to a 2D array of integers.
     *
     * @param a the 2D array of doubles to convert.
     * @return a new 2D integer array, or null if the input is null.
     * @see #toInt(double[])
     */
    public static int[][] toInt(final double[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][] result = new int[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of doubles to a 3D array of integers.
     *
     * @param a the 3D array of doubles to convert.
     * @return a new 3D integer array, or null if the input is null.
     * @see #toInt(double[][])
     */
    public static int[][][] toInt(final double[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final int[][][] result = new int[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toInt(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of bytes to an array of longs by casting.
     *
     * <pre><code>
     * byte[] bytes = {10, 20, 30};
     * long[] longs = Arrays37.toLong(bytes);
     * // longs is {10L, 20L, 30L}
     * </code></pre>
     *
     * @param a the array of bytes to convert.
     * @return a new long array, or null if the input is null.
     */
    public static long[] toLong(final byte[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[] result = new long[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a 2D array of bytes to a 2D array of longs.
     *
     * @param a the 2D array of bytes to convert.
     * @return a new 2D long array, or null if the input is null.
     * @see #toLong(byte[])
     */
    public static long[][] toLong(final byte[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][] result = new long[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toLong(a[i]);
        }

        return result;
    }

    /**
     * Converts a 3D array of bytes to a 3D array of longs.
     *
     * @param a the 3D array of bytes to convert.
     * @return a new 3D long array, or null if the input is null.
     * @see #toLong(byte[][])
     */
    public static long[][][] toLong(final byte[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][][] result = new long[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toLong(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code short} array to a one-dimensional {@code long} array.
     * Each {@code short} element is cast to a {@code long}.
     *
     * <pre><code>
     * short[] source = {1, 2, 3};
     * long[] result = Arrays.toLong(source);
     * // result is {1L, 2L, 3L}
     * </code></pre>
     *
     * @param a the one-dimensional {@code short} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[] toLong(final short[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[] result = new long[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code short} array to a two-dimensional {@code long} array.
     * Each {@code short} element is cast to a {@code long}.
     *
     * <pre><code>
     * short[][] source = {{1, 2}, {3, 4}};
     * long[][] result = Arrays.toLong(source);
     * // result is {{1L, 2L}, {3L, 4L}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code short} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[][] toLong(final short[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][] result = new long[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toLong(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code short} array to a three-dimensional {@code long} array.
     * Each {@code short} element is cast to a {@code long}.
     *
     * <pre><code>
     * short[][][] source = {{{1, 2}}, {{3, 4}}};
     * long[][][] result = Arrays.toLong(source);
     * // result is {{{1L, 2L}}, {{3L, 4L}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code short} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[][][] toLong(final short[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][][] result = new long[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toLong(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code int} array to a one-dimensional {@code long} array.
     * Each {@code int} element is cast to a {@code long}.
     *
     * <pre><code>
     * int[] source = {1, 2, 3};
     * long[] result = Arrays.toLong(source);
     * // result is {1L, 2L, 3L}
     * </code></pre>
     *
     * @param a the one-dimensional {@code int} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[] toLong(final int[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[] result = new long[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code int} array to a two-dimensional {@code long} array.
     * Each {@code int} element is cast to a {@code long}.
     *
     * <pre><code>
     * int[][] source = {{1, 2}, {3, 4}};
     * long[][] result = Arrays.toLong(source);
     * // result is {{1L, 2L}, {3L, 4L}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code int} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[][] toLong(final int[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][] result = new long[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toLong(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code int} array to a three-dimensional {@code long} array.
     * Each {@code int} element is cast to a {@code long}.
     *
     * <pre><code>
     * int[][][] source = {{{1, 2}}, {{3, 4}}};
     * long[][][] result = Arrays.toLong(source);
     * // result is {{{1L, 2L}}, {{3L, 4L}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code int} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[][][] toLong(final int[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][][] result = new long[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toLong(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code float} array to a one-dimensional {@code long} array.
     * Each {@code float} element is cast to a {@code long}, involving a narrowing primitive conversion.
     *
     * <pre><code>
     * float[] source = {1.1f, 2.9f, 3.5f};
     * long[] result = Arrays.toLong(source);
     * // result is {1L, 2L, 3L}
     * </code></pre>
     *
     * @param a the one-dimensional {@code float} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[] toLong(final float[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[] result = new long[len];

        for (int i = 0; i < len; i++) {
            result[i] = (long) a[i];
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code float} array to a two-dimensional {@code long} array.
     * Each {@code float} element is cast to a {@code long}.
     *
     * <pre><code>
     * float[][] source = {{1.1f, 2.9f}, {3.5f, 4.0f}};
     * long[][] result = Arrays.toLong(source);
     * // result is {{1L, 2L}, {3L, 4L}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code float} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[][] toLong(final float[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][] result = new long[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toLong(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code float} array to a three-dimensional {@code long} array.
     * Each {@code float} element is cast to a {@code long}.
     *
     * <pre><code>
     * float[][][] source = {{{1.1f, 2.9f}}, {{3.5f, 4.0f}}};
     * long[][][] result = Arrays.toLong(source);
     * // result is {{{1L, 2L}}, {{3L, 4L}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code float} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[][][] toLong(final float[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][][] result = new long[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toLong(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code double} array to a one-dimensional {@code long} array.
     * Each {@code double} element is cast to a {@code long}, involving a narrowing primitive conversion.
     *
     * <pre><code>
     * double[] source = {1.1, 2.9, 3.5};
     * long[] result = Arrays.toLong(source);
     * // result is {1L, 2L, 3L}
     * </code></pre>
     *
     * @param a the one-dimensional {@code double} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[] toLong(final double[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[] result = new long[len];

        for (int i = 0; i < len; i++) {
            result[i] = (long) a[i];
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code double} array to a two-dimensional {@code long} array.
     * Each {@code double} element is cast to a {@code long}.
     *
     * <pre><code>
     * double[][] source = {{1.1, 2.9}, {3.5, 4.0}};
     * long[][] result = Arrays.toLong(source);
     * // result is {{1L, 2L}, {3L, 4L}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code double} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[][] toLong(final double[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][] result = new long[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toLong(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code double} array to a three-dimensional {@code long} array.
     * Each {@code double} element is cast to a {@code long}.
     *
     * <pre><code>
     * double[][][] source = {{{1.1, 2.9}}, {{3.5, 4.0}}};
     * long[][][] result = Arrays.toLong(source);
     * // result is {{{1L, 2L}}, {{3L, 4L}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code double} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code long} array, or {@code null} if the input was {@code null}.
     */
    public static long[][][] toLong(final double[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final long[][][] result = new long[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toLong(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code byte} array to a one-dimensional {@code float} array.
     * Each {@code byte} element is cast to a {@code float}.
     *
     * <pre><code>
     * byte[] source = {1, 2, 3};
     * float[] result = Arrays.toFloat(source);
     * // result is {1.0f, 2.0f, 3.0f}
     * </code></pre>
     *
     * @param a the one-dimensional {@code byte} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[] toFloat(final byte[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[] result = new float[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code byte} array to a two-dimensional {@code float} array.
     * Each {@code byte} element is cast to a {@code float}.
     *
     * <pre><code>
     * byte[][] source = {{1, 2}, {3, 4}};
     * float[][] result = Arrays.toFloat(source);
     * // result is {{1.0f, 2.0f}, {3.0f, 4.0f}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code byte} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[][] toFloat(final byte[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[][] result = new float[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toFloat(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code byte} array to a three-dimensional {@code float} array.
     * Each {@code byte} element is cast to a {@code float}.
     *
     * <pre><code>
     * byte[][][] source = {{{1, 2}}, {{3, 4}}};
     * float[][][] result = Arrays.toFloat(source);
     * // result is {{{1.0f, 2.0f}}, {{3.0f, 4.0f}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code byte} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[][][] toFloat(final byte[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[][][] result = new float[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toFloat(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code short} array to a one-dimensional {@code float} array.
     * Each {@code short} element is cast to a {@code float}.
     *
     * <pre><code>
     * short[] source = {1, 2, 3};
     * float[] result = Arrays.toFloat(source);
     * // result is {1.0f, 2.0f, 3.0f}
     * </code></pre>
     *
     * @param a the one-dimensional {@code short} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[] toFloat(final short[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[] result = new float[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code short} array to a two-dimensional {@code float} array.
     * Each {@code short} element is cast to a {@code float}.
     *
     * <pre><code>
     * short[][] source = {{1, 2}, {3, 4}};
     * float[][] result = Arrays.toFloat(source);
     * // result is {{1.0f, 2.0f}, {3.0f, 4.0f}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code short} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[][] toFloat(final short[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[][] result = new float[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toFloat(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code short} array to a three-dimensional {@code float} array.
     * Each {@code short} element is cast to a {@code float}.
     *
     * <pre><code>
     * short[][][] source = {{{1, 2}}, {{3, 4}}};
     * float[][][] result = Arrays.toFloat(source);
     * // result is {{{1.0f, 2.0f}}, {{3.0f, 4.0f}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code short} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[][][] toFloat(final short[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[][][] result = new float[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toFloat(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code int} array to a one-dimensional {@code float} array.
     * Each {@code int} element is cast to a {@code float}.
     *
     * <pre><code>
     * int[] source = {1, 2, 3};
     * float[] result = Arrays.toFloat(source);
     * // result is {1.0f, 2.0f, 3.0f}
     * </code></pre>
     *
     * @param a the one-dimensional {@code int} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[] toFloat(final int[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[] result = new float[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code int} array to a two-dimensional {@code float} array.
     * Each {@code int} element is cast to a {@code float}.
     *
     * <pre><code>
     * int[][] source = {{1, 2}, {3, 4}};
     * float[][] result = Arrays.toFloat(source);
     * // result is {{1.0f, 2.0f}, {3.0f, 4.0f}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code int} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[][] toFloat(final int[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[][] result = new float[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toFloat(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code int} array to a three-dimensional {@code float} array.
     * Each {@code int} element is cast to a {@code float}.
     *
     * <pre><code>
     * int[][][] source = {{{1, 2}}, {{3, 4}}};
     * float[][][] result = Arrays.toFloat(source);
     * // result is {{{1.0f, 2.0f}}, {{3.0f, 4.0f}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code int} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[][][] toFloat(final int[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[][][] result = new float[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toFloat(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code long} array to a one-dimensional {@code float} array.
     * Each {@code long} element is cast to a {@code float}, which may result in a loss of precision.
     *
     * <pre><code>
     * long[] source = {1L, 2L, 9007199254740992L};
     * float[] result = Arrays.toFloat(source);
     * // result may be {1.0f, 2.0f, 9.0071992E15f}
     * </code></pre>
     *
     * @param a the one-dimensional {@code long} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[] toFloat(final long[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[] result = new float[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code long} array to a two-dimensional {@code float} array.
     * Each {@code long} element is cast to a {@code float}, which may result in a loss of precision.
     *
     * <pre><code>
     * long[][] source = {{1L, 2L}, {3L, 4L}};
     * float[][] result = Arrays.toFloat(source);
     * // result is {{1.0f, 2.0f}, {3.0f, 4.0f}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code long} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[][] toFloat(final long[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[][] result = new float[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toFloat(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code long} array to a three-dimensional {@code float} array.
     * Each {@code long} element is cast to a {@code float}, which may result in a loss of precision.
     *
     * <pre><code>
     * long[][][] source = {{{1L, 2L}}, {{3L, 4L}}};
     * float[][][] result = Arrays.toFloat(source);
     * // result is {{{1.0f, 2.0f}}, {{3.0f, 4.0f}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code long} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code float} array, or {@code null} if the input was {@code null}.
     */
    public static float[][][] toFloat(final long[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final float[][][] result = new float[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toFloat(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code byte} array to a one-dimensional {@code double} array.
     * Each {@code byte} element is cast to a {@code double}.
     *
     * <pre><code>
     * byte[] source = {1, 2, 3};
     * double[] result = Arrays.toDouble(source);
     * // result is {1.0, 2.0, 3.0}
     * </code></pre>
     *
     * @param a the one-dimensional {@code byte} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[] toDouble(final byte[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[] result = new double[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code byte} array to a two-dimensional {@code double} array.
     * Each {@code byte} element is cast to a {@code double}.
     *
     * <pre><code>
     * byte[][] source = {{1, 2}, {3, 4}};
     * double[][] result = Arrays.toDouble(source);
     * // result is {{1.0, 2.0}, {3.0, 4.0}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code byte} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[][] toDouble(final byte[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][] result = new double[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toDouble(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code byte} array to a three-dimensional {@code double} array.
     * Each {@code byte} element is cast to a {@code double}.
     *
     * <pre><code>
     * byte[][][] source = {{{1, 2}}, {{3, 4}}};
     * double[][][] result = Arrays.toDouble(source);
     * // result is {{{1.0, 2.0}}, {{3.0, 4.0}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code byte} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[][][] toDouble(final byte[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][][] result = new double[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toDouble(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code short} array to a one-dimensional {@code double} array.
     * Each {@code short} element is cast to a {@code double}.
     *
     * <pre><code>
     * short[] source = {1, 2, 3};
     * double[] result = Arrays.toDouble(source);
     * // result is {1.0, 2.0, 3.0}
     * </code></pre>
     *
     * @param a the one-dimensional {@code short} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[] toDouble(final short[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[] result = new double[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code short} array to a two-dimensional {@code double} array.
     * Each {@code short} element is cast to a {@code double}.
     *
     * <pre><code>
     * short[][] source = {{1, 2}, {3, 4}};
     * double[][] result = Arrays.toDouble(source);
     * // result is {{1.0, 2.0}, {3.0, 4.0}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code short} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[][] toDouble(final short[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][] result = new double[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toDouble(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code short} array to a three-dimensional {@code double} array.
     * Each {@code short} element is cast to a {@code double}.
     *
     * <pre><code>
     * short[][][] source = {{{1, 2}}, {{3, 4}}};
     * double[][][] result = Arrays.toDouble(source);
     * // result is {{{1.0, 2.0}}, {{3.0, 4.0}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code short} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[][][] toDouble(final short[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][][] result = new double[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toDouble(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code int} array to a one-dimensional {@code double} array.
     * Each {@code int} element is cast to a {@code double}.
     *
     * <pre><code>
     * int[] source = {1, 2, 3};
     * double[] result = Arrays.toDouble(source);
     * // result is {1.0, 2.0, 3.0}
     * </code></pre>
     *
     * @param a the one-dimensional {@code int} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[] toDouble(final int[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[] result = new double[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code int} array to a two-dimensional {@code double} array.
     * Each {@code int} element is cast to a {@code double}.
     *
     * <pre><code>
     * int[][] source = {{1, 2}, {3, 4}};
     * double[][] result = Arrays.toDouble(source);
     * // result is {{1.0, 2.0}, {3.0, 4.0}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code int} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[][] toDouble(final int[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][] result = new double[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toDouble(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code int} array to a three-dimensional {@code double} array.
     * Each {@code int} element is cast to a {@code double}.
     *
     * <pre><code>
     * int[][][] source = {{{1, 2}}, {{3, 4}}};
     * double[][][] result = Arrays.toDouble(source);
     * // result is {{{1.0, 2.0}}, {{3.0, 4.0}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code int} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[][][] toDouble(final int[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][][] result = new double[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toDouble(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code long} array to a one-dimensional {@code double} array.
     * Each {@code long} element is cast to a {@code double}, which may result in a loss of precision.
     *
     * <pre><code>
     * long[] source = {1L, 2L, 9007199254740992L};
     * double[] result = Arrays.toDouble(source);
     * // result is {1.0, 2.0, 9.007199254740992E15}
     * </code></pre>
     *
     * @param a the one-dimensional {@code long} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[] toDouble(final long[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[] result = new double[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code long} array to a two-dimensional {@code double} array.
     * Each {@code long} element is cast to a {@code double}, which may result in a loss of precision.
     *
     * <pre><code>
     * long[][] source = {{1L, 2L}, {3L, 4L}};
     * double[][] result = Arrays.toDouble(source);
     * // result is {{1.0, 2.0}, {3.0, 4.0}}
     * </code></pre>
     *
     * @param a the two-dimensional {@code long} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[][] toDouble(final long[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][] result = new double[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toDouble(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code long} array to a three-dimensional {@code double} array.
     * Each {@code long} element is cast to a {@code double}, which may result in a loss of precision.
     *
     * <pre><code>
     * long[][][] source = {{{1L, 2L}}, {{3L, 4L}}};
     * double[][][] result = Arrays.toDouble(source);
     * // result is {{{1.0, 2.0}}, {{3.0, 4.0}}}
     * </code></pre>
     *
     * @param a the three-dimensional {@code long} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[][][] toDouble(final long[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][][] result = new double[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toDouble(a[i]);
        }

        return result;
    }

    /**
     * Converts a one-dimensional {@code float} array to a one-dimensional {@code double} array.
     * Each {@code float} element is cast to a {@code double}.
     *
     * <pre><code>
     * float[] source = {1.1f, 2.2f, 3.3f};
     * double[] result = Arrays.toDouble(source);
     * // result is approximately {1.100000023841858, 2.200000047683716, 3.299999952316284}
     * </code></pre>
     *
     * @param a the one-dimensional {@code float} array to convert. Can be {@code null}.
     * @return a new one-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[] toDouble(final float[] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[] result = new double[len];

        for (int i = 0; i < len; i++) {
            result[i] = a[i]; // NOSONAR
        }

        return result;
    }

    /**
     * Converts a two-dimensional {@code float} array to a two-dimensional {@code double} array.
     * Each {@code float} element is cast to a {@code double}.
     *
     * <pre><code>
     * float[][] source = {{1.1f, 2.2f}, {3.3f, 4.4f}};
     * double[][] result = Arrays.toDouble(source);
     * // result is a 2D double array with converted values.
     * </code></pre>
     *
     * @param a the two-dimensional {@code float} array to convert. Can be {@code null}.
     * @return a new two-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[][] toDouble(final float[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][] result = new double[len][];

        for (int i = 0; i < len; i++) {
            result[i] = toDouble(a[i]);
        }

        return result;
    }

    /**
     * Converts a three-dimensional {@code float} array to a three-dimensional {@code double} array.
     * Each {@code float} element is cast to a {@code double}.
     *
     * <pre><code>
     * float[][][] source = {{{1.1f, 2.2f}}, {{3.3f, 4.4f}}};
     * double[][][] result = Arrays.toDouble(source);
     * // result is a 3D double array with converted values.
     * </code></pre>
     *
     * @param a the three-dimensional {@code float} array to convert. Can be {@code null}.
     * @return a new three-dimensional {@code double} array, or {@code null} if the input was {@code null}.
     */
    public static double[][][] toDouble(final float[][][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        final int len = N.len(a);
        final double[][][] result = new double[len][][];

        for (int i = 0; i < len; i++) {
            result[i] = toDouble(a[i]);
        }

        return result;
    }

    private static void checkMForReshape(final int m) { // NOSONAR
        N.checkArgument(m > 0, "'m' must be positive number: m = %s", m);
    }

    private static void checkMAndLForReshape(final int m, final int l) {
        N.checkArgument(m > 0 && l > 0, "'m'  and 'l' must be positive number: m = %s, l = %s", m, l);
    }

    /**
     * A placeholder utility class that extends {@code com.landawn.abacus.util.Arrays}.
     * This class is intended to be a part of a larger utility suite but does not define
     * any methods of its own. It is marked with {@code SuppressFBWarnings} for its naming convention.
     */
    @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION")
    public static final class f extends com.landawn.abacus.util.Arrays { // NOSONAR
        private f() {
            // utility class
        }
    }

    /**
     * A utility class providing methods for functional-style operations on two-dimensional arrays.
     * Operations include updating, replacing, reshaping, flattening, mapping, and zipping.
     * This class is marked with {@code SuppressFBWarnings} for its naming convention.
     */
    @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION")
    public static final class ff { // NOSONAR

        /**
         * Private constructor to prevent instantiation.
         */
        private ff() {
            // Singleton
        }

        /**
         * Updates all elements in the specified two-dimensional array in-place using the given operator.
         * The operator is applied to each element of the nested arrays.
         *
         * <pre><code>
         * String[][] a = {{"a", "b"}, {"c", "d"}};
         * ff.updateAll(a, str -> str.toUpperCase());
         * // a is now {{"A", "B"}, {"C", "D"}}
         * </code></pre>
         *
         * @param <T> the type of elements in the array.
         * @param <E> the type of exception that may be thrown by the operator.
         * @param a the two-dimensional array to update. The operation is in-place.
         * @param operator the unary operator to apply to each element.
         * @throws E if the operator throws an exception.
         */
        public static <T, E extends Exception> void updateAll(final T[][] a, final Throwables.UnaryOperator<T, E> operator) throws E {
            if (N.isEmpty(a)) {
                return;
            }

            for (final T[] element : a) {
                if (N.isEmpty(element)) {
                    continue;
                }

                for (int j = 0, m = element.length; j < m; j++) {
                    element[j] = operator.apply(element[j]);
                }
            }
        }

        /**
         * Replaces all elements in the specified two-dimensional array that satisfy the given predicate
         * with the provided new value. The replacement happens in-place.
         *
         * <pre><code>
         * Integer[][] a = {{1, null, 3}, {null, 5}};
         * ff.replaceIf(a, val -> val == null, -1);
         * // a is now {{1, -1, 3}, {-1, 5}}
         * </code></pre>
         *
         * @param <T> the type of elements in the array.
         * @param <E> the type of exception that may be thrown by the predicate.
         * @param a the two-dimensional array to modify.
         * @param predicate the condition to test for each element.
         * @param newValue the value to be placed in the array if the predicate is true.
         * @throws E if the predicate throws an exception.
         */
        public static <T, E extends Exception> void replaceIf(final T[][] a, final Throwables.Predicate<? super T, E> predicate, final T newValue) throws E {
            if (N.isEmpty(a)) {
                return;
            }

            for (final T[] element : a) {
                if (N.isEmpty(element)) {
                    continue;
                }

                for (int j = 0, m = element.length; j < m; j++) {
                    if (predicate.test(element[j])) {
                        element[j] = newValue;
                    }
                }
            }
        }

        /**
         * Reshapes a one-dimensional array into a two-dimensional array with a specified number of columns.
         * The number of rows is determined automatically. The last row may be shorter if the total number
         * of elements is not a multiple of {@code cols}.
         *
         * <pre><code>
         * Integer[] a = {1, 2, 3, 4, 5, 6, 7};
         * Integer[][] result = ff.reshape(a, 3);
         * // result is {{1, 2, 3}, {4, 5, 6}, {7}}
         * </code></pre>
         *
         * @param <T> the component type of the array.
         * @param a the one-dimensional array to reshape.
         * @param cols the number of columns in the resulting two-dimensional array. Must be positive.
         * @return a new two-dimensional array.
         * @throws IllegalArgumentException if {@code cols} is not positive.
         */
        public static <T> T[][] reshape(final T[] a, final int cols) throws IllegalArgumentException {
            checkMForReshape(cols);

            //        if (N.isEmpty(a)) {
            //            return new T[0][0];
            //        }

            final int len = a.length;
            final int n = Numbers.divide(len, cols, RoundingMode.CEILING);
            final T[][] c = N.newArray((Class<T[]>) a.getClass(), n);

            for (int i = 0, from = 0; i < n; i++, from += cols) {
                c[i] = N.copyOfRange(a, from, from + N.min(len - from, cols));
            }

            return c;
        }

        /**
         * Flattens a two-dimensional array (which may be jagged) into a one-dimensional array.
         * Elements are concatenated in the order they appear.
         *
         * <pre><code>
         * Integer[][] a = {{1, 2}, {3}, {4, 5, 6}};
         * Integer[] result = ff.flatten(a);
         * // result is {1, 2, 3, 4, 5, 6}
         * </code></pre>
         *
         * @param <T> the component type of the array.
         * @param a the two-dimensional array to flatten.
         * @return a new one-dimensional array containing all elements from the input array.
         */
        public static <T> T[] flatten(final T[][] a) {
            final int count = Numbers.toIntExact(totalCountOfElements(a));

            final T[] c = N.newArray((Class<T>) a.getClass().getComponentType().getComponentType(), count);
            int from = 0;

            for (final T[] element : a) {
                if (N.isEmpty(element)) {
                    continue;
                }

                N.copy(element, 0, c, from, element.length);

                from += element.length;
            }

            return c;
        }

        /**
         * Flattens a two-dimensional array, applies an operation to the resulting one-dimensional array,
         * and then copies the modified elements back into the original two-dimensional array.
         * This is useful for performing array-wide operations like sorting.
         *
         * <pre><code>
         * Integer[][] a = {{3, 1}, {4, 2}};
         * ff.flatOp(a, arr -> java.util.Arrays.sort(arr));
         * // a is now {{1, 2}, {3, 4}}
         * </code></pre>
         *
         * @param <T> the type of elements in the array.
         * @param <E> the type of exception that may be thrown by the operation.
         * @param a the two-dimensional array to operate on. The operation is in-place.
         * @param op the consumer to accept the flattened array.
         * @throws E if the operation throws an exception.
         */
        public static <T, E extends Exception> void flatOp(final T[][] a, final Throwables.Consumer<? super T[], E> op) throws E {
            if (N.isEmpty(a)) {
                return;
            }

            final T[] tmp = flatten(a);

            op.accept(tmp);

            int idx = 0;

            for (final T[] e : a) {
                if (N.notEmpty(e)) {
                    N.copy(tmp, idx, e, 0, e.length);
                    idx += e.length;
                }
            }
        }

        /**
         * Maps a two-dimensional array to a new two-dimensional array by applying a function to each element.
         * The structure of the array (number of rows and columns in each row) is preserved.
         *
         * <pre><code>
         * Integer[][] a = {{1, 2}, {3, 4}};
         * String[][] result = ff.map(a, String::valueOf);
         * // result is {{"1", "2"}, {"3", "4"}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source two-dimensional array.
         * @param func the unary operator to apply to each element.
         * @return a new two-dimensional array with the mapped elements.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> T[][] map(final T[][] a, final Throwables.UnaryOperator<T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            return map(a, func, (Class<T>) a.getClass().getComponentType().getComponentType());
        }

        /**
         * Maps a two-dimensional array of type {@code T} to a new two-dimensional array of type {@code R}
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][] a = {{"1", "2"}, {"3", "4"}};
         * Integer[][] result = ff.map(a, Integer::parseInt, Integer.class);
         * // result is {{1, 2}, {3, 4}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <R> the type of elements in the resulting array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source two-dimensional array.
         * @param func the function to apply to each element.
         * @param targetElementType the class object for the element type of the resulting array.
         * @return a new two-dimensional array with the mapped elements.
         * @throws E if the function throws an exception.
         */
        public static <T, R, E extends Exception> R[][] map(final T[][] a, final Throwables.Function<? super T, ? extends R, E> func,
                final Class<R> targetElementType) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final R[][] c = N.newArray(N.newArray(targetElementType, 0).getClass(), len);

            for (int i = 0; i < len; i++) {
                c[i] = com.landawn.abacus.util.Arrays.map(a[i], func, targetElementType);
            }

            return c;
        }

        /**
         * Maps a two-dimensional array of a generic type {@code T} to a two-dimensional {@code boolean} array
         * by applying a predicate to each element.
         *
         * <pre><code>
         * Integer[][] a = {{0, 1}, {-1, 2}};
         * boolean[][] result = ff.mapToBoolean(a, x -> x > 0);
         * // result is {{false, true}, {false, true}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source two-dimensional array.
         * @param func the predicate to apply to each element.
         * @return a new two-dimensional {@code boolean} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> boolean[][] mapToBoolean(final T[][] a, final Throwables.ToBooleanFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final boolean[][] c = new boolean[len][];

            for (int i = 0; i < len; i++) {
                c[i] = com.landawn.abacus.util.Arrays.mapToBoolean(a[i], func);
            }

            return c;
        }

        /**
         * Maps a two-dimensional array of a generic type {@code T} to a two-dimensional {@code char} array
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][] a = {{"a"}, {"b", "c"}};
         * char[][] result = ff.mapToChar(a, s -> s.charAt(0));
         * // result is {{'a'}, {'b', 'c'}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source two-dimensional array.
         * @param func the function to apply to each element.
         * @return a new two-dimensional {@code char} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> char[][] mapToChar(final T[][] a, final Throwables.ToCharFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final char[][] c = new char[len][];

            for (int i = 0; i < len; i++) {
                c[i] = com.landawn.abacus.util.Arrays.mapToChar(a[i], func);
            }

            return c;
        }

        /**
         * Maps a two-dimensional array of a generic type {@code T} to a two-dimensional {@code byte} array
         * by applying a function to each element.
         *
         * <pre><code>
         * Integer[][] a = {{10}, {20, 30}};
         * byte[][] result = ff.mapToByte(a, x -> x.byteValue());
         * // result is {{10}, {20, 30}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source two-dimensional array.
         * @param func the function to apply to each element.
         * @return a new two-dimensional {@code byte} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> byte[][] mapToByte(final T[][] a, final Throwables.ToByteFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final byte[][] c = new byte[len][];

            for (int i = 0; i < len; i++) {
                c[i] = com.landawn.abacus.util.Arrays.mapToByte(a[i], func);
            }

            return c;
        }

        /**
         * Maps a two-dimensional array of a generic type {@code T} to a two-dimensional {@code short} array
         * by applying a function to each element.
         *
         * <pre><code>
         * Integer[][] a = {{10}, {20, 30}};
         * short[][] result = ff.mapToShort(a, x -> x.shortValue());
         * // result is {{10}, {20, 30}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source two-dimensional array.
         * @param func the function to apply to each element.
         * @return a new two-dimensional {@code short} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> short[][] mapToShort(final T[][] a, final Throwables.ToShortFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final short[][] c = new short[len][];

            for (int i = 0; i < len; i++) {
                c[i] = com.landawn.abacus.util.Arrays.mapToShort(a[i], func);
            }

            return c;
        }

        /**
         * Maps a two-dimensional array of a generic type {@code T} to a two-dimensional {@code int} array
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][] a = {{"1"}, {"2", "3"}};
         * int[][] result = ff.mapToInt(a, Integer::parseInt);
         * // result is {{1}, {2, 3}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source two-dimensional array.
         * @param func the function to apply to each element.
         * @return a new two-dimensional {@code int} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> int[][] mapToInt(final T[][] a, final Throwables.ToIntFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final int[][] c = new int[len][];

            for (int i = 0; i < len; i++) {
                c[i] = com.landawn.abacus.util.Arrays.mapToInt(a[i], func);
            }

            return c;
        }

        /**
         * Maps a two-dimensional array of a generic type {@code T} to a two-dimensional {@code long} array
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][] a = {{"1"}, {"2", "3"}};
         * long[][] result = ff.mapToLong(a, Long::parseLong);
         * // result is {{1L}, {2L, 3L}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source two-dimensional array.
         * @param func the function to apply to each element.
         * @return a new two-dimensional {@code long} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> long[][] mapToLong(final T[][] a, final Throwables.ToLongFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final long[][] c = new long[len][];

            for (int i = 0; i < len; i++) {
                c[i] = com.landawn.abacus.util.Arrays.mapToLong(a[i], func);
            }

            return c;
        }

        /**
         * Maps a two-dimensional array of a generic type {@code T} to a two-dimensional {@code float} array
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][] a = {{"1.1"}, {"2.2", "3.3"}};
         * float[][] result = ff.mapToFloat(a, Float::parseFloat);
         * // result is {{1.1f}, {2.2f, 3.3f}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source two-dimensional array.
         * @param func the function to apply to each element.
         * @return a new two-dimensional {@code float} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> float[][] mapToFloat(final T[][] a, final Throwables.ToFloatFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final float[][] c = new float[len][];

            for (int i = 0; i < len; i++) {
                c[i] = com.landawn.abacus.util.Arrays.mapToFloat(a[i], func);
            }

            return c;
        }

        /**
         * Maps a two-dimensional array of a generic type {@code T} to a two-dimensional {@code double} array
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][] a = {{"1.1"}, {"2.2", "3.3"}};
         * double[][] result = ff.mapToDouble(a, Double::parseDouble);
         * // result is {{1.1}, {2.2, 3.3}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source two-dimensional array.
         * @param func the function to apply to each element.
         * @return a new two-dimensional {@code double} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> double[][] mapToDouble(final T[][] a, final Throwables.ToDoubleFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final double[][] c = new double[len][];

            for (int i = 0; i < len; i++) {
                c[i] = com.landawn.abacus.util.Arrays.mapToDouble(a[i], func);
            }

            return c;
        }

        /**
         * A private helper method to zip elements of two 1D arrays into a result array.
         *
         * @param <A> type of first array element
         * @param <B> type of second array element
         * @param <R> type of result array element
         * @param <E> type of exception
         * @param len length of the result array
         * @param a first array
         * @param b second array
         * @param valueForNoneA default value for first array
         * @param valueForNoneB default value for second array
         * @param zipFunction function to combine elements
         * @param targetElementType class of the result element type
         * @return a new array of zipped elements
         * @throws E if the zip function fails
         */
        private static <A, B, R, E extends Exception> R[] zip(final int len, final A[] a, final B[] b, final A valueForNoneA, final B valueForNoneB,
                final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E {
            final int lenA = N.len(a);
            final int lenB = N.len(b);

            final R[] result = N.newArray(targetElementType, len);

            for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
                result[i] = zipFunction.apply(a[i], b[i]);
            }

            if (lenA < lenB && lenA < len) {
                for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                    result[i] = zipFunction.apply(valueForNoneA, b[i]);
                }
            } else if (lenB < lenA && lenB < len) {
                for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                    result[i] = zipFunction.apply(a[i], valueForNoneB);
                }
            }

            if (N.max(lenA, lenB) < len) {
                for (int i = N.max(lenA, lenB); i < len; i++) {
                    result[i] = zipFunction.apply(valueForNoneA, valueForNoneB);
                }
            }

            return result;
        }

        /**
         * A private helper method to zip elements of three 1D arrays into a result array.
         *
         * @param <A> type of first array element
         * @param <B> type of second array element
         * @param <C> type of third array element
         * @param <R> type of result array element
         * @param <E> type of exception
         * @param a first array
         * @param b second array
         * @param c third array
         * @param valueForNoneA default value for first array
         * @param valueForNoneB default value for second array
         * @param valueForNoneC default value for third array
         * @param zipFunction function to combine elements
         * @param len length of the result array
         * @param targetElementType class of the result element type
         * @return a new array of zipped elements
         * @throws E if the zip function fails
         */
        private static <A, B, C, R, E extends Exception> R[] zip(final A[] a, final B[] b, final C[] c, final A valueForNoneA, final B valueForNoneB,
                final C valueForNoneC, final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction, final int len,
                final Class<R> targetElementType) throws E {
            final int lenA = N.len(a);
            final int lenB = N.len(b);
            final int lenC = N.len(c);

            final R[] result = N.newArray(targetElementType, len);

            for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
                result[i] = zipFunction.apply(a[i], b[i], c[i]);
            }

            if (N.min(lenA, lenB, lenC) < len) {
                for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                    result[i] = zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
                }
            }

            return result;
        }

        /**
         * Zips two 2D arrays together using a binary function. The resulting array will have a length
         * equal to the minimum of the lengths of the input arrays. Each sub-array's length will be
         * the minimum of the corresponding sub-arrays in the input arrays.
         *
         * <pre><code>
         * Integer[][] a = {{1, 2, 3}, {4, 5}};
         * String[][] b = {{"a", "b"}, {"c", "d", "e"}};
         * String[][] result = ff.zip(a, b, (i, s) -> i + s, String.class);
         * // result is {{"1a", "2b"}, {"4c", "5d"}}
         * </code></pre>
         *
         * @param <A> The element type of the first array.
         * @param <B> The element type of the second array.
         * @param <E> The exception type thrown by the zip function.
         * @param a The first 2D array.
         * @param b The second 2D array.
         * @param zipFunction The function to combine elements from the input arrays.
         * @return A new 2D array of type A.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, E extends Exception> A[][] zip(final A[][] a, final B[][] b, final Throwables.BiFunction<? super A, ? super B, A, E> zipFunction)
                throws E {
            return zip(a, b, zipFunction, (Class<A>) a.getClass().getComponentType().getComponentType());
        }

        /**
         * Zips two 2D arrays together into a new 2D array of a specified type. The resulting array will have a length
         * equal to the minimum of the lengths of the input arrays. Each sub-array's length will be
         * the minimum of the corresponding sub-arrays in the input arrays.
         *
         * <pre><code>
         * Integer[][] a = {{1, 2, 3}, {4, 5}};
         * String[][] b = {{"a", "b"}, {"c", "d", "e"}};
         * String[][] result = ff.zip(a, b, (i, s) -> i + s, String.class);
         * // result is {{"1a", "2b"}, {"4c", "5d"}}
         * </code></pre>
         *
         * @param <A> The element type of the first array.
         * @param <B> The element type of the second array.
         * @param <R> The element type of the resulting array.
         * @param <E> The exception type thrown by the zip function.
         * @param a The first 2D array.
         * @param b The second 2D array.
         * @param zipFunction The function to combine elements from the input arrays.
         * @param targetElementType The class of the resulting array's element type.
         * @return A new 2D array of type R.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, R, E extends Exception> R[][] zip(final A[][] a, final B[][] b,
                final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E {
            final int lenA = N.len(a);
            final int lenB = N.len(b);

            final R[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), N.min(lenA, lenB));

            for (int i = 0, len = result.length; i < len; i++) {
                final A[] aa = a[i];
                final B[] bb = b[i];
                final int minLen = N.min(N.len(aa), N.len(bb));
                final R[] ret = N.newArray(targetElementType, minLen);

                for (int j = 0; j < minLen; j++) {
                    ret[j] = zipFunction.apply(aa[j], bb[j]);
                }

                result[i] = ret;
            }

            return result;
        }

        /**
         * Zips two 2D arrays together using a binary function, providing default values for missing elements.
         * The resulting array's dimensions will match the maximum dimensions of the input arrays.
         *
         * <pre><code>
         * Integer[][] a = {{1}, {2, 3}};
         * Integer[][] b = {{10, 20}, {30}};
         * Integer[][] result = ff.zip(a, b, -1, -1, (x, y) -> x + y);
         * // result is {{11, 19}, {32, 2}}
         * </code></pre>
         *
         * @param <A> The element type of the first array and the result.
         * @param <B> The element type of the second array.
         * @param <E> The exception type thrown by the zip function.
         * @param a The first 2D array.
         * @param b The second 2D array.
         * @param valueForNoneA The default value for the first array if an element is missing.
         * @param valueForNoneB The default value for the second array if an element is missing.
         * @param zipFunction The function to combine elements.
         * @return A new 2D array of type A.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, E extends Exception> A[][] zip(final A[][] a, final B[][] b, final A valueForNoneA, final B valueForNoneB,
                final Throwables.BiFunction<? super A, ? super B, A, E> zipFunction) throws E {
            return zip(a, b, valueForNoneA, valueForNoneB, zipFunction, (Class<A>) a.getClass().getComponentType().getComponentType());
        }

        /**
         * Zips two 2D arrays together into a new 2D array of a specified type, providing default values for missing elements.
         * The resulting array's dimensions will match the maximum dimensions of the input arrays.
         *
         * <pre><code>
         * Integer[][] a = {{1}, {2, 3}};
         * String[][] b = {{"a", "b"}, {"c"}};
         * String[][] result = ff.zip(a, b, 0, "z", (i, s) -> i + s, String.class);
         * // result is {{"1a", "0b"}, {"2c", "3z"}}
         * </code></pre>
         *
         * @param <A> The element type of the first array.
         * @param <B> The element type of the second array.
         * @param <R> The element type of the resulting array.
         * @param <E> The exception type thrown by the zip function.
         * @param a The first 2D array.
         * @param b The second 2D array.
         * @param valueForNoneA The default value for the first array.
         * @param valueForNoneB The default value for the second array.
         * @param zipFunction The function to combine elements.
         * @param targetElementType The class of the resulting array's element type.
         * @return A new 2D array of type R.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, R, E extends Exception> R[][] zip(final A[][] a, final B[][] b, final A valueForNoneA, final B valueForNoneB,
                final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E {
            return zip(a, b, valueForNoneA, valueForNoneB, zipFunction, N.max(N.len(a), N.len(b)), N.max(maxSubArrayLen(a), maxSubArrayLen(b)),
                    targetElementType);
        }

        /**
         * Private helper method for zipping two 2D arrays with default values and specified dimensions.
         *
         * @param <A> The element type of the first array.
         * @param <B> The element type of the second array.
         * @param <R> The element type of the resulting array.
         * @param <E> The exception type.
         * @param a The first 2D array.
         * @param b The second 2D array.
         * @param valueForNoneA Default value for the first array.
         * @param valueForNoneB Default value for the second array.
         * @param zipFunction The zipping function.
         * @param len The desired length of the outer array.
         * @param rowLen The desired length of the inner arrays.
         * @param targetElementType The class of the resulting array's element type.
         * @return A new zipped 2D array.
         * @throws E if the zip function throws an exception.
         */
        private static <A, B, R, E extends Exception> R[][] zip(final A[][] a, final B[][] b, final A valueForNoneA, final B valueForNoneB,
                final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction, final int len, final int rowLen,
                final Class<R> targetElementType) throws E {
            final int lenA = N.len(a);
            final int lenB = N.len(b);

            final R[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), len);

            for (int i = 0, min = N.min(lenA, lenB, len); i < min; i++) {
                result[i] = zip(rowLen, a[i], b[i], valueForNoneA, valueForNoneB, zipFunction, targetElementType);
            }

            if (lenA < lenB && lenA < len) {
                for (int i = lenA, min = N.min(lenB, len); i < min; i++) {
                    result[i] = zip(rowLen, null, b[i], valueForNoneA, valueForNoneB, zipFunction, targetElementType);
                }
            } else if (lenB < lenA && lenB < len) {
                for (int i = lenB, min = N.min(lenA, len); i < min; i++) {
                    result[i] = zip(rowLen, a[i], null, valueForNoneA, valueForNoneB, zipFunction, targetElementType);
                }
            }

            if (N.max(lenA, lenB) < len) {
                for (int i = N.max(lenA, lenB); i < len; i++) {
                    result[i] = zip(rowLen, null, null, valueForNoneA, valueForNoneB, zipFunction, targetElementType);
                }
            }

            return result;
        }

        /**
         * Zips three 2D arrays together using a tri-function. The resulting array dimensions are truncated
         * to the smallest corresponding dimension of the input arrays.
         *
         * <pre><code>
         * Integer[][] a = {{1}};
         * Integer[][] b = {{2, 3}};
         * Integer[][] c = {{4, 5}};
         * Integer[][] result = ff.zip(a, b, c, (x, y, z) -> x + y + z);
         * // result is {{7}}
         * </code></pre>
         *
         * @param <A> The element type of the first array and the result.
         * @param <B> The element type of the second array.
         * @param <C> The element type of the third array.
         * @param <E> The exception type.
         * @param a The first 2D array.
         * @param b The second 2D array.
         * @param c The third 2D array.
         * @param zipFunction The function to combine elements.
         * @return A new 2D array of type A.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, C, E extends Exception> A[][] zip(final A[][] a, final B[][] b, final C[][] c,
                final Throwables.TriFunction<? super A, ? super B, ? super C, A, E> zipFunction) throws E {
            return zip(a, b, c, zipFunction, (Class<A>) a.getClass().getComponentType().getComponentType());
        }

        /**
         * Zips three 2D arrays together into a new 2D array of a specified type. The resulting array dimensions
         * are truncated to the smallest corresponding dimension of the input arrays.
         *
         * <pre><code>
         * Integer[][] a = {{1}};
         * Double[][] b = {{2.0, 3.0}};
         * Long[][] c = {{4L, 5L}};
         * String[][] result = ff.zip(a, b, c, (x, y, z) -> "" + x + y + z, String.class);
         * // result is {{"12.04"}}
         * </code></pre>
         *
         * @param <A> The element type of the first array.
         * @param <B> The element type of the second array.
         * @param <C> The element type of the third array.
         * @param <R> The element type of the resulting array.
         * @param <E> The exception type.
         * @param a The first 2D array.
         * @param b The second 2D array.
         * @param c The third 2D array.
         * @param zipFunction The function to combine elements.
         * @param targetElementType The class of the resulting array's element type.
         * @return A new 2D array of type R.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, C, R, E extends Exception> R[][] zip(final A[][] a, final B[][] b, final C[][] c,
                final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E {
            final int lenA = N.len(a);
            final int lenB = N.len(b);
            final int lenC = N.len(c);

            final R[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), N.min(lenA, lenB, lenC));

            for (int i = 0, len = result.length; i < len; i++) {
                final A[] aa = a[i];
                final B[] bb = b[i];
                final C[] cc = c[i];
                final int minLen = N.min(N.len(aa), N.len(bb), N.len(cc));
                final R[] ret = N.newArray(targetElementType, minLen);

                for (int j = 0; j < minLen; j++) {
                    ret[j] = zipFunction.apply(aa[j], bb[j], cc[j]);
                }

                result[i] = ret;
            }

            return result;
        }

        /**
         * Zips three 2D arrays together, providing default values for missing elements. The resulting array's
         * dimensions will match the maximum dimensions of the input arrays.
         *
         * <pre><code>
         * Integer[][] a = {{1}, {2}};
         * Integer[][] b = {{10, 20}};
         * Integer[][] c = {{100}, {200, 300}};
         * Integer[][] result = ff.zip(a, b, c, -1, -1, -1, (x, y, z) -> x + y + z);
         * // result is {{110, 18}, {201, 298}}
         * </code></pre>
         *
         * @param <A> The element type of the arrays and the result.
         * @param <B> The element type of the second array.
         * @param <C> The element type of the third array.
         * @param <E> The exception type.
         * @param a The first 2D array.
         * @param b The second 2D array.
         * @param c The third 2D array.
         * @param valueForNoneA Default value for the first array.
         * @param valueForNoneB Default value for the second array.
         * @param valueForNoneC Default value for the third array.
         * @param zipFunction The function to combine elements.
         * @return A new 2D array of type A.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, C, E extends Exception> A[][] zip(final A[][] a, final B[][] b, final C[][] c, final A valueForNoneA, final B valueForNoneB,
                final C valueForNoneC, final Throwables.TriFunction<? super A, ? super B, ? super C, A, E> zipFunction) throws E {
            return zip(a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction, (Class<A>) a.getClass().getComponentType().getComponentType());
        }

        /**
         * Zips three 2D arrays into a new 2D array of a specified type, with default values for missing elements.
         * The resulting array's dimensions will match the maximum dimensions of the input arrays.
         *
         * <pre><code>
         * Integer[][] a = {{1}};
         * String[][] b = {{"a", "b"}};
         * Double[][] c = {{1.1, 2.2}, {3.3}};
         * String[][] result = ff.zip(a, b, c, 0, "z", 0.0, (i, s, d) -> i + s + d, String.class);
         * // result is {{"1a1.1", "0b2.2"}, {"0z3.3"}}
         * </code></pre>
         *
         * @param <A> The element type of the first array.
         * @param <B> The element type of the second array.
         * @param <C> The element type of the third array.
         * @param <R> The element type of the resulting array.
         * @param <E> The exception type.
         * @param a The first 2D array.
         * @param b The second 2D array.
         * @param c The third 2D array.
         * @param valueForNoneA Default value for the first array.
         * @param valueForNoneB Default value for the second array.
         * @param valueForNoneC Default value for the third array.
         * @param zipFunction The function to combine elements.
         * @param targetElementType The class of the resulting array's element type.
         * @return A new 2D array of type R.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, C, R, E extends Exception> R[][] zip(final A[][] a, final B[][] b, final C[][] c, final A valueForNoneA, final B valueForNoneB,
                final C valueForNoneC, final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction,
                final Class<R> targetElementType) throws E {
            return zip(a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction, N.max(N.len(a), N.len(b), N.len(c)),
                    N.max(maxSubArrayLen(a), maxSubArrayLen(b), maxSubArrayLen(c)), targetElementType);
        }

        /**
         * Private helper method for zipping three 2D arrays with default values and specified dimensions.
         *
         * @param <A> The element type of the first array.
         * @param <B> The element type of the second array.
         * @param <C> The element type of the third array.
         * @param <R> The element type of the resulting array.
         * @param <E> The exception type.
         * @param a The first 2D array.
         * @param b The second 2D array.
         * @param c The third 2D array.
         * @param valueForNoneA Default value for the first array.
         * @param valueForNoneB Default value for the second array.
         * @param valueForNoneC Default value for the third array.
         * @param zipFunction The zipping function.
         * @param len The desired length of the outer array.
         * @param rowLen The desired length of the inner arrays.
         * @param targetElementType The class of the resulting array's element type.
         * @return A new zipped 2D array.
         * @throws E if the zip function throws an exception.
         */
        private static <A, B, C, R, E extends Exception> R[][] zip(final A[][] a, final B[][] b, final C[][] c, final A valueForNoneA, final B valueForNoneB,
                final C valueForNoneC, final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction, final int len,
                final int rowLen, final Class<R> targetElementType) throws E {
            final int lenA = N.len(a);
            final int lenB = N.len(b);
            final int lenC = N.len(c);

            final R[][] result = N.newArray(N.newArray(targetElementType, 0).getClass(), len);

            for (int i = 0, min = N.min(lenA, lenB, lenC, len); i < min; i++) {
                result[i] = zip(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction, rowLen, targetElementType);
            }

            if (N.min(lenA, lenB, lenC) < len) {
                for (int i = N.min(lenA, lenB, lenC); i < len; i++) {
                    result[i] = zip(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                            zipFunction, rowLen, targetElementType);
                }
            }

            return result;
        }

        /**
         * Calculates the total number of elements in a two-dimensional array, including elements in jagged arrays.
         * Null sub-arrays are counted as having zero length.
         *
         * <pre><code>
         * Object[][] a = {{1, 2}, {3}, null, {4, 5, 6}};
         * long count = ff.totalCountOfElements(a);
         * // count is 6
         * </code></pre>
         *
         * @param a the two-dimensional array to inspect. Can be {@code null}.
         * @return the total count of all elements in all sub-arrays. Returns 0 if the input array is null or empty.
         */
        public static long totalCountOfElements(final Object[][] a) {
            if (N.isEmpty(a)) {
                return 0;
            }
            long count = 0;

            for (final Object[] element : a) {
                count += (element == null ? 0 : element.length);
            }

            return count;
        }

        /**
         * Finds the minimum length among all sub-arrays in a two-dimensional array.
         * If a sub-array is {@code null}, its length is considered 0.
         *
         * <pre><code>
         * Object[][] a = {{1, 2}, {3}, null, {4, 5, 6}};
         * int minLen = ff.minSubArrayLen(a);
         * // minLen is 0 because of the null sub-array
         * </code></pre>
         *
         * @param a the two-dimensional array to check.
         * @return the minimum sub-array length, or 0 if the array is null or empty.
         */
        public static int minSubArrayLen(final Object[][] a) {
            if (N.isEmpty(a)) {
                return 0;
            }

            int minLen = Integer.MAX_VALUE;

            for (final Object[] ae : a) {
                minLen = N.min(minLen, ae == null ? 0 : ae.length);
            }

            return minLen;
        }

        /**
         * Finds the maximum length among all sub-arrays in a two-dimensional array.
         * If a sub-array is {@code null}, its length is considered 0.
         *
         * <pre><code>
         * Object[][] a = {{1, 2}, {3}, null, {4, 5, 6}};
         * int maxLen = ff.maxSubArrayLen(a);
         * // maxLen is 3
         * </code></pre>
         *
         * @param a the two-dimensional array to check.
         * @return the maximum sub-array length, or 0 if the array is null or empty.
         */
        public static int maxSubArrayLen(final Object[][] a) {
            if (N.isEmpty(a)) {
                return 0;
            }

            int maxLen = 0;

            for (final Object[] ae : a) {
                maxLen = N.max(maxLen, ae == null ? 0 : ae.length);
            }

            return maxLen;
        }

        /**
         * Generates a string representation of a two-dimensional array and prints it to the console.
         * The format is similar to `[[e1, e2], [e3, e4]]`.
         *
         * <pre><code>
         * String[][] a = {{"a", "b"}, {"c", "d"}};
         * ff.println(a);
         * // Prints "[[a, b], [c, d]]" to the console and returns the string.
         * </code></pre>
         *
         * @param a the two-dimensional array to print.
         * @return the string representation of the array.
         */
        static String println(final Object[][] a) {
            if (a == null) {
                return N.println("null");
            } else if (a.length == 0) {
                return N.println("[]");
            } else {
                final int len = a.length;
                final StringBuilder sb = Objectory.createStringBuilder();
                String str = null;
                final String ARRAY_PRINT_SEPARATOR = System.lineSeparator();

                try {
                    sb.append('[');

                    for (int i = 0; i < len; i++) {
                        if (i > 0) {
                            sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                        }

                        if (a[i] == null) {
                            sb.append("null");
                        } else if (a[i].length == 0) {
                            sb.append("[]");
                        } else {
                            final Object[] ai = a[i];
                            sb.append('[');

                            for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                                if (j > 0) {
                                    sb.append(", ");
                                }

                                sb.append(ai[j]);
                            }

                            sb.append(']');
                        }
                    }

                    sb.append(']');
                    str = sb.toString();
                } finally {
                    Objectory.recycle(sb);
                }

                return N.println(str);
            }
        }
    }

    /**
     * A utility class providing methods for functional-style operations on three-dimensional arrays.
     * Operations include updating, replacing, reshaping, flattening, mapping, and zipping.
     * This class is marked with {@code SuppressFBWarnings} for its naming convention.
     */
    @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION")
    public static final class fff { // NOSONAR

        /**
         * Private constructor to prevent instantiation.
         */
        private fff() {
            // Singleton
        }

        /**
         * Updates all elements in the specified three-dimensional array in-place using the given operator.
         * The operator is applied to each element of the nested arrays.
         *
         * <pre><code>
         * String[][][] a = {{{ "a" }}, {{ "b" }}};
         * fff.updateAll(a, str -> str.toUpperCase());
         * // a is now {{{ "A" }}, {{ "B" }}}
         * </code></pre>
         *
         * @param <T> the type of elements in the array.
         * @param <E> the type of exception that may be thrown by the operator.
         * @param a the three-dimensional array to update. The operation is in-place.
         * @param operator the unary operator to apply to each element.
         * @throws E if the operator throws an exception.
         */
        public static <T, E extends Exception> void updateAll(final T[][][] a, final Throwables.UnaryOperator<T, E> operator) throws E {
            if (N.isEmpty(a)) {
                return;
            }

            for (final T[][] element : a) {
                ff.updateAll(element, operator);
            }
        }

        /**
         * Replaces all elements in the specified three-dimensional array that satisfy the given predicate
         * with the provided new value. The replacement happens in-place.
         *
         * <pre><code>
         * Integer[][][] a = {{{1}, {null}}, {{3}}};
         * fff.replaceIf(a, val -> val == null, -1);
         * // a is now {{{1}, {-1}}, {{3}}}
         * </code></pre>
         *
         * @param <T> the type of elements in the array.
         * @param <E> the type of exception that may be thrown by the predicate.
         * @param a the three-dimensional array to modify.
         * @param predicate the condition to test for each element.
         * @param newValue the value to be placed in the array if the predicate is true.
         * @throws E if the predicate throws an exception.
         */
        public static <T, E extends Exception> void replaceIf(final T[][][] a, final Throwables.Predicate<? super T, E> predicate, final T newValue) throws E {
            if (N.isEmpty(a)) {
                return;
            }

            for (final T[][] element : a) {
                ff.replaceIf(element, predicate, newValue);
            }
        }

        /**
         * Reshapes a one-dimensional array into a three-dimensional array with the specified
         * number of rows and columns for the inner matrices.
         *
         * <pre><code>
         * Integer[] a = {1, 2, 3, 4, 5, 6, 7};
         * Integer[][][] result = fff.reshape(a, 2, 2);
         * // result is {{{1, 2}, {3, 4}}, {{5, 6}, {7}}}
         * </code></pre>
         *
         * @param <T> the type of the elements in the array.
         * @param a the one-dimensional array to be reshaped.
         * @param rows the number of rows for the inner 2D arrays.
         * @param cols the number of columns for the inner 2D arrays.
         * @return a three-dimensional array.
         * @throws IllegalArgumentException if rows or cols are not positive.
         */
        public static <T> T[][][] reshape(final T[] a, final int rows, final int cols) throws IllegalArgumentException {
            N.checkArgNotNull(a, "a");
            N.checkArgument(rows > 0 && cols > 0, "'rows' and 'cols' must be positive numbers: rows = %s, cols = %s", rows, cols);

            //        if (N.isEmpty(a)) {
            //            return new T[0][0][0];
            //        }

            final int len = a.length;
            final int n = Numbers.divide(len, rows * cols, RoundingMode.CEILING);
            final T[][][] c = N.newArray(N.newArray((Class<T[]>) a.getClass(), 0).getClass(), n);

            for (int i = 0, from = 0; i < n; i++) {
                c[i] = N.newArray((Class<T[]>) a.getClass(), N.min(rows, Numbers.divide(len - from, cols, RoundingMode.CEILING)));

                for (int j = 0, y = c[i].length; j < y; j++, from += cols) {
                    c[i][j] = N.copyOfRange(a, from, from + N.min(len - from, cols));
                }
            }

            return c;
        }

        /**
         * Flattens a three-dimensional array into a one-dimensional array.
         * Elements are concatenated in the order they appear.
         *
         * <pre><code>
         * Integer[][][] a = {{{1, 2}}, {{3}}, {{4, 5, 6}}};
         * Integer[] result = fff.flatten(a);
         * // result is {1, 2, 3, 4, 5, 6}
         * </code></pre>
         *
         * @param <T> the component type of the array.
         * @param a the three-dimensional array to flatten.
         * @return a new one-dimensional array containing all elements from the input array.
         */
        public static <T> T[] flatten(final T[][][] a) {
            final int count = Numbers.toIntExact(totalCountOfElements(a));

            final T[] c = N.newArray((Class<T>) a.getClass().getComponentType().getComponentType().getComponentType(), count);
            int from = 0;

            for (final T[][] element : a) {
                if (N.isEmpty(element)) {
                    continue;
                }

                for (final T[] ts : element) {
                    if (N.isEmpty(ts)) {
                        continue;
                    }

                    N.copy(ts, 0, c, from, ts.length);

                    from += ts.length;
                }
            }

            return c;
        }

        /**
         * Flattens a three-dimensional array, applies an operation to the resulting one-dimensional array,
         * and then copies the modified elements back into the original three-dimensional array.
         * This is useful for performing array-wide operations like sorting.
         *
         * <pre><code>
         * Integer[][][] a = {{{3}, {1}}, {{4}, {2}}};
         * fff.flatOp(a, arr -> java.util.Arrays.sort(arr));
         * // a is now {{{1}, {2}}, {{3}, {4}}}
         * </code></pre>
         *
         * @param <T> the type of elements in the array.
         * @param <E> the type of exception that may be thrown by the operation.
         * @param a the three-dimensional array to operate on. The operation is in-place.
         * @param op the consumer to accept the flattened array.
         * @throws E if the operation throws an exception.
         */
        public static <T, E extends Exception> void flatOp(final T[][][] a, final Throwables.Consumer<? super T[], E> op) throws E {
            if (N.isEmpty(a)) {
                return;
            }

            final T[] tmp = flatten(a);

            op.accept(tmp);

            int idx = 0;

            for (final T[][] e : a) {
                if (N.notEmpty(e)) {
                    for (final T[] ee : e) {
                        if (N.notEmpty(ee)) {
                            N.copy(tmp, idx, ee, 0, ee.length);
                            idx += ee.length;
                        }
                    }
                }
            }
        }

        /**
         * Maps a three-dimensional array to a new three-dimensional array by applying a function to each element.
         * The structure of the array is preserved.
         *
         * <pre><code>
         * Integer[][][] a = {{{1}}, {{2}}};
         * String[][][] result = fff.map(a, String::valueOf);
         * // result is {{{ "1" }}, {{ "2" }}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source three-dimensional array.
         * @param func the unary operator to apply to each element.
         * @return a new three-dimensional array with the mapped elements.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> T[][][] map(final T[][][] a, final Throwables.UnaryOperator<T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            return map(a, func, (Class<T>) a.getClass().getComponentType().getComponentType().getComponentType());
        }

        /**
         * Maps a three-dimensional array of type {@code T} to a new three-dimensional array of type {@code R}
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][][] a = {{{ "1" }}, {{ "2" }}};
         * Integer[][][] result = fff.map(a, Integer::parseInt, Integer.class);
         * // result is {{{1}}, {{2}}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <R> the type of elements in the resulting array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source three-dimensional array.
         * @param func the function to apply to each element.
         * @param targetElementType the class object for the element type of the resulting array.
         * @return a new three-dimensional array with the mapped elements.
         * @throws E if the function throws an exception.
         */
        public static <T, R, E extends Exception> R[][][] map(final T[][][] a, final Throwables.Function<? super T, ? extends R, E> func,
                final Class<R> targetElementType) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final R[][][] c = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), len);

            for (int i = 0; i < len; i++) {
                c[i] = ff.map(a[i], func, targetElementType);
            }

            return c;
        }

        /**
         * Maps a three-dimensional array of a generic type {@code T} to a three-dimensional {@code boolean} array
         * by applying a predicate to each element.
         *
         * <pre><code>
         * Integer[][][] a = {{{0, 1}}, {{-1, 2}}};
         * boolean[][][] result = fff.mapToBoolean(a, x -> x > 0);
         * // result is {{{false, true}}, {{false, true}}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source three-dimensional array.
         * @param func the predicate to apply to each element.
         * @return a new three-dimensional {@code boolean} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> boolean[][][] mapToBoolean(final T[][][] a, final Throwables.ToBooleanFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final boolean[][][] c = new boolean[len][][];

            for (int i = 0; i < len; i++) {
                c[i] = ff.mapToBoolean(a[i], func);
            }

            return c;
        }

        /**
         * Maps a three-dimensional array of a generic type {@code T} to a three-dimensional {@code char} array
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][][] a = {{{"a"}}, {{"b"}, {"c"}}};
         * char[][][] result = fff.mapToChar(a, s -> s.charAt(0));
         * // result is {{{'a'}}, {{'b'}, {'c'}}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source three-dimensional array.
         * @param func the function to apply to each element.
         * @return a new three-dimensional {@code char} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> char[][][] mapToChar(final T[][][] a, final Throwables.ToCharFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final char[][][] c = new char[len][][];

            for (int i = 0; i < len; i++) {
                c[i] = ff.mapToChar(a[i], func);
            }

            return c;
        }

        /**
         * Maps a three-dimensional array of a generic type {@code T} to a three-dimensional {@code byte} array
         * by applying a function to each element.
         *
         * <pre><code>
         * Integer[][][] a = {{{10}}, {{20}, {30}}};
         * byte[][][] result = fff.mapToByte(a, x -> x.byteValue());
         * // result is {{{10}}, {{20}, {30}}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source three-dimensional array.
         * @param func the function to apply to each element.
         * @return a new three-dimensional {@code byte} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> byte[][][] mapToByte(final T[][][] a, final Throwables.ToByteFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final byte[][][] c = new byte[len][][];

            for (int i = 0; i < len; i++) {
                c[i] = ff.mapToByte(a[i], func);
            }

            return c;
        }

        /**
         * Maps a three-dimensional array of a generic type {@code T} to a three-dimensional {@code short} array
         * by applying a function to each element.
         *
         * <pre><code>
         * Integer[][][] a = {{{10}}, {{20}, {30}}};
         * short[][][] result = fff.mapToShort(a, x -> x.shortValue());
         * // result is {{{10}}, {{20}, {30}}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source three-dimensional array.
         * @param func the function to apply to each element.
         * @return a new three-dimensional {@code short} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> short[][][] mapToShort(final T[][][] a, final Throwables.ToShortFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final short[][][] c = new short[len][][];

            for (int i = 0; i < len; i++) {
                c[i] = ff.mapToShort(a[i], func);
            }

            return c;
        }

        /**
         * Maps a three-dimensional array of a generic type {@code T} to a three-dimensional {@code int} array
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][][] a = {{{"1"}}, {{"2"}, {"3"}}};
         * int[][][] result = fff.mapToInt(a, Integer::parseInt);
         * // result is {{{1}}, {{2}, {3}}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source three-dimensional array.
         * @param func the function to apply to each element.
         * @return a new three-dimensional {@code int} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> int[][][] mapToInt(final T[][][] a, final Throwables.ToIntFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final int[][][] c = new int[len][][];

            for (int i = 0; i < len; i++) {
                c[i] = ff.mapToInt(a[i], func);
            }

            return c;
        }

        /**
         * Maps a three-dimensional array of a generic type {@code T} to a three-dimensional {@code long} array
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][][] a = {{{"1"}}, {{"2"}, {"3"}}};
         * long[][][] result = fff.mapToLong(a, Long::parseLong);
         * // result is {{{1L}}, {{2L}, {3L}}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source three-dimensional array.
         * @param func the function to apply to each element.
         * @return a new three-dimensional {@code long} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> long[][][] mapToLong(final T[][][] a, final Throwables.ToLongFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final long[][][] c = new long[len][][];

            for (int i = 0; i < len; i++) {
                c[i] = ff.mapToLong(a[i], func);
            }

            return c;
        }

        /**
         * Maps a three-dimensional array of a generic type {@code T} to a three-dimensional {@code float} array
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][][] a = {{{"1.1"}}, {{"2.2"}, {"3.3"}}};
         * float[][][] result = fff.mapToFloat(a, Float::parseFloat);
         * // result is {{{1.1f}}, {{2.2f}, {3.3f}}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source three-dimensional array.
         * @param func the function to apply to each element.
         * @return a new three-dimensional {@code float} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> float[][][] mapToFloat(final T[][][] a, final Throwables.ToFloatFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final float[][][] c = new float[len][][];

            for (int i = 0; i < len; i++) {
                c[i] = ff.mapToFloat(a[i], func);
            }

            return c;
        }

        /**
         * Maps a three-dimensional array of a generic type {@code T} to a three-dimensional {@code double} array
         * by applying a function to each element.
         *
         * <pre><code>
         * String[][][] a = {{{"1.1"}}, {{"2.2"}, {"3.3"}}};
         * double[][][] result = fff.mapToDouble(a, Double::parseDouble);
         * // result is {{{1.1}}, {{2.2}, {3.3}}}
         * </code></pre>
         *
         * @param <T> the type of elements in the source array.
         * @param <E> the type of exception that may be thrown by the function.
         * @param a the source three-dimensional array.
         * @param func the function to apply to each element.
         * @return a new three-dimensional {@code double} array.
         * @throws E if the function throws an exception.
         */
        public static <T, E extends Exception> double[][][] mapToDouble(final T[][][] a, final Throwables.ToDoubleFunction<? super T, E> func) throws E {
            if (a == null) {
                return null; // NOSONAR
            }

            final int len = N.len(a);
            final double[][][] c = new double[len][][];

            for (int i = 0; i < len; i++) {
                c[i] = ff.mapToDouble(a[i], func);
            }

            return c;
        }

        /**
         * Zips two 3D arrays together using a binary function. The resulting array dimensions are truncated
         * to the smallest corresponding dimension of the input arrays.
         *
         * <pre><code>
         * Integer[][][] a = {{{1}, {2}}};
         * Integer[][][] b = {{{10}}};
         * Integer[][][] result = fff.zip(a, b, (x, y) -> x + y);
         * // result is {{{11}}}
         * </code></pre>
         *
         * @param <A> The element type of the arrays and the result.
         * @param <B> The element type of the second array.
         * @param <E> The exception type.
         * @param a The first 3D array.
         * @param b The second 3D array.
         * @param zipFunction The function to combine elements.
         * @return A new 3D array of type A.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, E extends Exception> A[][][] zip(final A[][][] a, final B[][][] b,
                final Throwables.BiFunction<? super A, ? super B, A, E> zipFunction) throws E {
            return zip(a, b, zipFunction, (Class<A>) a.getClass().getComponentType().getComponentType().getComponentType());
        }

        /**
         * Zips two 3D arrays together into a new 3D array of a specified type. The resulting array dimensions
         * are truncated to the smallest corresponding dimension of the input arrays.
         *
         * <pre><code>
         * Integer[][][] a = {{{1}}};
         * String[][][] b = {{{"a"}}};
         * String[][][] result = fff.zip(a, b, (i, s) -> i + s, String.class);
         * // result is {{{ "1a" }}}
         * </code></pre>
         *
         * @param <A> The element type of the first array.
         * @param <B> The element type of the second array.
         * @param <R> The element type of the resulting array.
         * @param <E> The exception type.
         * @param a The first 3D array.
         * @param b The second 3D array.
         * @param zipFunction The function to combine elements.
         * @param targetElementType The class of the resulting array's element type.
         * @return A new 3D array of type R.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, R, E extends Exception> R[][][] zip(final A[][][] a, final B[][][] b,
                final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E {
            final int lenA = N.len(a);
            final int lenB = N.len(b);

            final R[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), N.min(lenA, lenB));

            for (int i = 0, len = result.length; i < len; i++) {
                result[i] = ff.zip(a[i], b[i], zipFunction, targetElementType);
            }

            return result;
        }

        /**
         * Zips two 3D arrays together, providing default values for missing elements. The resulting array's
         * dimensions will match the maximum dimensions of the input arrays.
         *
         * <pre><code>
         * Integer[][][] a = {{{1}}, {{2}}};
         * Integer[][][] b = {{{10, 20}}};
         * Integer[][][] result = fff.zip(a, b, -1, -1, (x, y) -> x + y);
         * // result is {{{11, 19}}, {{1, -2}}}
         * </code></pre>
         *
         * @param <A> The element type of the arrays and the result.
         * @param <B> The element type of the second array.
         * @param <E> The exception type.
         * @param a The first 3D array.
         * @param b The second 3D array.
         * @param valueForNoneA Default value for the first array.
         * @param valueForNoneB Default value for the second array.
         * @param zipFunction The function to combine elements.
         * @return A new 3D array of type A.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, E extends Exception> A[][][] zip(final A[][][] a, final B[][][] b, final A valueForNoneA, final B valueForNoneB,
                final Throwables.BiFunction<? super A, ? super B, A, E> zipFunction) throws E {
            return zip(a, b, valueForNoneA, valueForNoneB, zipFunction, (Class<A>) a.getClass().getComponentType().getComponentType().getComponentType());
        }

        /**
         * Zips two 3D arrays into a new 3D array of a specified type, with default values for missing elements.
         * The resulting array's dimensions will match the maximum dimensions of the input arrays.
         *
         * <pre><code>
         * Integer[][][] a = {{{1}}};
         * String[][][] b = {{{"a", "b"}}, {{"c"}}};
         * String[][][] result = fff.zip(a, b, 0, "z", (i, s) -> i + s, String.class);
         * // result is {{{ "1a", "0b"}}, {{ "0z"}}}
         * </code></pre>
         *
         * @param <A> The element type of the first array.
         * @param <B> The element type of the second array.
         * @param <R> The element type of the resulting array.
         * @param <E> The exception type.
         * @param a The first 3D array.
         * @param b The second 3D array.
         * @param valueForNoneA Default value for the first array.
         * @param valueForNoneB Default value for the second array.
         * @param zipFunction The function to combine elements.
         * @param targetElementType The class of the resulting array's element type.
         * @return A new 3D array of type R.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, R, E extends Exception> R[][][] zip(final A[][][] a, final B[][][] b, final A valueForNoneA, final B valueForNoneB,
                final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E {
            final int lenA = N.len(a);
            final int lenB = N.len(b);

            final R[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), N.max(lenA, lenB));

            for (int i = 0, min = N.min(lenA, lenB); i < min; i++) {
                result[i] = ff.zip(a[i], b[i], valueForNoneA, valueForNoneB, zipFunction, targetElementType);
            }

            if (lenA < lenB) {
                for (int i = lenA; i < lenB; i++) {
                    result[i] = ff.zip(null, b[i], valueForNoneA, valueForNoneB, zipFunction, targetElementType);
                }
            } else if (lenB < lenA) {
                for (int i = lenB; i < lenA; i++) {
                    result[i] = ff.zip(a[i], null, valueForNoneA, valueForNoneB, zipFunction, targetElementType);
                }
            }

            return result;
        }

        /**
         * Zips three 3D arrays together using a tri-function. The resulting array dimensions are truncated
         * to the smallest corresponding dimension of the input arrays.
         *
         * <pre><code>
         * Integer[][][] a = {{{1}}};
         * Integer[][][] b = {{{2}, {3}}};
         * Integer[][][] c = {{{4}}};
         * Integer[][][] result = fff.zip(a, b, c, (x, y, z) -> x + y + z);
         * // result is {{{7}}}
         * </code></pre>
         *
         * @param <A> The element type of the arrays and the result.
         * @param <B> The element type of the second array.
         * @param <C> The element type of the third array.
         * @param <E> The exception type.
         * @param a The first 3D array.
         * @param b The second 3D array.
         * @param c The third 3D array.
         * @param zipFunction The function to combine elements.
         * @return A new 3D array of type A.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, C, E extends Exception> A[][][] zip(final A[][][] a, final B[][][] b, final C[][][] c,
                final Throwables.TriFunction<? super A, ? super B, ? super C, A, E> zipFunction) throws E {
            return zip(a, b, c, zipFunction, (Class<A>) a.getClass().getComponentType().getComponentType().getComponentType());
        }

        /**
         * Zips three 3D arrays together into a new 3D array of a specified type. The resulting array dimensions
         * are truncated to the smallest corresponding dimension of the input arrays.
         *
         * <pre><code>
         * Integer[][][] a = {{{1}}};
         * String[][][] b = {{{"a"}}};
         * Double[][][] c = {{{2.2}}};
         * String[][][] result = fff.zip(a, b, c, (i, s, d) -> i + s + d, String.class);
         * // result is {{{ "1a2.2" }}}
         * </code></pre>
         *
         * @param <A> The element type of the first array.
         * @param <B> The element type of the second array.
         * @param <C> The element type of the third array.
         * @param <R> The element type of the resulting array.
         * @param <E> The exception type.
         * @param a The first 3D array.
         * @param b The second 3D array.
         * @param c The third 3D array.
         * @param zipFunction The function to combine elements.
         * @param targetElementType The class of the resulting array's element type.
         * @return A new 3D array of type R.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, C, R, E extends Exception> R[][][] zip(final A[][][] a, final B[][][] b, final C[][][] c,
                final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E {
            final int lenA = N.len(a);
            final int lenB = N.len(b);
            final int lenC = N.len(c);

            final R[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), N.min(lenA, lenB, lenC));

            for (int i = 0, len = result.length; i < len; i++) {
                result[i] = ff.zip(a[i], b[i], c[i], zipFunction, targetElementType);
            }

            return result;
        }

        /**
         * Zips three 3D arrays together, providing default values for missing elements. The resulting array's
         * dimensions will match the maximum dimensions of the input arrays.
         *
         * <pre><code>
         * Integer[][][] a = {{{1}}};
         * Integer[][][] b = {{{10, 20}}};
         * Integer[][][] c = {{{}, {100}}};
         * Integer[][][] result = fff.zip(a, b, c, -1, -1, -1, (x, y, z) -> x + y + z);
         * // result is {{{10, 18}}, {{-3, 98}}}
         * </code></pre>
         *
         * @param <A> The element type of the arrays and the result.
         * @param <B> The element type of the second array.
         * @param <C> The element type of the third array.
         * @param <E> The exception type.
         * @param a The first 3D array.
         * @param b The second 3D array.
         * @param c The third 3D array.
         * @param valueForNoneA Default value for the first array.
         * @param valueForNoneB Default value for the second array.
         * @param valueForNoneC Default value for the third array.
         * @param zipFunction The function to combine elements.
         * @return A new 3D array of type A.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, C, E extends Exception> A[][][] zip(final A[][][] a, final B[][][] b, final C[][][] c, final A valueForNoneA,
                final B valueForNoneB, final C valueForNoneC, final Throwables.TriFunction<? super A, ? super B, ? super C, A, E> zipFunction) throws E {
            return zip(a, b, c, valueForNoneA, valueForNoneB, valueForNoneC, zipFunction,
                    (Class<A>) a.getClass().getComponentType().getComponentType().getComponentType());
        }

        /**
         * Zips three 3D arrays into a new 3D array of a specified type, with default values for missing elements.
         * The resulting array's dimensions will match the maximum dimensions of the input arrays.
         *
         * <pre><code>
         * Integer[][][] a = {{{1}}};
         * String[][][] b = {{{"a", "b"}}};
         * Double[][][] c = {{{1.1}}, {{2.2}}};
         * String[][][] result = fff.zip(a, b, c, 0, "z", 0.0, (i, s, d) -> "" + i + s + d, String.class);
         * // result is {{{ "1a1.1", "0b0.0"}}, {{ "0z2.2"}}}
         * </code></pre>
         *
         * @param <A> The element type of the first array.
         * @param <B> The element type of the second array.
         * @param <C> The element type of the third array.
         * @param <R> The element type of the resulting array.
         * @param <E> The exception type.
         * @param a The first 3D array.
         * @param b The second 3D array.
         * @param c The third 3D array.
         * @param valueForNoneA Default value for the first array.
         * @param valueForNoneB Default value for the second array.
         * @param valueForNoneC Default value for the third array.
         * @param zipFunction The function to combine elements.
         * @param targetElementType The class of the resulting array's element type.
         * @return A new 3D array of type R.
         * @throws E if the zip function throws an exception.
         */
        public static <A, B, C, R, E extends Exception> R[][][] zip(final A[][][] a, final B[][][] b, final C[][][] c, final A valueForNoneA,
                final B valueForNoneB, final C valueForNoneC, final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction,
                final Class<R> targetElementType) throws E {
            final int lenA = N.len(a);
            final int lenB = N.len(b);
            final int lenC = N.len(c);

            final R[][][] result = N.newArray(N.newArray(N.newArray(targetElementType, 0).getClass(), 0).getClass(), N.max(lenA, lenB, lenC));

            for (int i = 0, min = N.min(lenA, lenB, lenC); i < min; i++) {
                result[i] = ff.zip(a[i], b[i], c[i], valueForNoneA, valueForNoneB, valueForNoneC, zipFunction, targetElementType);
            }

            for (int i = N.min(lenA, lenB, lenC), len = result.length; i < len; i++) {
                result[i] = ff.zip(i < lenA ? a[i] : null, i < lenB ? b[i] : null, i < lenC ? c[i] : null, valueForNoneA, valueForNoneB, valueForNoneC,
                        zipFunction, targetElementType);
            }

            return result;
        }

        /**
         * Calculates the total number of elements in a three-dimensional array.
         * This method correctly handles jagged and null inner arrays.
         *
         * <pre><code>
         * Object[][][] a = {{{1}, {2, 3}}, null, {{{4, 5}, {6}}}};
         * long count = fff.totalCountOfElements(a);
         * // count is 6
         * </code></pre>
         *
         * @param a the three-dimensional array to inspect.
         * @return the total count of all elements. Returns 0 if the array is null or empty.
         */
        public static long totalCountOfElements(final Object[][][] a) {
            if (N.isEmpty(a)) {
                return 0;
            }
            long count = 0;

            for (final Object[][] element : a) {
                if (N.isEmpty(element)) {
                    continue;
                }

                for (final Object[] ts : element) {
                    if (N.isEmpty(ts)) {
                        continue;
                    }

                    count += ts.length;
                }
            }

            return count;
        }

        /**
         * Generates a string representation of a three-dimensional array and prints it to the console.
         * The format is structured with newlines for readability between 2D slices.
         *
         * <pre><code>
         * String[][][] a = {{{ "a" }}, {{ "b", "c" }}};
         * fff.println(a);
         * // Prints a formatted string representation to the console and returns it.
         * </code></pre>
         *
         * @param a the three-dimensional array to print.
         * @return the string representation of the array.
         */
        static String println(final Object[][][] a) {
            if (a == null) {
                return N.println("null");
            } else if (a.length == 0) {
                return N.println("[]");
            } else {
                final int len = a.length;
                final StringBuilder sb = Objectory.createStringBuilder();
                String str = null;
                final String ARRAY_PRINT_SEPARATOR = System.lineSeparator();

                try {
                    sb.append('[');

                    for (int i = 0; i < len; i++) {
                        if (i > 0) {
                            sb.append(',').append(ARRAY_PRINT_SEPARATOR).append(' ');
                        }

                        if (a[i] == null) {
                            sb.append("null");
                        } else if (a[i].length == 0) {
                            sb.append("[]");
                        } else {
                            final Object[][] ai = a[i];
                            sb.append('[');

                            for (int j = 0, aiLen = ai.length; j < aiLen; j++) {
                                if (j > 0) {
                                    sb.append(',').append(IOUtil.LINE_SEPARATOR).append("  ");
                                }

                                if (ai[j] == null) {
                                    sb.append("null");
                                } else if (ai[j].length == 0) {
                                    sb.append("[]");
                                } else {
                                    final Object[] aij = ai[j];
                                    sb.append('[');

                                    for (int k = 0, aijLen = aij.length; k < aijLen; k++) {
                                        if (k > 0) {
                                            sb.append(", ");
                                        }

                                        sb.append(aij[k]);
                                    }

                                    sb.append(']');
                                }
                            }

                            sb.append(']');
                        }
                    }

                    sb.append(']');
                    str = sb.toString();
                } finally {
                    Objectory.recycle(sb);
                }

                N.println(str);

                return str;
            }
        }
    }
}
