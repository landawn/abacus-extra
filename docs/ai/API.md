# abacus-extra API Index (v3.3.1)
- Build: unknown
- Java: 17
- Generated: 2026-02-08

## Packages
- com.landawn.abacus.util

## com.landawn.abacus.util
### Class AbstractMatrix (com.landawn.abacus.util.AbstractMatrix)
A comprehensive abstract base class providing the foundational architecture for all matrix implementations in the Abacus library.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### componentType(...) -> Class
- **Signature:** `@SuppressWarnings("rawtypes") public abstract Class componentType()`
- **Summary:** Returns the component type of the elements in this matrix.
- **Parameters:**
  - (none)
- **Returns:** the Class object representing the component type of matrix elements
##### array(...) -> A\[\]
- **Signature:** `@SuppressFBWarnings("EI_EXPOSE_REP") public A[] array()`
- **Summary:** Returns the underlying two-dimensional array of this matrix.
- **Contract:**
  - This method exposes the internal array representation for performance reasons and should be used with caution as modifications to the returned array will directly affect the matrix.
  - If you need an independent copy, use {@link #copy()} instead.
- **Parameters:**
  - (none)
- **Returns:** the underlying two-dimensional array (not a copy)
##### rowCount(...) -> int
- **Signature:** `public int rowCount()`
- **Summary:** Returns the number of rows in this matrix.
- **Parameters:**
  - (none)
- **Returns:** the number of rows
##### columnCount(...) -> int
- **Signature:** `public int columnCount()`
- **Summary:** Returns the number of columns in this matrix.
- **Parameters:**
  - (none)
- **Returns:** the number of columns
##### elementCount(...) -> long
- **Signature:** `public long elementCount()`
- **Summary:** Returns the total number of elements in this matrix (rows × columns).
- **Parameters:**
  - (none)
- **Returns:** the total number of elements
##### isEmpty(...) -> boolean
- **Signature:** `public boolean isEmpty()`
- **Summary:** Checks if the matrix is empty (contains no elements).
- **Contract:**
  - Checks if the matrix is empty (contains no elements).
  - A matrix is considered empty if either the number of rows or columns is zero, resulting in a total count of zero elements.
- **Parameters:**
  - (none)
- **Returns:** {@code true} if the matrix has no elements (count == 0), {@code false} otherwise
##### println(...) -> String
- **Signature:** `public abstract String println()`
- **Summary:** Prints the matrix to standard output in a formatted, human-readable manner and returns the output string.
- **Parameters:**
  - (none)
- **Returns:** the formatted string representation of the matrix that was printed to standard output
##### copy(...) -> X
- **Signature:** `public abstract X copy()`
- **Summary:** Creates a copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is a copy of this matrix with the same dimensions and values
- **Signature:** `public abstract X copy(int fromRowIndex, int toRowIndex)`
- **Summary:** Creates a copy of a row range from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a new matrix containing the specified rows with dimensions (toRowIndex - fromRowIndex) × columnCount
- **Signature:** `public abstract X copy(int fromRowIndex, int toRowIndex, int fromColumnIndex, int toColumnIndex)`
- **Summary:** Creates a copy of a rectangular region from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a new matrix containing the specified region with dimensions (toRowIndex - fromRowIndex) × (toColumnIndex - fromColumnIndex)
##### rotate90(...) -> X
- **Signature:** `public abstract X rotate90()`
- **Summary:** Rotates this matrix 90 degrees clockwise.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 90 degrees clockwise with dimensions columnCount × rowCount
##### rotate180(...) -> X
- **Signature:** `public abstract X rotate180()`
- **Summary:** Rotates this matrix 180 degrees.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 180 degrees with the same dimensions (rowCount × columnCount)
##### rotate270(...) -> X
- **Signature:** `public abstract X rotate270()`
- **Summary:** Rotates this matrix 270 degrees clockwise (or 90 degrees counter-clockwise).
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 270 degrees clockwise with dimensions columnCount × rowCount
##### transpose(...) -> X
- **Signature:** `public abstract X transpose()`
- **Summary:** Creates the transpose of this matrix by swapping rows and columns.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is the transpose of this matrix with dimensions columnCount × rowCount
##### reshape(...) -> X
- **Signature:** `public X reshape(final int newColumnCount)`
- **Summary:** Reshapes this matrix to have the specified number of columns.
- **Contract:**
  - If the total element count is not evenly divisible by the new column count, the last row will be padded with default values (0 for numeric types, false for boolean, null for objects).
- **Parameters:**
  - `newColumnCount` (`int`) — the number of columns in the reshaped matrix (must be positive)
- **Returns:** a new matrix with the specified number of columns
- **Signature:** `public abstract X reshape(int newRowCount, int newColumnCount)`
- **Summary:** Reshapes this matrix to have the specified dimensions.
- **Contract:**
  - If the new shape has fewer elements than the original, excess elements are discarded.
  - If the new shape has more elements, the extra positions are filled with default values (0 for numeric types, false for boolean, null for objects).
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the reshaped matrix (must be positive)
  - `newColumnCount` (`int`) — the number of columns in the reshaped matrix (must be positive)
- **Returns:** a new matrix with the specified dimensions (newRowCount × newColumnCount)
##### isSameShape(...) -> boolean
- **Signature:** `public boolean isSameShape(final X x)`
- **Summary:** Checks if this matrix has the same shape (dimensions) as another matrix.
- **Contract:**
  - Checks if this matrix has the same shape (dimensions) as another matrix.
  - Two matrices have the same shape if they have the same number of rows and columns.
- **Parameters:**
  - `x` (`X`) — the matrix to compare with
- **Returns:** {@code true} if both matrices have the same dimensions, {@code false} otherwise
##### repelem(...) -> X
- **Signature:** `public abstract X repelem(int rowRepeats, int colRepeats)`
- **Summary:** Repeats each element in the matrix the specified number of times in both dimensions.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat each element in the row direction (must be &gt; = 1)
  - `colRepeats` (`int`) — number of times to repeat each element in the column direction (must be &gt; = 1)
- **Returns:** a new matrix with repeated elements, dimensions (rows × rowRepeats) × (columnCount × colRepeats)
- **See also:** <a href="https://www.mathworks.com/help/matlab/ref/repelem.html">,MATLAB repelem,</a>
##### repmat(...) -> X
- **Signature:** `public abstract X repmat(int rowRepeats, int colRepeats)`
- **Summary:** Repeats the entire matrix the specified number of times in both dimensions.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat the matrix in the row direction (must be &gt; = 1)
  - `colRepeats` (`int`) — number of times to repeat the matrix in the column direction (must be &gt; = 1)
- **Returns:** a new matrix with the original matrix repeated, dimensions (rows × rowRepeats) × (columnCount × colRepeats)
- **See also:** <a href="https://www.mathworks.com/help/matlab/ref/repmat.html">,MATLAB repmat,</a>
##### flatten(...) -> PL
- **Signature:** `public abstract PL flatten()`
- **Summary:** Flattens the matrix into a one-dimensional list.
- **Parameters:**
  - (none)
- **Returns:** a new list containing all elements in row-major order with size equal to {@code elementCount}
##### flatOp(...) -> void
- **Signature:** `public abstract <E extends Exception> void flatOp(Throwables.Consumer<? super A, E> op) throws E`
- **Summary:** Applies an operation to the flattened view of the matrix and updates the matrix with the result.
- **Parameters:**
  - `op` (`Throwables.Consumer<? super A, E>`) — the operation to apply to the flattened array (receives array type A, not A\[\])
- **Throws:**
  - `E` — if the operation throws an exception
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.IntBiConsumer<E> action) throws E`
- **Summary:** Performs the given action for each position in the matrix.
- **Contract:**
  - <p> This method is useful when you need to access matrix positions without caring about the actual element values, or when the element access logic is handled inside the action.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code matrix.forEach((i, j) -> { System.out.println("Position: (" + i + "," + j + ")"); }); // Count elements on the main diagonal AtomicInteger diagonalCount = new AtomicInteger(0); matrix.forEach((i, j) -> { if (i == j) diagonalCount.incrementAndGet(); }); } </pre>
- **Parameters:**
  - `action` (`Throwables.IntBiConsumer<E>`) — the action to perform for each position, receives (rowIndex, columnIndex)
- **Throws:**
  - `E` — if the action throws an exception
- **Signature:** `public <E extends Exception> void forEach(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.IntBiConsumer<E> action) throws IndexOutOfBoundsException, E`
- **Summary:** Performs the given action for each position in the specified rectangular region of the matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
  - `action` (`Throwables.IntBiConsumer<E>`) — the action to perform for each position, receives (rowIndex, columnIndex)
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is out of bounds
  - `E` — if the action throws an exception
- **Signature:** `public <E extends Exception> void forEach(final Throwables.BiIntObjConsumer<X, E> action) throws E`
- **Summary:** Performs the given action for each position in the matrix, providing the matrix itself as a parameter.
- **Contract:**
  - <p> This variant is useful when the action needs access to matrix elements or methods, allowing you to read/write values or use matrix operations within the action.
- **Parameters:**
  - `action` (`Throwables.BiIntObjConsumer<X, E>`) — the action to perform, receiving (rowIndex, columnIndex, matrix)
- **Throws:**
  - `E` — if the action throws an exception
- **Signature:** `public <E extends Exception> void forEach(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.BiIntObjConsumer<X, E> action) throws IndexOutOfBoundsException, E`
- **Summary:** Performs the given action for each position in the specified rectangular region, providing the matrix itself.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
  - `action` (`Throwables.BiIntObjConsumer<X, E>`) — the action to perform, receiving (rowIndex, columnIndex, matrix)
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is out of bounds
  - `E` — if the action throws an exception
##### adjacent4Points(...) -> Stream<Point>
- **Signature:** `public Stream<Point> adjacent4Points(final int i, final int j)`
- **Summary:** Returns a stream of points adjacent to the specified position in the four cardinal directions (up, down, left, right).
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** a stream of adjacent points in cardinal directions (0-4 points depending on position)
##### adjacent8Points(...) -> Stream<Point>
- **Signature:** `public Stream<Point> adjacent8Points(final int i, final int j)`
- **Summary:** Returns a stream of all 8 points adjacent to the specified position, including both cardinal directions (up, down, left, right) and diagonal directions.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** a stream of adjacent points in all 8 directions (0-8 points depending on position)
##### pointsLU2RD(...) -> Stream<Point>
- **Signature:** `public Stream<Point> pointsLU2RD()`
- **Summary:** Returns a stream of points along the main diagonal (left-up to right-down).
- **Contract:**
  - The matrix must be square (rowCount == columnCount) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a stream of {@link Point} objects representing the main diagonal positions
##### pointsRU2LD(...) -> Stream<Point>
- **Signature:** `public Stream<Point> pointsRU2LD()`
- **Summary:** Returns a stream of points along the anti-diagonal (right-up to left-down).
- **Contract:**
  - The matrix must be square (rowCount == columnCount) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a stream of {@link Point} objects representing the anti-diagonal positions
##### pointsH(...) -> Stream<Point>
- **Signature:** `public Stream<Point> pointsH()`
- **Summary:** Returns a stream of all points in the matrix in row-major order (horizontal traversal).
- **Parameters:**
  - (none)
- **Returns:** a stream of all {@link Point} objects in row-major order
- **Signature:** `public Stream<Point> pointsH(final int rowIndex)`
- **Summary:** Returns a stream of points for a specific row in horizontal order (left to right).
- **Parameters:**
  - `rowIndex` (`int`) — the row index (0-based)
- **Returns:** a stream of {@link Point} objects for all columns in the specified row
- **Signature:** `@SuppressWarnings("resource") public Stream<Point> pointsH(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of points for a range of rows in row-major order (horizontal traversal).
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a stream of {@link Point} objects in the specified row range, in row-major order
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rowCount, or fromRowIndex &gt; toRowIndex
##### pointsV(...) -> Stream<Point>
- **Signature:** `public Stream<Point> pointsV()`
- **Summary:** Returns a stream of all points in the matrix in column-major order (vertical traversal).
- **Parameters:**
  - (none)
- **Returns:** a stream of all {@link Point} objects in column-major order
- **Signature:** `public Stream<Point> pointsV(final int columnIndex)`
- **Summary:** Returns a stream of points for a specific column in vertical order (top to bottom).
- **Parameters:**
  - `columnIndex` (`int`) — the column index (0-based)
- **Returns:** a stream of {@link Point} objects for all rows in the specified column
- **Signature:** `@SuppressWarnings("resource") public Stream<Point> pointsV(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of points for a range of columns in column-major order (vertical traversal).
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a stream of {@link Point} objects in the specified column range, in column-major order
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromColumnIndex &lt; 0, toColumnIndex &gt; columnCount, or fromColumnIndex &gt; toColumnIndex
##### pointsR(...) -> Stream<Stream<Point>>
- **Signature:** `public Stream<Stream<Point>> pointsR()`
- **Summary:** Returns a stream of streams where each inner stream represents a row of points.
- **Parameters:**
  - (none)
- **Returns:** a stream of streams, where each inner stream contains {@link Point} objects for one row
- **Signature:** `@SuppressWarnings("resource") public Stream<Stream<Point>> pointsR(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of streams for a range of rows, where each inner stream represents a row of points.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a stream of streams, where each inner stream contains {@link Point} objects for one row
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rowCount, or fromRowIndex &gt; toRowIndex
##### pointsC(...) -> Stream<Stream<Point>>
- **Signature:** `public Stream<Stream<Point>> pointsC()`
- **Summary:** Returns a stream of streams where each inner stream represents a column of points.
- **Parameters:**
  - (none)
- **Returns:** a stream of streams, where each inner stream contains {@link Point} objects for one column
- **Signature:** `@SuppressWarnings("resource") public Stream<Stream<Point>> pointsC(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of streams for a range of columns, where each inner stream represents a column of points.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a stream of streams, where each inner stream contains {@link Point} objects for one column
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromColumnIndex &lt; 0, toColumnIndex &gt; columnCount, or fromColumnIndex &gt; toColumnIndex
##### streamLU2RD(...) -> ES
- **Signature:** `public abstract ES streamLU2RD()`
- **Summary:** Returns a stream of elements along the main diagonal (left-up to right-down).
- **Contract:**
  - The matrix must be square (rowCount == columnCount) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a stream of diagonal elements
##### streamRU2LD(...) -> ES
- **Signature:** `public abstract ES streamRU2LD()`
- **Summary:** Returns a stream of elements along the anti-diagonal (right-up to left-down).
- **Contract:**
  - The matrix must be square (rowCount == columnCount) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a stream of anti-diagonal elements
##### streamH(...) -> ES
- **Signature:** `public abstract ES streamH()`
- **Summary:** Returns a stream of all elements in row-major order (horizontal traversal).
- **Parameters:**
  - (none)
- **Returns:** a stream of all elements in row-major order
- **Signature:** `public abstract ES streamH(final int rowIndex)`
- **Summary:** Returns a stream of elements from a specific row.
- **Parameters:**
  - `rowIndex` (`int`) — the row index (0-based)
- **Returns:** a stream of elements in the specified row
- **Signature:** `public abstract ES streamH(final int fromRowIndex, final int toRowIndex)`
- **Summary:** Returns a stream of elements from a range of rows in row-major order.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a stream of elements in the specified row range
##### streamV(...) -> ES
- **Signature:** `public abstract ES streamV()`
- **Summary:** Returns a stream of all elements in column-major order (vertical traversal).
- **Parameters:**
  - (none)
- **Returns:** a stream of all elements in column-major order
- **Signature:** `public abstract ES streamV(final int columnIndex)`
- **Summary:** Returns a stream of elements from a specific column.
- **Parameters:**
  - `columnIndex` (`int`) — the column index (0-based)
- **Returns:** a stream of elements in the specified column
- **Signature:** `public abstract ES streamV(final int fromColumnIndex, final int toColumnIndex)`
- **Summary:** Returns a stream of elements from a range of columns in column-major order.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a stream of elements in the specified column range
##### streamR(...) -> RS
- **Signature:** `public abstract RS streamR()`
- **Summary:** Returns a stream of row streams.
- **Parameters:**
  - (none)
- **Returns:** a stream of row streams
- **Signature:** `public abstract RS streamR(final int fromRowIndex, final int toRowIndex)`
- **Summary:** Returns a stream of row streams for a range of rows.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a stream of row streams for the specified range
##### streamC(...) -> RS
- **Signature:** `public abstract RS streamC()`
- **Summary:** Returns a stream of column streams.
- **Parameters:**
  - (none)
- **Returns:** a stream of column streams
- **Signature:** `public abstract RS streamC(final int fromColumnIndex, final int toColumnIndex)`
- **Summary:** Returns a stream of column streams for a range of columns.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a stream of column streams for the specified range
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.Consumer<? super X, E> action) throws E`
- **Summary:** Executes the given action with this matrix as the parameter.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Log matrix details matrix.accept(m -> { System.out.println("Matrix dimensions: " + m.rowCount + "x" + m.columnCount); m.println(); }); // Validate matrix before processing matrix.accept(m -> { if (m.isEmpty()) { throw new IllegalStateException("Matrix cannot be empty"); } }); // Modify matrix elements in place matrix.accept(m -> { for (int i = 0; i < m.rowCount; i++) { m.set(i, 0, 0); // Set first column to 0 } }); } </pre>
- **Parameters:**
  - `action` (`Throwables.Consumer<? super X, E>`) — the consumer action to perform on this matrix
- **Throws:**
  - `E` — if the action throws an exception
##### apply(...) -> R
- **Signature:** `public <R, E extends Exception> R apply(final Throwables.Function<? super X, R, E> action) throws E`
- **Summary:** Applies the given function to this matrix and returns the result.
- **Parameters:**
  - `action` (`Throwables.Function<? super X, R, E>`) — the function to apply to this matrix
- **Returns:** the result of applying the function to this matrix
- **Throws:**
  - `E` — if the function throws an exception

### Class Arrays (com.landawn.abacus.util.Arrays)
A comprehensive, high-performance utility class providing extensive array manipulation and operation capabilities for all primitive types and objects in single and multi-dimensional configurations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### println(...) -> String
- **Signature:** `public static String println(final Object[] a)`
- **Summary:** Prints a string representation of a one-dimensional object array to the console and returns the string.
- **Parameters:**
  - `a` (`Object[]`) — the one-dimensional object array to print (can be {@code null} ).
- **Returns:** the string representation of the array that was printed to console.
- **See also:** #println(Object\[\]\[\]),for two-dimensional array printing, #println(Object\[\]\[\]\[\]),for three-dimensional array printing, N#println(Object),for the underlying print implementation
- **Signature:** `public static String println(final Object[][] a)`
- **Summary:** Prints a string representation of a two-dimensional object array to the console and returns the string.
- **Parameters:**
  - `a` (`Object[][]`) — the two-dimensional object array to print (can be {@code null} ).
- **Returns:** the string representation of the two-dimensional array that was printed to console.
- **See also:** #println(Object\[\]),for one-dimensional array printing, #println(Object\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final Object[][][] a)`
- **Summary:** Prints a string representation of a three-dimensional object array to the console and returns the string.
- **Parameters:**
  - `a` (`Object[][][]`) — the three-dimensional object array to print (can be {@code null} ).
- **Returns:** the string representation of the three-dimensional array that was printed to console.
- **See also:** #println(Object\[\]),for one-dimensional array printing, #println(Object\[\]\[\]),for two-dimensional array printing
- **Signature:** `public static String println(final boolean[] a)`
- **Summary:** Prints a string representation of a one-dimensional boolean array to the console and returns the string.
- **Parameters:**
  - `a` (`boolean[]`) — the one-dimensional boolean array to print (can be {@code null} ).
- **Returns:** the string representation of the array that was printed to console.
- **See also:** #println(boolean\[\]\[\]),for two-dimensional array printing, #println(boolean\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final boolean[][] a)`
- **Summary:** Prints a string representation of a two-dimensional boolean array to the console and returns the string.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional boolean array to print (can be {@code null} ).
- **Returns:** the string representation of the two-dimensional array that was printed to console.
- **See also:** #println(boolean\[\]),for one-dimensional array printing, #println(boolean\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final boolean[][][] a)`
- **Summary:** Prints a string representation of a three-dimensional boolean array to the console and returns the string.
- **Parameters:**
  - `a` (`boolean[][][]`) — the three-dimensional boolean array to print (can be {@code null} ).
- **Returns:** the string representation of the three-dimensional array that was printed to console.
- **See also:** #println(boolean\[\]),for one-dimensional array printing, #println(boolean\[\]\[\]),for two-dimensional array printing
- **Signature:** `public static String println(final char[] a)`
- **Summary:** Prints a string representation of a one-dimensional character array to the console and returns the string.
- **Parameters:**
  - `a` (`char[]`) — the one-dimensional character array to print (can be {@code null} ).
- **Returns:** the string representation of the array that was printed to console.
- **See also:** #println(char\[\]\[\]),for two-dimensional array printing, #println(char\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final char[][] a)`
- **Summary:** Prints a string representation of a two-dimensional character array to the console and returns the string.
- **Parameters:**
  - `a` (`char[][]`) — the two-dimensional character array to print (can be {@code null} ).
- **Returns:** the string representation of the two-dimensional array that was printed to console.
- **See also:** #println(char\[\]),for one-dimensional array printing, #println(char\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final char[][][] a)`
- **Summary:** Prints a string representation of a three-dimensional character array to the console and returns the string.
- **Parameters:**
  - `a` (`char[][][]`) — the three-dimensional character array to print (can be {@code null} ).
- **Returns:** the string representation of the three-dimensional array that was printed to console.
- **See also:** #println(char\[\]),for one-dimensional array printing, #println(char\[\]\[\]),for two-dimensional array printing
- **Signature:** `public static String println(final byte[] a)`
- **Summary:** Prints a string representation of a one-dimensional byte array to the console and returns the string.
- **Parameters:**
  - `a` (`byte[]`) — the one-dimensional byte array to print (can be {@code null} ).
- **Returns:** the string representation of the array that was printed to console.
- **See also:** #println(byte\[\]\[\]),for two-dimensional array printing, #println(byte\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final byte[][] a)`
- **Summary:** Prints a string representation of a two-dimensional byte array to the console and returns the string.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array to print (can be {@code null} ).
- **Returns:** the string representation of the two-dimensional array that was printed to console.
- **See also:** #println(byte\[\]),for one-dimensional array printing, #println(byte\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final byte[][][] a)`
- **Summary:** Prints a string representation of a three-dimensional byte array to the console and returns the string.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional byte array to print (can be {@code null} ).
- **Returns:** the string representation of the three-dimensional array that was printed to console.
- **See also:** #println(byte\[\]),for one-dimensional array printing, #println(byte\[\]\[\]),for two-dimensional array printing
- **Signature:** `public static String println(final short[] a)`
- **Summary:** Prints a string representation of a one-dimensional short array to the console and returns the string.
- **Parameters:**
  - `a` (`short[]`) — the one-dimensional short array to print (can be {@code null} ).
- **Returns:** the string representation of the array that was printed to console.
- **See also:** #println(short\[\]\[\]),for two-dimensional array printing, #println(short\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final short[][] a)`
- **Summary:** Prints a string representation of a two-dimensional short array to the console and returns the string.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional short array to print (can be {@code null} ).
- **Returns:** the string representation of the two-dimensional array that was printed to console.
- **See also:** #println(short\[\]),for one-dimensional array printing, #println(short\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final short[][][] a)`
- **Summary:** Prints a string representation of a three-dimensional short array to the console and returns the string.
- **Parameters:**
  - `a` (`short[][][]`) — the three-dimensional short array to print (can be {@code null} ).
- **Returns:** the string representation of the three-dimensional array that was printed to console.
- **See also:** #println(short\[\]),for one-dimensional array printing, #println(short\[\]\[\]),for two-dimensional array printing
- **Signature:** `public static String println(final int[] a)`
- **Summary:** Prints a string representation of a one-dimensional integer array to the console and returns the string.
- **Parameters:**
  - `a` (`int[]`) — the one-dimensional integer array to print (can be {@code null} ).
- **Returns:** the string representation of the array that was printed to console.
- **See also:** #println(int\[\]\[\]),for two-dimensional array printing, #println(int\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final int[][] a)`
- **Summary:** Prints a string representation of a two-dimensional integer array to the console and returns the string.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional integer array to print (can be {@code null} ).
- **Returns:** the string representation of the two-dimensional array that was printed to console.
- **See also:** #println(int\[\]),for one-dimensional array printing, #println(int\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final int[][][] a)`
- **Summary:** Prints a string representation of a three-dimensional integer array to the console and returns the string.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional integer array to print (can be {@code null} ).
- **Returns:** the string representation of the three-dimensional array that was printed to console.
- **See also:** #println(int\[\]),for one-dimensional array printing, #println(int\[\]\[\]),for two-dimensional array printing
- **Signature:** `public static String println(final long[] a)`
- **Summary:** Prints a string representation of a one-dimensional long array to the console and returns the string.
- **Parameters:**
  - `a` (`long[]`) — the one-dimensional long array to print (can be {@code null} ).
- **Returns:** the string representation of the array that was printed to console.
- **See also:** #println(long\[\]\[\]),for two-dimensional array printing, #println(long\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final long[][] a)`
- **Summary:** Prints a string representation of a two-dimensional long array to the console and returns the string.
- **Parameters:**
  - `a` (`long[][]`) — the two-dimensional long array to print (can be {@code null} ).
- **Returns:** the string representation of the two-dimensional array that was printed to console.
- **See also:** #println(long\[\]),for one-dimensional array printing, #println(long\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final long[][][] a)`
- **Summary:** Prints a string representation of a three-dimensional long array to the console and returns the string.
- **Parameters:**
  - `a` (`long[][][]`) — the three-dimensional long array to print (can be {@code null} ).
- **Returns:** the string representation of the three-dimensional array that was printed to console.
- **See also:** #println(long\[\]),for one-dimensional array printing, #println(long\[\]\[\]),for two-dimensional array printing
- **Signature:** `public static String println(final float[] a)`
- **Summary:** Prints a string representation of a one-dimensional float array to the console and returns the string.
- **Parameters:**
  - `a` (`float[]`) — the one-dimensional float array to print (can be {@code null} ).
- **Returns:** the string representation of the array that was printed to console.
- **See also:** #println(float\[\]\[\]),for two-dimensional array printing, #println(float\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final float[][] a)`
- **Summary:** Prints a string representation of a two-dimensional float array to the console and returns the string.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional float array to print (can be {@code null} ).
- **Returns:** the string representation of the two-dimensional array that was printed to console.
- **See also:** #println(float\[\]),for one-dimensional array printing, #println(float\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final float[][][] a)`
- **Summary:** Prints a string representation of a three-dimensional float array to the console and returns the string.
- **Parameters:**
  - `a` (`float[][][]`) — the three-dimensional float array to print (can be {@code null} ).
- **Returns:** the string representation of the three-dimensional array that was printed to console.
- **See also:** #println(float\[\]),for one-dimensional array printing, #println(float\[\]\[\]),for two-dimensional array printing
- **Signature:** `public static String println(final double[] a)`
- **Summary:** Prints a string representation of a one-dimensional double array to the console and returns the string.
- **Parameters:**
  - `a` (`double[]`) — the one-dimensional double array to print (can be {@code null} ).
- **Returns:** the string representation of the array that was printed to console.
- **See also:** #println(double\[\]\[\]),for two-dimensional array printing, #println(double\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final double[][] a)`
- **Summary:** Prints a string representation of a two-dimensional double array to the console and returns the string.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional double array to print (can be {@code null} ).
- **Returns:** the string representation of the two-dimensional array that was printed to console.
- **See also:** #println(double\[\]),for one-dimensional array printing, #println(double\[\]\[\]\[\]),for three-dimensional array printing
- **Signature:** `public static String println(final double[][][] a)`
- **Summary:** Prints a string representation of a three-dimensional double array to the console and returns the string.
- **Parameters:**
  - `a` (`double[][][]`) — the three-dimensional double array to print (can be {@code null} ).
- **Returns:** the string representation of the three-dimensional array that was printed to console.
- **See also:** #println(double\[\]),for one-dimensional array printing, #println(double\[\]\[\]),for two-dimensional array printing
##### mapToObj(...) -> T\[\]
- **Signature:** `public static <T, E extends Exception> T[] mapToObj(final boolean[] a, final Throwables.BooleanFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each boolean element to an object using the provided mapper function.
- **Contract:**
  - "YES" : "NO", String.class); // Result: \["YES", "NO", "YES"\] } </pre> <p> <b> Type Conversion: </b> The target element type must be specified to ensure proper array creation and type safety throughout the transformation process.
- **Parameters:**
  - `a` (`boolean[]`) — the boolean array to map (can be {@code null} ).
  - `mapper` (`Throwables.BooleanFunction<? extends T, E>`) — the function that maps each boolean to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** an object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **See also:** #mapToObj(boolean\[\]\[\], Throwables.BooleanFunction, Class),for two-dimensional arrays, #mapToObj(boolean\[\]\[\]\[\], Throwables.BooleanFunction, Class),for three-dimensional arrays
- **Signature:** `public static <T, E extends Exception> T[][] mapToObj(final boolean[][] a, final Throwables.BooleanFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each boolean element in a two-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional boolean array to map (can be {@code null} ).
  - `mapper` (`Throwables.BooleanFunction<? extends T, E>`) — the function that maps each boolean to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a two-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][][] mapToObj(final boolean[][][] a, final Throwables.BooleanFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each boolean element in a three-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`boolean[][][]`) — the three-dimensional boolean array to map (can be {@code null} ).
  - `mapper` (`Throwables.BooleanFunction<? extends T, E>`) — the function that maps each boolean to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a three-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[] mapToObj(final char[] a, final Throwables.CharFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each char element to an object using the provided mapper function.
- **Parameters:**
  - `a` (`char[]`) — the char array to map (can be {@code null} ).
  - `mapper` (`Throwables.CharFunction<? extends T, E>`) — the function that maps each char to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** an object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][] mapToObj(final char[][] a, final Throwables.CharFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each char element in a two-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`char[][]`) — the two-dimensional char array to map (can be {@code null} ).
  - `mapper` (`Throwables.CharFunction<? extends T, E>`) — the function that maps each char to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a two-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][][] mapToObj(final char[][][] a, final Throwables.CharFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each char element in a three-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`char[][][]`) — the three-dimensional char array to map (can be {@code null} ).
  - `mapper` (`Throwables.CharFunction<? extends T, E>`) — the function that maps each char to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a three-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[] mapToObj(final byte[] a, final Throwables.ByteFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each byte element to an object using the provided mapper function.
- **Parameters:**
  - `a` (`byte[]`) — the byte array to map (can be {@code null} ).
  - `mapper` (`Throwables.ByteFunction<? extends T, E>`) — the function that maps each byte to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** an object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][] mapToObj(final byte[][] a, final Throwables.ByteFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each byte element in a two-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array to map (can be {@code null} ).
  - `mapper` (`Throwables.ByteFunction<? extends T, E>`) — the function that maps each byte to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a two-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][][] mapToObj(final byte[][][] a, final Throwables.ByteFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each byte element in a three-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional byte array to map (can be {@code null} ).
  - `mapper` (`Throwables.ByteFunction<? extends T, E>`) — the function that maps each byte to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a three-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[] mapToObj(final short[] a, final Throwables.ShortFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each short element to an object using the provided mapper function.
- **Parameters:**
  - `a` (`short[]`) — the short array to map (can be {@code null} ).
  - `mapper` (`Throwables.ShortFunction<? extends T, E>`) — the function that maps each short to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** an object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][] mapToObj(final short[][] a, final Throwables.ShortFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each short element in a two-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional short array to map (can be {@code null} ).
  - `mapper` (`Throwables.ShortFunction<? extends T, E>`) — the function that maps each short to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a two-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][][] mapToObj(final short[][][] a, final Throwables.ShortFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each short element in a three-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`short[][][]`) — the three-dimensional short array to map (can be {@code null} ).
  - `mapper` (`Throwables.ShortFunction<? extends T, E>`) — the function that maps each short to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a three-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[] mapToObj(final int[] a, final Throwables.IntFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each int element to an object using the provided mapper function.
- **Parameters:**
  - `a` (`int[]`) — the int array to map (can be {@code null} ).
  - `mapper` (`Throwables.IntFunction<? extends T, E>`) — the function that maps each int to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** an object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][] mapToObj(final int[][] a, final Throwables.IntFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each int element in a two-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional int array to map (can be {@code null} ).
  - `mapper` (`Throwables.IntFunction<? extends T, E>`) — the function that maps each int to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a two-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][][] mapToObj(final int[][][] a, final Throwables.IntFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each int element in a three-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional int array to map (can be {@code null} ).
  - `mapper` (`Throwables.IntFunction<? extends T, E>`) — the function that maps each int to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a three-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[] mapToObj(final long[] a, final Throwables.LongFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each long element to an object using the provided mapper function.
- **Parameters:**
  - `a` (`long[]`) — the long array to map (can be {@code null} ).
  - `mapper` (`Throwables.LongFunction<? extends T, E>`) — the function that maps each long to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** an object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][] mapToObj(final long[][] a, final Throwables.LongFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each long element in a two-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`long[][]`) — the two-dimensional long array to map (can be {@code null} ).
  - `mapper` (`Throwables.LongFunction<? extends T, E>`) — the function that maps each long to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a two-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][][] mapToObj(final long[][][] a, final Throwables.LongFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each long element in a three-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`long[][][]`) — the three-dimensional long array to map (can be {@code null} ).
  - `mapper` (`Throwables.LongFunction<? extends T, E>`) — the function that maps each long to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a three-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[] mapToObj(final float[] a, final Throwables.FloatFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each float element to an object using the provided mapper function.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code float\[\] temperatures = {98.6f, 99.5f, 97.3f}; String\[\] result = Arrays.mapToObj(temperatures, t -> t + "°F", String.class); // Result: \["98.6°F", "99.5°F", "97.3°F"\] } </pre> <p> <b> Type Conversion: </b> The target element type must be specified to ensure proper array creation and type safety throughout the transformation process.
- **Parameters:**
  - `a` (`float[]`) — the float array to map (can be {@code null} ).
  - `mapper` (`Throwables.FloatFunction<? extends T, E>`) — the function that maps each float to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** an object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **See also:** #mapToObj(float\[\]\[\], Throwables.FloatFunction, Class),for two-dimensional arrays, #mapToObj(float\[\]\[\]\[\], Throwables.FloatFunction, Class),for three-dimensional arrays
- **Signature:** `public static <T, E extends Exception> T[][] mapToObj(final float[][] a, final Throwables.FloatFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each float element in a two-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional float array to map (can be {@code null} ).
  - `mapper` (`Throwables.FloatFunction<? extends T, E>`) — the function that maps each float to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a two-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[][][] mapToObj(final float[][][] a, final Throwables.FloatFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each float element in a three-dimensional array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`float[][][]`) — the three-dimensional float array to map (can be {@code null} ).
  - `mapper` (`Throwables.FloatFunction<? extends T, E>`) — the function that maps each float to an object (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a three-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <T, E extends Exception> T[] mapToObj(final double[] a, final Throwables.DoubleFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each element of a double array to an object using the provided mapper function.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code double\[\] doubles = {1.5, 2.5, 3.5}; String\[\] strings = Arrays.mapToObj(doubles, d -> String.format("%.1f", d), String.class); // Result: \["1.5", "2.5", "3.5"\] } </pre> <p> <b> Type Conversion: </b> The target element type must be specified to ensure proper array creation and type safety throughout the transformation process.
- **Parameters:**
  - `a` (`double[]`) — the double array to map (can be {@code null} ).
  - `mapper` (`Throwables.DoubleFunction<? extends T, E>`) — the function to transform each double element (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** an object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **See also:** #mapToObj(double\[\]\[\], Throwables.DoubleFunction, Class),for two-dimensional arrays, #mapToObj(double\[\]\[\]\[\], Throwables.DoubleFunction, Class),for three-dimensional arrays
- **Signature:** `public static <T, E extends Exception> T[][] mapToObj(final double[][] a, final Throwables.DoubleFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each element of a two-dimensional double array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional double array to map (can be {@code null} ).
  - `mapper` (`Throwables.DoubleFunction<? extends T, E>`) — the function to transform each double element (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a two-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **See also:** #mapToObj(double\[\], Throwables.DoubleFunction, Class),for one-dimensional arrays, #mapToObj(double\[\]\[\]\[\], Throwables.DoubleFunction, Class),for three-dimensional arrays
- **Signature:** `public static <T, E extends Exception> T[][][] mapToObj(final double[][][] a, final Throwables.DoubleFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Maps each element of a three-dimensional double array to an object using the provided mapper function.
- **Parameters:**
  - `a` (`double[][][]`) — the three-dimensional double array to map (can be {@code null} ).
  - `mapper` (`Throwables.DoubleFunction<? extends T, E>`) — the function to transform each double element (must not be {@code null} ).
  - `targetElementType` (`Class<T>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a three-dimensional object array containing the mapped values, or an empty array if input is {@code null} or empty.
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **See also:** #mapToObj(double\[\], Throwables.DoubleFunction, Class),for one-dimensional arrays, #mapToObj(double\[\]\[\], Throwables.DoubleFunction, Class),for two-dimensional arrays
##### mapToLong(...) -> long\[\]
- **Signature:** `public static <E extends Exception> long[] mapToLong(final int[] a, final Throwables.IntToLongFunction<E> mapper) throws E`
- **Summary:** Maps a one-dimensional int array to a one-dimensional long array using the provided mapper function.
- **Parameters:**
  - `a` (`int[]`) — the int array to map (can be {@code null} ).
  - `mapper` (`Throwables.IntToLongFunction<E>`) — the function to transform each int to long (must not be {@code null} ).
- **Returns:** a long array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **See also:** #mapToLong(int\[\]\[\], Throwables.IntToLongFunction),for two-dimensional arrays, #mapToLong(int\[\]\[\]\[\], Throwables.IntToLongFunction),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> long[][] mapToLong(final int[][] a, final Throwables.IntToLongFunction<E> mapper) throws E`
- **Summary:** Maps a two-dimensional int array to a two-dimensional long array using the provided mapper function.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional int array to map (can be {@code null} ).
  - `mapper` (`Throwables.IntToLongFunction<E>`) — the function to transform each int to long (must not be {@code null} ).
- **Returns:** a two-dimensional long array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **See also:** #mapToLong(int\[\], Throwables.IntToLongFunction),for one-dimensional arrays, #mapToLong(int\[\]\[\]\[\], Throwables.IntToLongFunction),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> long[][][] mapToLong(final int[][][] a, final Throwables.IntToLongFunction<E> mapper) throws E`
- **Summary:** Maps a three-dimensional int array to a three-dimensional long array using the provided mapper function.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional int array to map (can be {@code null} ).
  - `mapper` (`Throwables.IntToLongFunction<E>`) — the function to transform each int to long (must not be {@code null} ).
- **Returns:** a three-dimensional long array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **See also:** #mapToLong(int\[\], Throwables.IntToLongFunction),for one-dimensional arrays, #mapToLong(int\[\]\[\], Throwables.IntToLongFunction),for two-dimensional arrays
- **Signature:** `public static <E extends Exception> long[] mapToLong(final double[] a, final Throwables.DoubleToLongFunction<E> mapper) throws E`
- **Summary:** Maps a one-dimensional double array to a one-dimensional long array using the provided mapper function.
- **Parameters:**
  - `a` (`double[]`) — the input double array (can be {@code null} ).
  - `mapper` (`Throwables.DoubleToLongFunction<E>`) — the function to transform each double to long (must not be {@code null} ).
- **Returns:** a long array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> long[][] mapToLong(final double[][] a, final Throwables.DoubleToLongFunction<E> mapper) throws E`
- **Summary:** Maps a two-dimensional double array to a two-dimensional long array using the provided mapper function.
- **Parameters:**
  - `a` (`double[][]`) — the input two-dimensional double array (can be {@code null} ).
  - `mapper` (`Throwables.DoubleToLongFunction<E>`) — the function to transform each double to long (must not be {@code null} ).
- **Returns:** a two-dimensional long array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> long[][][] mapToLong(final double[][][] a, final Throwables.DoubleToLongFunction<E> mapper) throws E`
- **Summary:** Maps a three-dimensional double array to a three-dimensional long array using the provided mapper function.
- **Parameters:**
  - `a` (`double[][][]`) — the input three-dimensional double array (can be {@code null} ).
  - `mapper` (`Throwables.DoubleToLongFunction<E>`) — the function to transform each double to long (must not be {@code null} ).
- **Returns:** a three-dimensional long array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
##### mapToDouble(...) -> double\[\]
- **Signature:** `public static <E extends Exception> double[] mapToDouble(final int[] a, final Throwables.IntToDoubleFunction<E> mapper) throws E`
- **Summary:** Maps a one-dimensional int array to a one-dimensional double array using the provided mapper function.
- **Parameters:**
  - `a` (`int[]`) — the input int array (can be {@code null} ).
  - `mapper` (`Throwables.IntToDoubleFunction<E>`) — the function to transform each int to double (must not be {@code null} ).
- **Returns:** a double array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> double[][] mapToDouble(final int[][] a, final Throwables.IntToDoubleFunction<E> mapper) throws E`
- **Summary:** Maps a two-dimensional int array to a two-dimensional double array using the provided mapper function.
- **Parameters:**
  - `a` (`int[][]`) — the input two-dimensional int array (can be {@code null} ).
  - `mapper` (`Throwables.IntToDoubleFunction<E>`) — the function to transform each int to double (must not be {@code null} ).
- **Returns:** a two-dimensional double array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> double[][][] mapToDouble(final int[][][] a, final Throwables.IntToDoubleFunction<E> mapper) throws E`
- **Summary:** Maps a three-dimensional int array to a three-dimensional double array using the provided mapper function.
- **Parameters:**
  - `a` (`int[][][]`) — the input three-dimensional int array (can be {@code null} ).
  - `mapper` (`Throwables.IntToDoubleFunction<E>`) — the function to transform each int to double (must not be {@code null} ).
- **Returns:** a three-dimensional double array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> double[] mapToDouble(final long[] a, final Throwables.LongToDoubleFunction<E> mapper) throws E`
- **Summary:** Maps a one-dimensional long array to a one-dimensional double array using the provided mapper function.
- **Parameters:**
  - `a` (`long[]`) — the input long array (can be {@code null} ).
  - `mapper` (`Throwables.LongToDoubleFunction<E>`) — the function to transform each long to double (must not be {@code null} ).
- **Returns:** a double array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> double[][] mapToDouble(final long[][] a, final Throwables.LongToDoubleFunction<E> mapper) throws E`
- **Summary:** Maps a two-dimensional long array to a two-dimensional double array using the provided mapper function.
- **Parameters:**
  - `a` (`long[][]`) — the input two-dimensional long array (can be {@code null} ).
  - `mapper` (`Throwables.LongToDoubleFunction<E>`) — the function to transform each long to double (must not be {@code null} ).
- **Returns:** a two-dimensional double array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> double[][][] mapToDouble(final long[][][] a, final Throwables.LongToDoubleFunction<E> mapper) throws E`
- **Summary:** Maps a three-dimensional long array to a three-dimensional double array using the provided mapper function.
- **Parameters:**
  - `a` (`long[][][]`) — the input three-dimensional long array (can be {@code null} ).
  - `mapper` (`Throwables.LongToDoubleFunction<E>`) — the function to transform each long to double (must not be {@code null} ).
- **Returns:** a three-dimensional double array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
##### mapToInt(...) -> int\[\]
- **Signature:** `public static <E extends Exception> int[] mapToInt(final long[] a, final Throwables.LongToIntFunction<E> mapper) throws E`
- **Summary:** Maps a one-dimensional long array to a one-dimensional int array using the provided mapper function.
- **Parameters:**
  - `a` (`long[]`) — the input long array (can be {@code null} ).
  - `mapper` (`Throwables.LongToIntFunction<E>`) — the function to transform each long to int (must not be {@code null} ).
- **Returns:** an int array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> int[][] mapToInt(final long[][] a, final Throwables.LongToIntFunction<E> mapper) throws E`
- **Summary:** Maps a two-dimensional long array to a two-dimensional int array using the provided mapper function.
- **Parameters:**
  - `a` (`long[][]`) — the input two-dimensional long array (can be {@code null} ).
  - `mapper` (`Throwables.LongToIntFunction<E>`) — the function to transform each long to int (must not be {@code null} ).
- **Returns:** a two-dimensional int array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> int[][][] mapToInt(final long[][][] a, final Throwables.LongToIntFunction<E> mapper) throws E`
- **Summary:** Maps a three-dimensional long array to a three-dimensional int array using the provided mapper function.
- **Parameters:**
  - `a` (`long[][][]`) — the input three-dimensional long array (can be {@code null} ).
  - `mapper` (`Throwables.LongToIntFunction<E>`) — the function to transform each long to int (must not be {@code null} ).
- **Returns:** a three-dimensional int array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> int[] mapToInt(final double[] a, final Throwables.DoubleToIntFunction<E> mapper) throws E`
- **Summary:** Maps a one-dimensional double array to a one-dimensional int array using the provided mapper function.
- **Parameters:**
  - `a` (`double[]`) — the input double array (can be {@code null} ).
  - `mapper` (`Throwables.DoubleToIntFunction<E>`) — the function to transform each double to int (must not be {@code null} ).
- **Returns:** an int array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> int[][] mapToInt(final double[][] a, final Throwables.DoubleToIntFunction<E> mapper) throws E`
- **Summary:** Maps a two-dimensional double array to a two-dimensional int array using the provided mapper function.
- **Parameters:**
  - `a` (`double[][]`) — the input two-dimensional double array (can be {@code null} ).
  - `mapper` (`Throwables.DoubleToIntFunction<E>`) — the function to transform each double to int (must not be {@code null} ).
- **Returns:** a two-dimensional int array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
- **Signature:** `public static <E extends Exception> int[][][] mapToInt(final double[][][] a, final Throwables.DoubleToIntFunction<E> mapper) throws E`
- **Summary:** Maps a three-dimensional double array to a three-dimensional int array using the provided mapper function.
- **Parameters:**
  - `a` (`double[][][]`) — the input three-dimensional double array (can be {@code null} ).
  - `mapper` (`Throwables.DoubleToIntFunction<E>`) — the function to transform each double to int (must not be {@code null} ).
- **Returns:** a three-dimensional int array with mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the {@code mapper} function throws an exception.
##### updateAll(...) -> void
- **Signature:** `public static <E extends Exception> void updateAll(final boolean[] a, final Throwables.BooleanUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a boolean array using the provided unary operator.
- **Parameters:**
  - `a` (`boolean[]`) — the boolean array to update (can be {@code null} ).
  - `operator` (`Throwables.BooleanUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **See also:** #updateAll(boolean\[\]\[\], Throwables.BooleanUnaryOperator),for two-dimensional arrays, #updateAll(boolean\[\]\[\]\[\], Throwables.BooleanUnaryOperator),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void updateAll(final boolean[][] a, final Throwables.BooleanUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a two-dimensional boolean array using the provided unary operator.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional boolean array to update (can be {@code null} or empty).
  - `operator` (`Throwables.BooleanUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **See also:** #updateAll(boolean\[\], Throwables.BooleanUnaryOperator),for one-dimensional arrays, #updateAll(boolean\[\]\[\]\[\], Throwables.BooleanUnaryOperator),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void updateAll(final boolean[][][] a, final Throwables.BooleanUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a three-dimensional boolean array using the provided unary operator.
- **Parameters:**
  - `a` (`boolean[][][]`) — the three-dimensional boolean array to update (can be {@code null} or empty).
  - `operator` (`Throwables.BooleanUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **See also:** #updateAll(boolean\[\], Throwables.BooleanUnaryOperator),for one-dimensional arrays, #updateAll(boolean\[\]\[\], Throwables.BooleanUnaryOperator),for two-dimensional arrays
- **Signature:** `public static <E extends Exception> void updateAll(final char[] a, final Throwables.CharUnaryOperator<E> operator) throws E`
- **Summary:** Updates every element in the specified character array by applying a given operator.
- **Parameters:**
  - `a` (`char[]`) — The char array to update (can be {@code null} ).
  - `operator` (`Throwables.CharUnaryOperator<E>`) — The unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **See also:** #updateAll(char\[\]\[\], Throwables.CharUnaryOperator),for two-dimensional arrays, #updateAll(char\[\]\[\]\[\], Throwables.CharUnaryOperator),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void updateAll(final char[][] a, final Throwables.CharUnaryOperator<E> operator) throws E`
- **Summary:** Recursively updates every element in the two-dimensional character array by applying a given operator.
- **Parameters:**
  - `a` (`char[][]`) — The two-dimensional char array to update (can be {@code null} ).
  - `operator` (`Throwables.CharUnaryOperator<E>`) — The unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **See also:** #updateAll(char\[\], Throwables.CharUnaryOperator),for one-dimensional arrays, #updateAll(char\[\]\[\]\[\], Throwables.CharUnaryOperator),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void updateAll(final char[][][] a, final Throwables.CharUnaryOperator<E> operator) throws E`
- **Summary:** Recursively updates every element in the three-dimensional character array by applying a given operator.
- **Parameters:**
  - `a` (`char[][][]`) — The three-dimensional char array to update (can be {@code null} ).
  - `operator` (`Throwables.CharUnaryOperator<E>`) — The unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **See also:** #updateAll(char\[\], Throwables.CharUnaryOperator),for one-dimensional arrays, #updateAll(char\[\]\[\], Throwables.CharUnaryOperator),for two-dimensional arrays
- **Signature:** `public static <E extends Exception> void updateAll(final byte[] a, final Throwables.ByteUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a byte array using the provided unary operator.
- **Parameters:**
  - `a` (`byte[]`) — the byte array to update (can be {@code null} ).
  - `operator` (`Throwables.ByteUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **See also:** #updateAll(byte\[\]\[\], Throwables.ByteUnaryOperator),for two-dimensional arrays, #updateAll(byte\[\]\[\]\[\], Throwables.ByteUnaryOperator),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void updateAll(final byte[][] a, final Throwables.ByteUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a two-dimensional byte array using the provided unary operator.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array to update (can be {@code null} or empty).
  - `operator` (`Throwables.ByteUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **See also:** #updateAll(byte\[\], Throwables.ByteUnaryOperator),for one-dimensional arrays, #updateAll(byte\[\]\[\]\[\], Throwables.ByteUnaryOperator),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void updateAll(final byte[][][] a, final Throwables.ByteUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a three-dimensional byte array using the provided unary operator.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional byte array to update (can be {@code null} or empty).
  - `operator` (`Throwables.ByteUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **See also:** #updateAll(byte\[\], Throwables.ByteUnaryOperator),for one-dimensional arrays, #updateAll(byte\[\]\[\], Throwables.ByteUnaryOperator),for two-dimensional arrays
- **Signature:** `public static <E extends Exception> void updateAll(final short[] a, final Throwables.ShortUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a short array using the provided unary operator.
- **Parameters:**
  - `a` (`short[]`) — the array to update (can be {@code null} ).
  - `operator` (`Throwables.ShortUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final short[][] a, final Throwables.ShortUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a two-dimensional short array using the provided unary operator.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional array to update (can be {@code null} ).
  - `operator` (`Throwables.ShortUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final short[][][] a, final Throwables.ShortUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a three-dimensional short array using the provided unary operator.
- **Parameters:**
  - `a` (`short[][][]`) — the three-dimensional array to update (can be {@code null} ).
  - `operator` (`Throwables.ShortUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final int[] a, final Throwables.IntUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements of the given array by applying the specified unary operator.
- **Parameters:**
  - `a` (`int[]`) — the array to be modified (can be {@code null} ).
  - `operator` (`Throwables.IntUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final int[][] a, final Throwables.IntUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements of the given two-dimensional array by applying the specified unary operator.
- **Contract:**
  - If the array is null or empty, the method returns without performing any operation.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional array to be modified.
  - `operator` (`Throwables.IntUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final int[][][] a, final Throwables.IntUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements of the given three-dimensional array by applying the specified unary operator.
- **Contract:**
  - If the array is null or empty, the method returns without performing any operation.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional array to be modified.
  - `operator` (`Throwables.IntUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final long[] a, final Throwables.LongUnaryOperator<E> operator) throws E`
- **Summary:** Updates each element of the specified long array by applying a unary operator.
- **Parameters:**
  - `a` (`long[]`) — The array to be modified (can be {@code null} ).
  - `operator` (`Throwables.LongUnaryOperator<E>`) — The unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — If the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final long[][] a, final Throwables.LongUnaryOperator<E> operator) throws E`
- **Summary:** Updates each element of the specified two-dimensional long array in-place by applying a unary operator.
- **Parameters:**
  - `a` (`long[][]`) — The two-dimensional array to be modified. The modification happens in-place.
  - `operator` (`Throwables.LongUnaryOperator<E>`) — The unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — If the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final long[][][] a, final Throwables.LongUnaryOperator<E> operator) throws E`
- **Summary:** Updates each element of the specified three-dimensional long array in-place by applying a unary operator.
- **Parameters:**
  - `a` (`long[][][]`) — The three-dimensional array to be modified. The modification happens in-place.
  - `operator` (`Throwables.LongUnaryOperator<E>`) — The unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — If the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final float[] a, final Throwables.FloatUnaryOperator<E> operator) throws E`
- **Summary:** Updates each element of the specified float array by applying a given unary operator.
- **Parameters:**
  - `a` (`float[]`) — the array to be updated (can be {@code null} ).
  - `operator` (`Throwables.FloatUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final float[][] a, final Throwables.FloatUnaryOperator<E> operator) throws E`
- **Summary:** Updates each element of the specified two-dimensional float array in-place by applying a given unary operator.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional array to be updated (can be {@code null} ).
  - `operator` (`Throwables.FloatUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final float[][][] a, final Throwables.FloatUnaryOperator<E> operator) throws E`
- **Summary:** Updates each element of the specified three-dimensional float array in-place by applying a given unary operator.
- **Parameters:**
  - `a` (`float[][][]`) — the three-dimensional array to be updated (can be {@code null} ).
  - `operator` (`Throwables.FloatUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final double[] a, final Throwables.DoubleUnaryOperator<E> operator) throws E`
- **Summary:** Updates each element of the specified double array by applying a unary operator.
- **Parameters:**
  - `a` (`double[]`) — the array to be updated (can be {@code null} ).
  - `operator` (`Throwables.DoubleUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final double[][] a, final Throwables.DoubleUnaryOperator<E> operator) throws E`
- **Summary:** Updates each element of the specified two-dimensional array in-place by applying a unary operator.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional array to be updated.
  - `operator` (`Throwables.DoubleUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
- **Signature:** `public static <E extends Exception> void updateAll(final double[][][] a, final Throwables.DoubleUnaryOperator<E> operator) throws E`
- **Summary:** Updates each element of the specified three-dimensional array in-place by applying a unary operator.
- **Parameters:**
  - `a` (`double[][][]`) — the three-dimensional array to be updated.
  - `operator` (`Throwables.DoubleUnaryOperator<E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception.
##### replaceIf(...) -> void
- **Signature:** `public static <E extends Exception> void replaceIf(final boolean[] a, final Throwables.BooleanPredicate<E> predicate, final boolean newValue) throws E`
- **Summary:** Replaces all elements in a boolean array that match the predicate with a new value.
- **Parameters:**
  - `a` (`boolean[]`) — the boolean array to modify (can be {@code null} ).
  - `predicate` (`Throwables.BooleanPredicate<E>`) — the condition to test each element (must not be {@code null} ).
  - `newValue` (`boolean`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **See also:** #replaceIf(boolean\[\]\[\], Throwables.BooleanPredicate, boolean),for two-dimensional arrays, #replaceIf(boolean\[\]\[\]\[\], Throwables.BooleanPredicate, boolean),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void replaceIf(final boolean[][] a, final Throwables.BooleanPredicate<E> predicate, final boolean newValue) throws E`
- **Summary:** Replaces all elements in a two-dimensional boolean array that match the predicate with a new value.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional boolean array to modify (can be {@code null} or empty).
  - `predicate` (`Throwables.BooleanPredicate<E>`) — the condition to test each element (must not be {@code null} ).
  - `newValue` (`boolean`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **See also:** #replaceIf(boolean\[\], Throwables.BooleanPredicate, boolean),for one-dimensional arrays, #replaceIf(boolean\[\]\[\]\[\], Throwables.BooleanPredicate, boolean),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void replaceIf(final boolean[][][] a, final Throwables.BooleanPredicate<E> predicate, final boolean newValue) throws E`
- **Summary:** Replaces all elements in a three-dimensional boolean array that match the predicate with a new value.
- **Parameters:**
  - `a` (`boolean[][][]`) — the three-dimensional boolean array to modify (can be {@code null} or empty).
  - `predicate` (`Throwables.BooleanPredicate<E>`) — the condition to test each element (must not be {@code null} ).
  - `newValue` (`boolean`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **See also:** #replaceIf(boolean\[\], Throwables.BooleanPredicate, boolean),for one-dimensional arrays, #replaceIf(boolean\[\]\[\], Throwables.BooleanPredicate, boolean),for two-dimensional arrays
- **Signature:** `public static <E extends Exception> void replaceIf(final char[] a, final Throwables.CharPredicate<E> predicate, final char newValue) throws E`
- **Summary:** Replaces each element of a character array with a new value if the element satisfies the given predicate.
- **Contract:**
  - Replaces each element of a character array with a new value if the element satisfies the given predicate.
- **Parameters:**
  - `a` (`char[]`) — The char array to modify (can be {@code null} ).
  - `predicate` (`Throwables.CharPredicate<E>`) — The condition to test for each element (must not be {@code null} ).
  - `newValue` (`char`) — The value to be placed in the array if the predicate is true.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **See also:** #replaceIf(char\[\]\[\], Throwables.CharPredicate, char),for two-dimensional arrays, #replaceIf(char\[\]\[\]\[\], Throwables.CharPredicate, char),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void replaceIf(final char[][] a, final Throwables.CharPredicate<E> predicate, final char newValue) throws E`
- **Summary:** Recursively replaces each element of a two-dimensional character array with a new value if the element satisfies the given predicate.
- **Contract:**
  - Recursively replaces each element of a two-dimensional character array with a new value if the element satisfies the given predicate.
- **Parameters:**
  - `a` (`char[][]`) — The two-dimensional char array to modify (can be {@code null} ).
  - `predicate` (`Throwables.CharPredicate<E>`) — The condition to test for each element (must not be {@code null} ).
  - `newValue` (`char`) — The value to be placed in the array if the predicate is true.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **See also:** #replaceIf(char\[\], Throwables.CharPredicate, char),for one-dimensional arrays, #replaceIf(char\[\]\[\]\[\], Throwables.CharPredicate, char),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void replaceIf(final char[][][] a, final Throwables.CharPredicate<E> predicate, final char newValue) throws E`
- **Summary:** Recursively replaces each element of a three-dimensional character array with a new value if the element satisfies the given predicate.
- **Contract:**
  - Recursively replaces each element of a three-dimensional character array with a new value if the element satisfies the given predicate.
- **Parameters:**
  - `a` (`char[][][]`) — The three-dimensional char array to modify (can be {@code null} ).
  - `predicate` (`Throwables.CharPredicate<E>`) — The condition to test for each element (must not be {@code null} ).
  - `newValue` (`char`) — The value to be placed in the array if the predicate is true.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **See also:** #replaceIf(char\[\], Throwables.CharPredicate, char),for one-dimensional arrays, #replaceIf(char\[\]\[\], Throwables.CharPredicate, char),for two-dimensional arrays
- **Signature:** `public static <E extends Exception> void replaceIf(final byte[] a, final Throwables.BytePredicate<E> predicate, final byte newValue) throws E`
- **Summary:** Replaces all elements in a byte array that match the predicate with a new value.
- **Parameters:**
  - `a` (`byte[]`) — the byte array to modify (can be {@code null} ).
  - `predicate` (`Throwables.BytePredicate<E>`) — the condition to test each element (must not be {@code null} ).
  - `newValue` (`byte`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **See also:** #replaceIf(byte\[\]\[\], Throwables.BytePredicate, byte),for two-dimensional arrays, #replaceIf(byte\[\]\[\]\[\], Throwables.BytePredicate, byte),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void replaceIf(final byte[][] a, final Throwables.BytePredicate<E> predicate, final byte newValue) throws E`
- **Summary:** Replaces all elements in a two-dimensional byte array that match the predicate with a new value.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array to modify (can be {@code null} or empty).
  - `predicate` (`Throwables.BytePredicate<E>`) — the condition to test each element (must not be {@code null} ).
  - `newValue` (`byte`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **See also:** #replaceIf(byte\[\], Throwables.BytePredicate, byte),for one-dimensional arrays, #replaceIf(byte\[\]\[\]\[\], Throwables.BytePredicate, byte),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void replaceIf(final byte[][][] a, final Throwables.BytePredicate<E> predicate, final byte newValue) throws E`
- **Summary:** Replaces all elements in a three-dimensional byte array that match the predicate with a new value.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional byte array to modify (can be {@code null} or empty).
  - `predicate` (`Throwables.BytePredicate<E>`) — the condition to test each element (must not be {@code null} ).
  - `newValue` (`byte`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **See also:** #replaceIf(byte\[\], Throwables.BytePredicate, byte),for one-dimensional arrays, #replaceIf(byte\[\]\[\], Throwables.BytePredicate, byte),for two-dimensional arrays
- **Signature:** `public static <E extends Exception> void replaceIf(final short[] a, final Throwables.ShortPredicate<E> predicate, final short newValue) throws E`
- **Summary:** Replaces elements in a short array that match the predicate with a new value.
- **Parameters:**
  - `a` (`short[]`) — the array to modify (can be {@code null} ).
  - `predicate` (`Throwables.ShortPredicate<E>`) — the predicate to test each element (must not be {@code null} ).
  - `newValue` (`short`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final short[][] a, final Throwables.ShortPredicate<E> predicate, final short newValue) throws E`
- **Summary:** Replaces elements in a two-dimensional short array that match the predicate with a new value.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional array to modify (can be {@code null} ).
  - `predicate` (`Throwables.ShortPredicate<E>`) — the predicate to test each element (must not be {@code null} ).
  - `newValue` (`short`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final short[][][] a, final Throwables.ShortPredicate<E> predicate, final short newValue) throws E`
- **Summary:** Replaces elements in a three-dimensional short array that match the predicate with a new value.
- **Parameters:**
  - `a` (`short[][][]`) — the three-dimensional array to modify (can be {@code null} ).
  - `predicate` (`Throwables.ShortPredicate<E>`) — the predicate to test each element (must not be {@code null} ).
  - `newValue` (`short`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final int[] a, final Throwables.IntPredicate<E> predicate, final int newValue) throws E`
- **Summary:** Replaces elements in the array that match the given predicate with the specified new value.
- **Parameters:**
  - `a` (`int[]`) — the array to be modified (can be {@code null} ).
  - `predicate` (`Throwables.IntPredicate<E>`) — the predicate to test each element (must not be {@code null} ).
  - `newValue` (`int`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final int[][] a, final Throwables.IntPredicate<E> predicate, final int newValue) throws E`
- **Summary:** Replaces elements in the two-dimensional array that match the given predicate with the specified new value.
- **Contract:**
  - If the array is null or empty, the method returns without performing any operation.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional array to be modified.
  - `predicate` (`Throwables.IntPredicate<E>`) — the predicate to test each element (must not be {@code null} ).
  - `newValue` (`int`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final int[][][] a, final Throwables.IntPredicate<E> predicate, final int newValue) throws E`
- **Summary:** Replaces elements in the three-dimensional array that match the given predicate with the specified new value.
- **Contract:**
  - If the array is null or empty, the method returns without performing any operation.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional array to be modified.
  - `predicate` (`Throwables.IntPredicate<E>`) — the predicate to test each element (must not be {@code null} ).
  - `newValue` (`int`) — the value to replace matching elements with.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final long[] a, final Throwables.LongPredicate<E> predicate, final long newValue) throws E`
- **Summary:** Replaces each element of a long array with a new value if it satisfies a given predicate.
- **Contract:**
  - Replaces each element of a long array with a new value if it satisfies a given predicate.
- **Parameters:**
  - `a` (`long[]`) — The array to be modified (can be {@code null} ).
  - `predicate` (`Throwables.LongPredicate<E>`) — The condition to test for each element (must not be {@code null} ).
  - `newValue` (`long`) — The value to replace with if the predicate is true.
- **Throws:**
  - `E` — If the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final long[][] a, final Throwables.LongPredicate<E> predicate, final long newValue) throws E`
- **Summary:** Replaces each element of a two-dimensional long array with a new value if it satisfies a given predicate.
- **Contract:**
  - Replaces each element of a two-dimensional long array with a new value if it satisfies a given predicate.
- **Parameters:**
  - `a` (`long[][]`) — The two-dimensional array to be modified.
  - `predicate` (`Throwables.LongPredicate<E>`) — The condition to test for each element (must not be {@code null} ).
  - `newValue` (`long`) — The value to replace with if the predicate is true.
- **Throws:**
  - `E` — If the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final long[][][] a, final Throwables.LongPredicate<E> predicate, final long newValue) throws E`
- **Summary:** Replaces each element of a three-dimensional long array with a new value if it satisfies a given predicate.
- **Contract:**
  - Replaces each element of a three-dimensional long array with a new value if it satisfies a given predicate.
- **Parameters:**
  - `a` (`long[][][]`) — The three-dimensional array to be modified.
  - `predicate` (`Throwables.LongPredicate<E>`) — The condition to test for each element (must not be {@code null} ).
  - `newValue` (`long`) — The value to replace with if the predicate is true.
- **Throws:**
  - `E` — If the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final float[] a, final Throwables.FloatPredicate<E> predicate, final float newValue) throws E`
- **Summary:** Replaces each element of a float array with the specified new value if it satisfies the given predicate.
- **Contract:**
  - Replaces each element of a float array with the specified new value if it satisfies the given predicate.
- **Parameters:**
  - `a` (`float[]`) — the array to be modified (can be {@code null} ).
  - `predicate` (`Throwables.FloatPredicate<E>`) — the condition to test for each element (must not be {@code null} ).
  - `newValue` (`float`) — the value to be placed in the array if the predicate is true.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final float[][] a, final Throwables.FloatPredicate<E> predicate, final float newValue) throws E`
- **Summary:** Replaces each element of a two-dimensional float array with the specified new value if it satisfies the given predicate.
- **Contract:**
  - Replaces each element of a two-dimensional float array with the specified new value if it satisfies the given predicate.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional array to be modified.
  - `predicate` (`Throwables.FloatPredicate<E>`) — the condition to test for each element (must not be {@code null} ).
  - `newValue` (`float`) — the value to be placed in the array if the predicate is true.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final float[][][] a, final Throwables.FloatPredicate<E> predicate, final float newValue) throws E`
- **Summary:** Replaces each element of a three-dimensional float array with the specified new value if it satisfies the given predicate.
- **Contract:**
  - Replaces each element of a three-dimensional float array with the specified new value if it satisfies the given predicate.
- **Parameters:**
  - `a` (`float[][][]`) — the three-dimensional array to be modified.
  - `predicate` (`Throwables.FloatPredicate<E>`) — the condition to test for each element (must not be {@code null} ).
  - `newValue` (`float`) — the value to be placed in the array if the predicate is true.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final double[] a, final Throwables.DoublePredicate<E> predicate, final double newValue) throws E`
- **Summary:** Replaces each element of the array with the specified new value if it satisfies the given predicate.
- **Contract:**
  - Replaces each element of the array with the specified new value if it satisfies the given predicate.
- **Parameters:**
  - `a` (`double[]`) — the array to be modified (can be {@code null} ).
  - `predicate` (`Throwables.DoublePredicate<E>`) — a predicate to apply to each element to determine if it should be replaced (must not be {@code null} ).
  - `newValue` (`double`) — the value to be placed into the array.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final double[][] a, final Throwables.DoublePredicate<E> predicate, final double newValue) throws E`
- **Summary:** Replaces each element of the two-dimensional array with the specified new value if it satisfies the given predicate.
- **Contract:**
  - Replaces each element of the two-dimensional array with the specified new value if it satisfies the given predicate.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional array to be modified.
  - `predicate` (`Throwables.DoublePredicate<E>`) — a predicate to apply to each element to determine if it should be replaced (must not be {@code null} ).
  - `newValue` (`double`) — the value to be placed into the array.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
- **Signature:** `public static <E extends Exception> void replaceIf(final double[][][] a, final Throwables.DoublePredicate<E> predicate, final double newValue) throws E`
- **Summary:** Replaces each element of the three-dimensional array with the specified new value if it satisfies the given predicate.
- **Contract:**
  - Replaces each element of the three-dimensional array with the specified new value if it satisfies the given predicate.
- **Parameters:**
  - `a` (`double[][][]`) — the three-dimensional array to be modified.
  - `predicate` (`Throwables.DoublePredicate<E>`) — a predicate to apply to each element to determine if it should be replaced (must not be {@code null} ).
  - `newValue` (`double`) — the value to be placed into the array.
- **Throws:**
  - `E` — if the {@code predicate} throws an exception.
##### reshape(...) -> boolean\[\]\[\]
- **Signature:** `public static boolean[][] reshape(final boolean[] a, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional boolean array into a two-dimensional boolean array with the specified number of columns.
- **Contract:**
  - The last row may have fewer elements if the total elements don't divide evenly.
- **Parameters:**
  - `a` (`boolean[]`) — the one-dimensional boolean array to reshape.
  - `columnCount` (`int`) — the number of columns for the reshaped array.
- **Returns:** a two-dimensional boolean array with the specified number of columns.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the number of columns is less than or equal to zero.
- **Signature:** `public static boolean[][][] reshape(final boolean[] a, final int rows, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional boolean array into a three-dimensional boolean array with the specified number of rows and columns.
- **Parameters:**
  - `a` (`boolean[]`) — the one-dimensional boolean array to reshape.
  - `rows` (`int`) — the number of rows for the reshaped subarray.
  - `columnCount` (`int`) — the number of columns for the reshaped subarray.
- **Returns:** a three-dimensional boolean array with the specified number of rows and columns.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rows <= 0} , {@code columnCount <= 0} , or {@code (long) rows * columnCount > Integer.MAX_VALUE} .
- **Signature:** `public static char[][] reshape(final char[] a, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional character array into a two-dimensional character array with a specified number of columns.
- **Contract:**
  - If the length of the input array is not a multiple of {@code columnCount} , the last sub-array will be shorter.
- **Parameters:**
  - `a` (`char[]`) — The one-dimensional character array to reshape.
  - `columnCount` (`int`) — The number of columns in the new two-dimensional array.
- **Returns:** A new two-dimensional character array.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code columnCount} is not positive.
- **Signature:** `public static char[][][] reshape(final char[] a, final int rows, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional character array into a three-dimensional character array with specified dimensions.
- **Contract:**
  - If the input array's length is not a perfect multiple of {@code rows * columnCount} , the last sub-arrays may be shorter.
- **Parameters:**
  - `a` (`char[]`) — The one-dimensional character array to reshape.
  - `rows` (`int`) — The number of rows in each two-dimensional sub-array.
  - `columnCount` (`int`) — The number of columns in each two-dimensional sub-array.
- **Returns:** A new three-dimensional character array.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rows <= 0} , {@code columnCount <= 0} , or {@code (long) rows * columnCount > Integer.MAX_VALUE} .
- **Signature:** `public static byte[][] reshape(final byte[] a, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional byte array into a two-dimensional byte array with the specified number of columns.
- **Contract:**
  - The last row may have fewer elements if the total elements don't divide evenly.
- **Parameters:**
  - `a` (`byte[]`) — the one-dimensional byte array to reshape.
  - `columnCount` (`int`) — the number of columns for the reshaped array.
- **Returns:** a two-dimensional byte array with the specified number of columns.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the number of columns is less than or equal to zero.
- **Signature:** `public static byte[][][] reshape(final byte[] a, final int rows, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional byte array into a three-dimensional byte array with the specified number of rows and columns.
- **Parameters:**
  - `a` (`byte[]`) — the one-dimensional byte array to reshape.
  - `rows` (`int`) — the number of rows for the reshaped subarray.
  - `columnCount` (`int`) — the number of columns for the reshaped subarray.
- **Returns:** a three-dimensional byte array with the specified number of rows and columns.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rows <= 0} , {@code columnCount <= 0} , or {@code (long) rows * columnCount > Integer.MAX_VALUE} .
- **Signature:** `public static short[][] reshape(final short[] a, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional short array into a two-dimensional array with the specified number of columns.
- **Contract:**
  - The last row may have fewer elements if the array length is not evenly divisible by columnCount.
- **Parameters:**
  - `a` (`short[]`) — the array to reshape.
  - `columnCount` (`int`) — the number of columns in each row.
- **Returns:** a two-dimensional array with the specified column count.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnCount is less than 1.
- **Signature:** `public static short[][][] reshape(final short[] a, final int rows, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional short array into a three-dimensional array with the specified dimensions.
- **Parameters:**
  - `a` (`short[]`) — the array to reshape.
  - `rows` (`int`) — the number of rows in each two-dimensional block.
  - `columnCount` (`int`) — the number of columns in each row.
- **Returns:** a three-dimensional array with the specified dimensions.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rows <= 0} , {@code columnCount <= 0} , or {@code (long) rows * columnCount > Integer.MAX_VALUE} .
- **Signature:** `public static int[][] reshape(final int[] a, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional array into a two-dimensional array with the specified number of columns.
- **Contract:**
  - The last row may contain fewer elements if the array length is not evenly divisible by the column count.
  - If the input array is null or empty, returns an empty two-dimensional array.
- **Parameters:**
  - `a` (`int[]`) — the one-dimensional array to reshape.
  - `columnCount` (`int`) — the number of columns in each row.
- **Returns:** a new two-dimensional array containing the reshaped data.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnCount is less than 1.
- **Signature:** `public static int[][][] reshape(final int[] a, final int rows, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional array into a three-dimensional array with the specified dimensions.
- **Contract:**
  - Each matrix may be incomplete if the array length is not evenly divisible by rows × columnCount.
  - If the input array is null or empty, returns an empty three-dimensional array.
- **Parameters:**
  - `a` (`int[]`) — the one-dimensional array to reshape.
  - `rows` (`int`) — the number of rows in each two-dimensional matrix.
  - `columnCount` (`int`) — the number of columns in each row.
- **Returns:** a new three-dimensional array containing the reshaped data.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rows <= 0} , {@code columnCount <= 0} , or {@code (long) rows * columnCount > Integer.MAX_VALUE} .
- **Signature:** `public static long[][] reshape(final long[] a, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional long array into a two-dimensional long array with a specified number of columns.
- **Contract:**
  - The last row may be shorter if the total number of elements is not a multiple of {@code columnCount} .
- **Parameters:**
  - `a` (`long[]`) — The one-dimensional array to reshape.
  - `columnCount` (`int`) — The number of columns in the resulting two-dimensional array.
- **Returns:** A new two-dimensional long array.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code columnCount} is not positive.
- **Signature:** `public static long[][][] reshape(final long[] a, final int rows, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional long array into a three-dimensional long array with a specified number of rows and columns.
- **Contract:**
  - The last sub-arrays may be shorter if the total element count is not perfectly divisible.
- **Parameters:**
  - `a` (`long[]`) — The one-dimensional array to reshape.
  - `rows` (`int`) — The number of rows in each two-dimensional sub-array.
  - `columnCount` (`int`) — The number of columns in each two-dimensional sub-array.
- **Returns:** A new three-dimensional long array.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rows <= 0} , {@code columnCount <= 0} , or {@code (long) rows * columnCount > Integer.MAX_VALUE} .
- **Signature:** `public static float[][] reshape(final float[] a, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional float array into a two-dimensional float array with the specified number of columns.
- **Contract:**
  - The last row of the resulting two-dimensional array may have fewer elements if the length of the input array is not a multiple of {@code columnCount} .
- **Parameters:**
  - `a` (`float[]`) — the one-dimensional array to reshape.
  - `columnCount` (`int`) — the number of columns in the new two-dimensional array.
- **Returns:** a new two-dimensional array containing the elements of the input array.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code columnCount} is not positive.
- **Signature:** `public static float[][][] reshape(final float[] a, final int rows, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional float array into a three-dimensional float array with the specified number of rows and columns.
- **Contract:**
  - The last sub-array may be smaller if the total number of elements is not a multiple of {@code rows * columnCount} .
- **Parameters:**
  - `a` (`float[]`) — the one-dimensional array to reshape.
  - `rows` (`int`) — the number of rows in each two-dimensional sub-array.
  - `columnCount` (`int`) — the number of columns in each two-dimensional sub-array.
- **Returns:** a new three-dimensional array containing the elements of the input array.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rows <= 0} , {@code columnCount <= 0} , or {@code (long) rows * columnCount > Integer.MAX_VALUE} .
- **Signature:** `public static double[][] reshape(final double[] a, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional array into a two-dimensional array with the specified number of columns.
- **Contract:**
  - The last row may be shorter if the total number of elements is not a multiple of {@code columnCount} .
- **Parameters:**
  - `a` (`double[]`) — the one-dimensional array to reshape.
  - `columnCount` (`int`) — the number of columns in the new two-dimensional array.
- **Returns:** a new two-dimensional array.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code columnCount} is not positive.
- **Signature:** `public static double[][][] reshape(final double[] a, final int rows, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional array into a three-dimensional array with the specified number of rows and columns.
- **Contract:**
  - The last sub-arrays may be shorter if the total count is not a multiple of {@code rows * columnCount} .
- **Parameters:**
  - `a` (`double[]`) — the one-dimensional array to reshape.
  - `rows` (`int`) — the number of rows in each two-dimensional slice.
  - `columnCount` (`int`) — the number of columns in each two-dimensional slice.
- **Returns:** a new three-dimensional array.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rows <= 0} , {@code columnCount <= 0} , or {@code (long) rows * columnCount > Integer.MAX_VALUE} .
##### flatten(...) -> boolean\[\]
- **Signature:** `public static boolean[] flatten(final boolean[][] a)`
- **Summary:** Flattens a two-dimensional boolean array into a one-dimensional boolean array.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional boolean array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **See also:** #flatten(boolean\[\]\[\]\[\]),for flattening three-dimensional arrays, #flatOp(boolean\[\]\[\], Throwables.Consumer),for performing operations on flattened arrays
- **Signature:** `public static boolean[] flatten(final boolean[][][] a)`
- **Summary:** Flattens a three-dimensional boolean array into a one-dimensional boolean array.
- **Parameters:**
  - `a` (`boolean[][][]`) — the three-dimensional boolean array to flatten (can be {@code null} ).
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **See also:** #flatten(boolean\[\]\[\]),for flattening two-dimensional arrays, #flatOp(boolean\[\]\[\]\[\], Throwables.Consumer),for performing operations on flattened three-dimensional arrays
- **Signature:** `public static char[] flatten(final char[][] a)`
- **Summary:** Flattens a two-dimensional character array into a new one-dimensional character array by concatenating all its sub-arrays.
- **Parameters:**
  - `a` (`char[][]`) — The two-dimensional character array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static char[] flatten(final char[][][] a)`
- **Summary:** Flattens a three-dimensional character array into a new one-dimensional character array by concatenating all its innermost sub-arrays.
- **Parameters:**
  - `a` (`char[][][]`) — The three-dimensional character array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static byte[] flatten(final byte[][] a)`
- **Summary:** Flattens a two-dimensional byte array into a one-dimensional byte array.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static byte[] flatten(final byte[][][] a)`
- **Summary:** Flattens a three-dimensional byte array into a one-dimensional byte array.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional byte array to flatten (can be {@code null} ).
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static short[] flatten(final short[][] a)`
- **Summary:** Flattens a two-dimensional short array into a one-dimensional array.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static short[] flatten(final short[][][] a)`
- **Summary:** Flattens a three-dimensional short array into a one-dimensional array.
- **Parameters:**
  - `a` (`short[][][]`) — the three-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static int[] flatten(final int[][] a)`
- **Summary:** Flattens a two-dimensional array into a one-dimensional array.
- **Contract:**
  - If the input array is null or empty, returns an empty array.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static int[] flatten(final int[][][] a)`
- **Summary:** Flattens a three-dimensional array into a one-dimensional array.
- **Contract:**
  - If the input array is null or empty, returns an empty array.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static long[] flatten(final long[][] a)`
- **Summary:** Flattens a two-dimensional long array into a one-dimensional long array by concatenating its rows.
- **Parameters:**
  - `a` (`long[][]`) — The two-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static long[] flatten(final long[][][] a)`
- **Summary:** Flattens a three-dimensional long array into a one-dimensional long array by concatenating its elements in order.
- **Parameters:**
  - `a` (`long[][][]`) — The three-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static float[] flatten(final float[][] a)`
- **Summary:** Flattens a two-dimensional float array into a new one-dimensional float array.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static float[] flatten(final float[][][] a)`
- **Summary:** Flattens a three-dimensional float array into a new one-dimensional float array.
- **Parameters:**
  - `a` (`float[][][]`) — the three-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static double[] flatten(final double[][] a)`
- **Summary:** Flattens a two-dimensional array into a one-dimensional array by concatenating its rows.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
- **Signature:** `public static double[] flatten(final double[][][] a)`
- **Summary:** Flattens a three-dimensional array into a one-dimensional array by concatenating its elements in order.
- **Parameters:**
  - `a` (`double[][][]`) — the three-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array, or an empty array if input is null or empty.
##### flatOp(...) -> void
- **Signature:** `public static <E extends Exception> void flatOp(final boolean[][] a, final Throwables.Consumer<? super boolean[], E> op) throws E`
- **Summary:** Flattens a two-dimensional array, performs an operation on the resulting one-dimensional array, and then copies the modified elements back into the original two-dimensional array.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional boolean array to operate on.
  - `op` (`Throwables.Consumer<? super boolean[], E>`) — the operation to apply to the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **See also:** #flatten(boolean\[\]\[\]),for just flattening without applying operations, #flatOp(boolean\[\]\[\]\[\], Throwables.Consumer),for three-dimensional arrays
- **Signature:** `public static <E extends Exception> void flatOp(final boolean[][][] a, final Throwables.Consumer<? super boolean[], E> op) throws E`
- **Summary:** Flattens a three-dimensional array, performs an in-place operation on the resulting one-dimensional array, and then copies the modified elements back into the original three-dimensional array.
- **Parameters:**
  - `a` (`boolean[][][]`) — the three-dimensional boolean array to operate on (can be {@code null} or empty).
  - `op` (`Throwables.Consumer<? super boolean[], E>`) — the operation to apply to the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final char[][] a, final Throwables.Consumer<? super char[], E> op) throws E`
- **Summary:** Flattens a two-dimensional array, performs an operation on the resulting one-dimensional array, and then copies the modified elements back into the original two-dimensional array.
- **Parameters:**
  - `a` (`char[][]`) — The two-dimensional character array to operate on.
  - `op` (`Throwables.Consumer<? super char[], E>`) — The consumer operation to apply to the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final char[][][] a, final Throwables.Consumer<? super char[], E> op) throws E`
- **Summary:** Flattens a three-dimensional array, performs an in-place operation on the resulting one-dimensional array, and then copies the modified elements back into the original three-dimensional array.
- **Parameters:**
  - `a` (`char[][][]`) — The three-dimensional character array to operate on.
  - `op` (`Throwables.Consumer<? super char[], E>`) — The consumer operation to apply to the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final byte[][] a, final Throwables.Consumer<? super byte[], E> op) throws E`
- **Summary:** Flattens a two-dimensional array, performs an operation on the resulting one-dimensional array, and then copies the modified elements back into the original two-dimensional array.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array to operate on.
  - `op` (`Throwables.Consumer<? super byte[], E>`) — the operation to apply to the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final byte[][][] a, final Throwables.Consumer<? super byte[], E> op) throws E`
- **Summary:** Flattens a three-dimensional array, performs an in-place operation on the resulting one-dimensional array, and then copies the modified elements back into the original three-dimensional array.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional byte array to operate on (can be {@code null} or empty).
  - `op` (`Throwables.Consumer<? super byte[], E>`) — the operation to apply to the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final short[][] a, final Throwables.Consumer<? super short[], E> op) throws E`
- **Summary:** Flattens a two-dimensional array, performs an operation on the resulting one-dimensional array, and then copies the modified elements back into the original two-dimensional array.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional array to operate on.
  - `op` (`Throwables.Consumer<? super short[], E>`) — the operation to perform on the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final short[][][] a, final Throwables.Consumer<? super short[], E> op) throws E`
- **Summary:** Flattens a three-dimensional array, performs an in-place operation on the resulting one-dimensional array, and then copies the modified elements back into the original three-dimensional array.
- **Parameters:**
  - `a` (`short[][][]`) — the three-dimensional array to operate on.
  - `op` (`Throwables.Consumer<? super short[], E>`) — the operation to perform on the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final int[][] a, final Throwables.Consumer<? super int[], E> op) throws E`
- **Summary:** Flattens a two-dimensional array, performs an operation on the resulting one-dimensional array, and then copies the modified elements back into the original two-dimensional array.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional array to process.
  - `op` (`Throwables.Consumer<? super int[], E>`) — the operation to apply to the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final int[][][] a, final Throwables.Consumer<? super int[], E> op) throws E`
- **Summary:** Flattens a three-dimensional array, performs an in-place operation on the resulting one-dimensional array, and then copies the modified elements back into the original three-dimensional array.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional array to process.
  - `op` (`Throwables.Consumer<? super int[], E>`) — the operation to apply to the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final long[][] a, final Throwables.Consumer<? super long[], E> op) throws E`
- **Summary:** Flattens a two-dimensional array, performs an operation on the resulting one-dimensional array, and then copies the modified elements back into the original two-dimensional array.
- **Parameters:**
  - `a` (`long[][]`) — The two-dimensional array to operate on.
  - `op` (`Throwables.Consumer<? super long[], E>`) — The consumer to accept the flattened one-dimensional array for modification (must not be {@code null} ).
- **Throws:**
  - `E` — If the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final long[][][] a, final Throwables.Consumer<? super long[], E> op) throws E`
- **Summary:** Flattens a three-dimensional array, performs an in-place operation on the resulting one-dimensional array, and then copies the modified elements back into the original three-dimensional array.
- **Parameters:**
  - `a` (`long[][][]`) — The three-dimensional array to operate on.
  - `op` (`Throwables.Consumer<? super long[], E>`) — The consumer to accept the flattened one-dimensional array for modification (must not be {@code null} ).
- **Throws:**
  - `E` — If the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final float[][] a, final Throwables.Consumer<? super float[], E> op) throws E`
- **Summary:** Flattens a two-dimensional array, performs an operation on the resulting one-dimensional array, and then copies the modified elements back into the original two-dimensional array.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional array to operate on.
  - `op` (`Throwables.Consumer<? super float[], E>`) — the operation to perform on the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final float[][][] a, final Throwables.Consumer<? super float[], E> op) throws E`
- **Summary:** Flattens a three-dimensional array, performs an in-place operation on the resulting one-dimensional array, and then copies the modified elements back into the original three-dimensional array.
- **Parameters:**
  - `a` (`float[][][]`) — the three-dimensional array to operate on.
  - `op` (`Throwables.Consumer<? super float[], E>`) — the operation to perform on the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final double[][] a, final Throwables.Consumer<? super double[], E> op) throws E`
- **Summary:** Flattens a two-dimensional array, performs an operation on the resulting one-dimensional array, and then copies the modified elements back into the original two-dimensional array.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional array to operate on.
  - `op` (`Throwables.Consumer<? super double[], E>`) — the operation to perform on the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
- **Signature:** `public static <E extends Exception> void flatOp(final double[][][] a, final Throwables.Consumer<? super double[], E> op) throws E`
- **Summary:** Flattens a three-dimensional array, performs an in-place operation on the resulting one-dimensional array, and then copies the modified elements back into the original three-dimensional array.
- **Parameters:**
  - `a` (`double[][][]`) — the three-dimensional array to operate on.
  - `op` (`Throwables.Consumer<? super double[], E>`) — the operation to perform on the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
##### zip(...) -> boolean\[\]
- **Signature:** `public static <E extends Exception> boolean[] zip(final boolean[] a, final boolean[] b, final Throwables.BooleanBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two boolean arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shorter array is exhausted, resulting in an output array with length equal to the minimum of the two input array lengths.
  - <p> This method is useful when you want to perform element-wise operations on two arrays without worrying about length mismatches.
- **Parameters:**
  - `a` (`boolean[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`boolean[]`) — the second array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.BooleanBinaryOperator<E>`) — the function to apply to corresponding elements from both arrays (must not be {@code null} ).
- **Returns:** a new array containing the results of applying the zip function to corresponding elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> boolean[] zip(final boolean[] a, final boolean[] b, final boolean defaultValueA, final boolean defaultValueB, final Throwables.BooleanBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two boolean arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from two boolean arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
  - <p> This method is ideal when you need to process arrays of different lengths and want to provide sensible defaults for missing values rather than truncating to the shorter length.
- **Parameters:**
  - `a` (`boolean[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`boolean[]`) — the second array (can be {@code null} , treated as empty).
  - `defaultValueA` (`boolean`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`boolean`) — the default value to use when array 'b' is shorter.
  - `zipFunction` (`Throwables.BooleanBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> boolean[] zip(final boolean[] a, final boolean[] b, final boolean[] c, final Throwables.BooleanTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three boolean arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shortest array is exhausted, making this suitable for combining multiple arrays when you only care about positions where all arrays have values.
- **Parameters:**
  - `a` (`boolean[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`boolean[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`boolean[]`) — the third array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.BooleanTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new array containing the results with length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> boolean[] zip(final boolean[] a, final boolean[] b, final boolean[] c, final boolean defaultValueA, final boolean defaultValueB, final boolean valueForNoneC, final Throwables.BooleanTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three boolean arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from three boolean arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
  - This provides maximum flexibility when working with three arrays of potentially different sizes.
- **Parameters:**
  - `a` (`boolean[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`boolean[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`boolean[]`) — the third array (can be {@code null} , treated as empty).
  - `defaultValueA` (`boolean`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`boolean`) — the default value to use when array 'b' is shorter.
  - `valueForNoneC` (`boolean`) — the default value to use when array 'c' is shorter.
  - `zipFunction` (`Throwables.BooleanTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> boolean[][] zip(final boolean[][] a, final boolean[][] b, final Throwables.BooleanBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional boolean arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays (rows), stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`boolean[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`boolean[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.BooleanBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results of zipping corresponding sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> boolean[][] zip(final boolean[][] a, final boolean[][] b, final boolean defaultValueA, final boolean defaultValueB, final Throwables.BooleanBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional boolean arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Contract:**
  - For each position, if one array lacks a sub-array, a null is treated as an empty array and default values are used for all positions.
- **Parameters:**
  - `a` (`boolean[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`boolean[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`boolean`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`boolean`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.BooleanBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> boolean[][] zip(final boolean[][] a, final boolean[][] b, final boolean[][] c, final Throwables.BooleanTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional boolean arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays (rows) from all three input arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`boolean[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`boolean[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`boolean[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.BooleanTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> boolean[][] zip(final boolean[][] a, final boolean[][] b, final boolean[][] c, final boolean defaultValueA, final boolean defaultValueB, final boolean valueForNoneC, final Throwables.BooleanTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional boolean arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`boolean[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`boolean[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`boolean[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`boolean`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`boolean`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`boolean`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.BooleanTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> boolean[][][] zip(final boolean[][][] a, final boolean[][][] b, final Throwables.BooleanBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional boolean arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`boolean[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`boolean[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.BooleanBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results of zipping corresponding two-dimensional sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> boolean[][][] zip(final boolean[][][] a, final boolean[][][] b, final boolean defaultValueA, final boolean defaultValueB, final Throwables.BooleanBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional boolean arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`boolean[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`boolean[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`boolean`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`boolean`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.BooleanBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> boolean[][][] zip(final boolean[][][] a, final boolean[][][] b, final boolean[][][] c, final Throwables.BooleanTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional boolean arrays using the provided zip function.
- **Parameters:**
  - `a` (`boolean[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`boolean[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`boolean[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.BooleanTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> boolean[][][] zip(final boolean[][][] a, final boolean[][][] b, final boolean[][][] c, final boolean defaultValueA, final boolean defaultValueB, final boolean valueForNoneC, final Throwables.BooleanTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional boolean arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`boolean[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`boolean[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`boolean[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`boolean`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`boolean`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`boolean`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.BooleanTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[] zip(final char[] a, final char[] b, final Throwables.CharBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two char arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shorter array is exhausted.
- **Parameters:**
  - `a` (`char[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`char[]`) — the second array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.CharBinaryOperator<E>`) — the function to apply to corresponding elements from both arrays (must not be {@code null} ).
- **Returns:** a new array containing the results of applying the zip function to corresponding elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[] zip(final char[] a, final char[] b, final char defaultValueA, final char defaultValueB, final Throwables.CharBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two char arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from two char arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
  - When one array is shorter, the specified default value is used in place of missing elements.
  - This allows for complete processing of both arrays even when they have different lengths.
- **Parameters:**
  - `a` (`char[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`char[]`) — the second array (can be {@code null} , treated as empty).
  - `defaultValueA` (`char`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`char`) — the default value to use when array 'b' is shorter.
  - `zipFunction` (`Throwables.CharBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[] zip(final char[] a, final char[] b, final char[] c, final Throwables.CharTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three char arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shortest array is exhausted.
- **Parameters:**
  - `a` (`char[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`char[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`char[]`) — the third array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.CharTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new array containing the results with length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[] zip(final char[] a, final char[] b, final char[] c, final char defaultValueA, final char defaultValueB, final char valueForNoneC, final Throwables.CharTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three char arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from three char arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
  - When any array is shorter than the longest, the corresponding default value is used for missing elements.
- **Parameters:**
  - `a` (`char[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`char[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`char[]`) — the third array (can be {@code null} , treated as empty).
  - `defaultValueA` (`char`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`char`) — the default value to use when array 'b' is shorter.
  - `valueForNoneC` (`char`) — the default value to use when array 'c' is shorter.
  - `zipFunction` (`Throwables.CharTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[][] zip(final char[][] a, final char[][] b, final Throwables.CharBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional char arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`char[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`char[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.CharBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results of zipping corresponding sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[][] zip(final char[][] a, final char[][] b, final char defaultValueA, final char defaultValueB, final Throwables.CharBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional char arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Contract:**
  - When processing inner arrays, default values are used for any missing elements within those arrays as well.
- **Parameters:**
  - `a` (`char[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`char[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`char`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`char`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.CharBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[][] zip(final char[][] a, final char[][] b, final char[][] c, final Throwables.CharTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional char arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`char[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`char[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`char[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.CharTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[][] zip(final char[][] a, final char[][] b, final char[][] c, final char defaultValueA, final char defaultValueB, final char valueForNoneC, final Throwables.CharTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional char arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`char[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`char[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`char[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`char`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`char`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`char`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.CharTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[][][] zip(final char[][][] a, final char[][][] b, final Throwables.CharBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional char arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`char[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`char[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.CharBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results of zipping corresponding two-dimensional sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[][][] zip(final char[][][] a, final char[][][] b, final char defaultValueA, final char defaultValueB, final Throwables.CharBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional char arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`char[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`char[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`char`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`char`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.CharBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[][][] zip(final char[][][] a, final char[][][] b, final char[][][] c, final Throwables.CharTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional char arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`char[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`char[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`char[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.CharTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> char[][][] zip(final char[][][] a, final char[][][] b, final char[][][] c, final char defaultValueA, final char defaultValueB, final char valueForNoneC, final Throwables.CharTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional char arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`char[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`char[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`char[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`char`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`char`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`char`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.CharTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[] zip(final byte[] a, final byte[] b, final Throwables.ByteBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two byte arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shorter array is exhausted.
- **Parameters:**
  - `a` (`byte[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`byte[]`) — the second array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ByteBinaryOperator<E>`) — the function to apply to corresponding elements from both arrays (must not be {@code null} ).
- **Returns:** a new array containing the results of applying the zip function to corresponding elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[] zip(final byte[] a, final byte[] b, final byte defaultValueA, final byte defaultValueB, final Throwables.ByteBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two byte arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from two byte arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`byte[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`byte[]`) — the second array (can be {@code null} , treated as empty).
  - `defaultValueA` (`byte`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`byte`) — the default value to use when array 'b' is shorter.
  - `zipFunction` (`Throwables.ByteBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the length of the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[] zip(final byte[] a, final byte[] b, final byte[] c, final Throwables.ByteTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three byte arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shortest array is exhausted.
- **Parameters:**
  - `a` (`byte[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`byte[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`byte[]`) — the third array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ByteTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new array containing the results with length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[] zip(final byte[] a, final byte[] b, final byte[] c, final byte defaultValueA, final byte defaultValueB, final byte valueForNoneC, final Throwables.ByteTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three byte arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from three byte arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`byte[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`byte[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`byte[]`) — the third array (can be {@code null} , treated as empty).
  - `defaultValueA` (`byte`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`byte`) — the default value to use when array 'b' is shorter.
  - `valueForNoneC` (`byte`) — the default value to use when array 'c' is shorter.
  - `zipFunction` (`Throwables.ByteTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[][] zip(final byte[][] a, final byte[][] b, final Throwables.ByteBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional byte arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`byte[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`byte[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ByteBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results of zipping corresponding sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[][] zip(final byte[][] a, final byte[][] b, final byte defaultValueA, final byte defaultValueB, final Throwables.ByteBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional byte arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`byte[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`byte[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`byte`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`byte`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.ByteBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the length of the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[][] zip(final byte[][] a, final byte[][] b, final byte[][] c, final Throwables.ByteTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional byte arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`byte[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`byte[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`byte[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ByteTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[][] zip(final byte[][] a, final byte[][] b, final byte[][] c, final byte defaultValueA, final byte defaultValueB, final byte valueForNoneC, final Throwables.ByteTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional byte arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`byte[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`byte[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`byte[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`byte`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`byte`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`byte`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.ByteTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[][][] zip(final byte[][][] a, final byte[][][] b, final Throwables.ByteBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional byte arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`byte[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`byte[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ByteBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results of zipping corresponding two-dimensional sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[][][] zip(final byte[][][] a, final byte[][][] b, final byte defaultValueA, final byte defaultValueB, final Throwables.ByteBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional byte arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`byte[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`byte[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`byte`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`byte`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.ByteBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the length of the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[][][] zip(final byte[][][] a, final byte[][][] b, final byte[][][] c, final Throwables.ByteTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional byte arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`byte[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`byte[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`byte[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ByteTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> byte[][][] zip(final byte[][][] a, final byte[][][] b, final byte[][][] c, final byte defaultValueA, final byte defaultValueB, final byte valueForNoneC, final Throwables.ByteTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional byte arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`byte[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`byte[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`byte[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`byte`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`byte`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`byte`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.ByteTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[] zip(final short[] a, final short[] b, final Throwables.ShortBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two short arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shorter array is exhausted.
- **Parameters:**
  - `a` (`short[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`short[]`) — the second array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ShortBinaryOperator<E>`) — the function to apply to corresponding elements from both arrays (must not be {@code null} ).
- **Returns:** a new array containing the results of applying the zip function to corresponding elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[] zip(final short[] a, final short[] b, final short defaultValueA, final short defaultValueB, final Throwables.ShortBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two short arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from two short arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`short[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`short[]`) — the second array (can be {@code null} , treated as empty).
  - `defaultValueA` (`short`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`short`) — the default value to use when array 'b' is shorter.
  - `zipFunction` (`Throwables.ShortBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[] zip(final short[] a, final short[] b, final short[] c, final Throwables.ShortTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three short arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shortest array is exhausted.
- **Parameters:**
  - `a` (`short[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`short[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`short[]`) — the third array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ShortTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new array containing the results with length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[] zip(final short[] a, final short[] b, final short[] c, final short defaultValueA, final short defaultValueB, final short valueForNoneC, final Throwables.ShortTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three short arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from three short arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`short[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`short[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`short[]`) — the third array (can be {@code null} , treated as empty).
  - `defaultValueA` (`short`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`short`) — the default value to use when array 'b' is shorter.
  - `valueForNoneC` (`short`) — the default value to use when array 'c' is shorter.
  - `zipFunction` (`Throwables.ShortTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[][] zip(final short[][] a, final short[][] b, final Throwables.ShortBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional short arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`short[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`short[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ShortBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results of zipping corresponding sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[][] zip(final short[][] a, final short[][] b, final short defaultValueA, final short defaultValueB, final Throwables.ShortBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional short arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`short[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`short[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`short`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`short`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.ShortBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[][] zip(final short[][] a, final short[][] b, final short[][] c, final Throwables.ShortTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional short arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`short[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`short[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`short[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ShortTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[][] zip(final short[][] a, final short[][] b, final short[][] c, final short defaultValueA, final short defaultValueB, final short valueForNoneC, final Throwables.ShortTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional short arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`short[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`short[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`short[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`short`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`short`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`short`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.ShortTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[][][] zip(final short[][][] a, final short[][][] b, final Throwables.ShortBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional short arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`short[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`short[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ShortBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results of zipping corresponding two-dimensional sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[][][] zip(final short[][][] a, final short[][][] b, final short defaultValueA, final short defaultValueB, final Throwables.ShortBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional short arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`short[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`short[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`short`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`short`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.ShortBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[][][] zip(final short[][][] a, final short[][][] b, final short[][][] c, final Throwables.ShortTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional short arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`short[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`short[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`short[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.ShortTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> short[][][] zip(final short[][][] a, final short[][][] b, final short[][][] c, final short defaultValueA, final short defaultValueB, final short valueForNoneC, final Throwables.ShortTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional short arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`short[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`short[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`short[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`short`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`short`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`short`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.ShortTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[] zip(final int[] a, final int[] b, final Throwables.IntBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two int arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shorter array is exhausted.
- **Parameters:**
  - `a` (`int[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`int[]`) — the second array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.IntBinaryOperator<E>`) — the function to apply to corresponding elements from both arrays (must not be {@code null} ).
- **Returns:** a new array containing the results of applying the zip function to corresponding elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[] zip(final int[] a, final int[] b, final int defaultValueA, final int defaultValueB, final Throwables.IntBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two int arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from two int arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`int[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`int[]`) — the second array (can be {@code null} , treated as empty).
  - `defaultValueA` (`int`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`int`) — the default value to use when array 'b' is shorter.
  - `zipFunction` (`Throwables.IntBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[] zip(final int[] a, final int[] b, final int[] c, final Throwables.IntTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three int arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shortest array is exhausted.
- **Parameters:**
  - `a` (`int[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`int[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`int[]`) — the third array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.IntTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new array containing the results with length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[] zip(final int[] a, final int[] b, final int[] c, final int defaultValueA, final int defaultValueB, final int valueForNoneC, final Throwables.IntTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three int arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from three int arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`int[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`int[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`int[]`) — the third array (can be {@code null} , treated as empty).
  - `defaultValueA` (`int`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`int`) — the default value to use when array 'b' is shorter.
  - `valueForNoneC` (`int`) — the default value to use when array 'c' is shorter.
  - `zipFunction` (`Throwables.IntTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[][] zip(final int[][] a, final int[][] b, final Throwables.IntBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional int arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`int[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`int[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.IntBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results of zipping corresponding sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[][] zip(final int[][] a, final int[][] b, final int defaultValueA, final int defaultValueB, final Throwables.IntBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional int arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`int[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`int[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`int`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`int`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.IntBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[][] zip(final int[][] a, final int[][] b, final int[][] c, final Throwables.IntTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional int arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`int[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`int[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`int[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.IntTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[][] zip(final int[][] a, final int[][] b, final int[][] c, final int defaultValueA, final int defaultValueB, final int valueForNoneC, final Throwables.IntTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional int arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`int[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`int[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`int[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`int`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`int`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`int`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.IntTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[][][] zip(final int[][][] a, final int[][][] b, final Throwables.IntBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional int arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`int[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`int[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.IntBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results of zipping corresponding two-dimensional sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[][][] zip(final int[][][] a, final int[][][] b, final int defaultValueA, final int defaultValueB, final Throwables.IntBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional int arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`int[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`int[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`int`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`int`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.IntBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[][][] zip(final int[][][] a, final int[][][] b, final int[][][] c, final Throwables.IntTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional int arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`int[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`int[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`int[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.IntTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> int[][][] zip(final int[][][] a, final int[][][] b, final int[][][] c, final int defaultValueA, final int defaultValueB, final int valueForNoneC, final Throwables.IntTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional int arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`int[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`int[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`int[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`int`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`int`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`int`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.IntTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[] zip(final long[] a, final long[] b, final Throwables.LongBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two long arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shorter array is exhausted.
- **Parameters:**
  - `a` (`long[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`long[]`) — the second array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.LongBinaryOperator<E>`) — the function to apply to corresponding elements from both arrays (must not be {@code null} ).
- **Returns:** a new array containing the results of applying the zip function to corresponding elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[] zip(final long[] a, final long[] b, final long defaultValueA, final long defaultValueB, final Throwables.LongBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two long arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from two long arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`long[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`long[]`) — the second array (can be {@code null} , treated as empty).
  - `defaultValueA` (`long`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`long`) — the default value to use when array 'b' is shorter.
  - `zipFunction` (`Throwables.LongBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[] zip(final long[] a, final long[] b, final long[] c, final Throwables.LongTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three long arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shortest array is exhausted.
- **Parameters:**
  - `a` (`long[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`long[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`long[]`) — the third array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.LongTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new array containing the results with length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[] zip(final long[] a, final long[] b, final long[] c, final long defaultValueA, final long defaultValueB, final long valueForNoneC, final Throwables.LongTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three long arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from three long arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`long[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`long[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`long[]`) — the third array (can be {@code null} , treated as empty).
  - `defaultValueA` (`long`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`long`) — the default value to use when array 'b' is shorter.
  - `valueForNoneC` (`long`) — the default value to use when array 'c' is shorter.
  - `zipFunction` (`Throwables.LongTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[][] zip(final long[][] a, final long[][] b, final Throwables.LongBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional long arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`long[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`long[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.LongBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results of zipping corresponding sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[][] zip(final long[][] a, final long[][] b, final long defaultValueA, final long defaultValueB, final Throwables.LongBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional long arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`long[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`long[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`long`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`long`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.LongBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[][] zip(final long[][] a, final long[][] b, final long[][] c, final Throwables.LongTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional long arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`long[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`long[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`long[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.LongTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[][] zip(final long[][] a, final long[][] b, final long[][] c, final long defaultValueA, final long defaultValueB, final long valueForNoneC, final Throwables.LongTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional long arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`long[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`long[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`long[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`long`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`long`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`long`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.LongTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[][][] zip(final long[][][] a, final long[][][] b, final Throwables.LongBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional long arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`long[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`long[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.LongBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results of zipping corresponding two-dimensional sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[][][] zip(final long[][][] a, final long[][][] b, final long defaultValueA, final long defaultValueB, final Throwables.LongBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional long arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`long[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`long[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`long`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`long`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.LongBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[][][] zip(final long[][][] a, final long[][][] b, final long[][][] c, final Throwables.LongTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional long arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`long[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`long[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`long[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.LongTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> long[][][] zip(final long[][][] a, final long[][][] b, final long[][][] c, final long defaultValueA, final long defaultValueB, final long valueForNoneC, final Throwables.LongTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional long arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`long[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`long[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`long[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`long`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`long`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`long`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.LongTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[] zip(final float[] a, final float[] b, final Throwables.FloatBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two float arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shorter array is exhausted.
- **Parameters:**
  - `a` (`float[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`float[]`) — the second array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.FloatBinaryOperator<E>`) — the function to apply to corresponding elements from both arrays (must not be {@code null} ).
- **Returns:** a new array containing the results of applying the zip function to corresponding elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[] zip(final float[] a, final float[] b, final float defaultValueA, final float defaultValueB, final Throwables.FloatBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two float arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from two float arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`float[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`float[]`) — the second array (can be {@code null} , treated as empty).
  - `defaultValueA` (`float`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`float`) — the default value to use when array 'b' is shorter.
  - `zipFunction` (`Throwables.FloatBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[] zip(final float[] a, final float[] b, final float[] c, final Throwables.FloatTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three float arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shortest array is exhausted.
- **Parameters:**
  - `a` (`float[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`float[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`float[]`) — the third array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.FloatTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new array containing the results with length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[] zip(final float[] a, final float[] b, final float[] c, final float defaultValueA, final float defaultValueB, final float valueForNoneC, final Throwables.FloatTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three float arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from three float arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`float[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`float[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`float[]`) — the third array (can be {@code null} , treated as empty).
  - `defaultValueA` (`float`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`float`) — the default value to use when array 'b' is shorter.
  - `valueForNoneC` (`float`) — the default value to use when array 'c' is shorter.
  - `zipFunction` (`Throwables.FloatTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[][] zip(final float[][] a, final float[][] b, final Throwables.FloatBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional float arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`float[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`float[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.FloatBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results of zipping corresponding sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[][] zip(final float[][] a, final float[][] b, final float defaultValueA, final float defaultValueB, final Throwables.FloatBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional float arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`float[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`float[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`float`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`float`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.FloatBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[][] zip(final float[][] a, final float[][] b, final float[][] c, final Throwables.FloatTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional float arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`float[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`float[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`float[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.FloatTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[][] zip(final float[][] a, final float[][] b, final float[][] c, final float defaultValueA, final float defaultValueB, final float valueForNoneC, final Throwables.FloatTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional float arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`float[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`float[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`float[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`float`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`float`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`float`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.FloatTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[][][] zip(final float[][][] a, final float[][][] b, final Throwables.FloatBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional float arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`float[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`float[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.FloatBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results of zipping corresponding two-dimensional sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[][][] zip(final float[][][] a, final float[][][] b, final float defaultValueA, final float defaultValueB, final Throwables.FloatBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional float arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`float[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`float[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`float`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`float`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.FloatBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[][][] zip(final float[][][] a, final float[][][] b, final float[][][] c, final Throwables.FloatTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional float arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`float[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`float[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`float[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.FloatTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> float[][][] zip(final float[][][] a, final float[][][] b, final float[][][] c, final float defaultValueA, final float defaultValueB, final float valueForNoneC, final Throwables.FloatTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional float arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`float[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`float[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`float[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`float`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`float`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`float`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.FloatTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[] zip(final double[] a, final double[] b, final Throwables.DoubleBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two double arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shorter array is exhausted.
- **Parameters:**
  - `a` (`double[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`double[]`) — the second array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.DoubleBinaryOperator<E>`) — the function to apply to corresponding elements from both arrays (must not be {@code null} ).
- **Returns:** a new array containing the results of applying the zip function to corresponding elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[] zip(final double[] a, final double[] b, final double defaultValueA, final double defaultValueB, final Throwables.DoubleBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two double arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from two double arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`double[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`double[]`) — the second array (can be {@code null} , treated as empty).
  - `defaultValueA` (`double`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`double`) — the default value to use when array 'b' is shorter.
  - `zipFunction` (`Throwables.DoubleBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the length of the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[] zip(final double[] a, final double[] b, final double[] c, final Throwables.DoubleTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three double arrays using the provided zip function.
- **Contract:**
  - The operation stops when the shortest array is exhausted.
- **Parameters:**
  - `a` (`double[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`double[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`double[]`) — the third array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.DoubleTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new array containing the results with length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[] zip(final double[] a, final double[] b, final double[] c, final double defaultValueA, final double defaultValueB, final double valueForNoneC, final Throwables.DoubleTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three double arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Contract:**
  - Combines elements from three double arrays using the provided zip function, with default values for missing elements when arrays have different lengths.
- **Parameters:**
  - `a` (`double[]`) — the first array (can be {@code null} , treated as empty).
  - `b` (`double[]`) — the second array (can be {@code null} , treated as empty).
  - `c` (`double[]`) — the third array (can be {@code null} , treated as empty).
  - `defaultValueA` (`double`) — the default value to use when array 'a' is shorter.
  - `defaultValueB` (`double`) — the default value to use when array 'b' is shorter.
  - `valueForNoneC` (`double`) — the default value to use when array 'c' is shorter.
  - `zipFunction` (`Throwables.DoubleTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new array with length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[][] zip(final double[][] a, final double[][] b, final Throwables.DoubleBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional double arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`double[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`double[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.DoubleBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results of zipping corresponding sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[][] zip(final double[][] a, final double[][] b, final double defaultValueA, final double defaultValueB, final Throwables.DoubleBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional double arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`double[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`double[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`double`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`double`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.DoubleBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the length of the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[][] zip(final double[][] a, final double[][] b, final double[][] c, final Throwables.DoubleTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional double arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`double[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`double[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`double[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.DoubleTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[][] zip(final double[][] a, final double[][] b, final double[][] c, final double defaultValueA, final double defaultValueB, final double valueForNoneC, final Throwables.DoubleTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional double arrays using the provided zip function, with default values for missing elements at both the outer and inner array levels.
- **Parameters:**
  - `a` (`double[][]`) — the first two-dimensional array (can be {@code null} , treated as empty).
  - `b` (`double[][]`) — the second two-dimensional array (can be {@code null} , treated as empty).
  - `c` (`double[][]`) — the third two-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`double`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`double`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`double`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.DoubleTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[][][] zip(final double[][][] a, final double[][][] b, final Throwables.DoubleBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional double arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shorter outer array is exhausted.
- **Parameters:**
  - `a` (`double[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`double[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.DoubleBinaryOperator<E>`) — the function to apply to corresponding elements in sub-arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results of zipping corresponding two-dimensional sub-arrays.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[][][] zip(final double[][][] a, final double[][][] b, final double defaultValueA, final double defaultValueB, final Throwables.DoubleBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from two three-dimensional double arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`double[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`double[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`double`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`double`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.DoubleBinaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the length of the longer input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[][][] zip(final double[][][] a, final double[][][] b, final double[][][] c, final Throwables.DoubleTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional double arrays using the provided zip function.
- **Contract:**
  - Applies the zip operation to corresponding two-dimensional sub-arrays, stopping when the shortest outer array is exhausted.
- **Parameters:**
  - `a` (`double[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`double[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`double[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `zipFunction` (`Throwables.DoubleTernaryOperator<E>`) — the function to apply to corresponding elements from all three arrays (must not be {@code null} ).
- **Returns:** a new three-dimensional array containing the results with outer length equal to the shortest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <E extends Exception> double[][][] zip(final double[][][] a, final double[][][] b, final double[][][] c, final double defaultValueA, final double defaultValueB, final double valueForNoneC, final Throwables.DoubleTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines elements from three three-dimensional double arrays using the provided zip function, with default values for missing elements at all array levels.
- **Parameters:**
  - `a` (`double[][][]`) — the first three-dimensional array (can be {@code null} , treated as empty).
  - `b` (`double[][][]`) — the second three-dimensional array (can be {@code null} , treated as empty).
  - `c` (`double[][][]`) — the third three-dimensional array (can be {@code null} , treated as empty).
  - `defaultValueA` (`double`) — the default value to use when array 'a' or its sub-arrays are shorter.
  - `defaultValueB` (`double`) — the default value to use when array 'b' or its sub-arrays are shorter.
  - `valueForNoneC` (`double`) — the default value to use when array 'c' or its sub-arrays are shorter.
  - `zipFunction` (`Throwables.DoubleTernaryOperator<E>`) — the function to apply to corresponding elements (must not be {@code null} ).
- **Returns:** a new three-dimensional array with outer length equal to the longest input array.
- **Throws:**
  - `E` — if the zip function throws an exception.
##### totalCountOfElements(...) -> long
- **Signature:** `public static long totalCountOfElements(final boolean[][] a)`
- **Summary:** Calculates the total count of elements in a two-dimensional boolean array.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional boolean array.
- **Returns:** the total number of elements across all sub-arrays.
- **Signature:** `public static long totalCountOfElements(final boolean[][][] a)`
- **Summary:** Calculates the total count of elements in a three-dimensional boolean array.
- **Parameters:**
  - `a` (`boolean[][][]`) — the three-dimensional boolean array.
- **Returns:** the total number of elements across all sub-arrays.
- **Signature:** `public static long totalCountOfElements(final char[][] a)`
- **Summary:** Calculates the total number of characters in a two-dimensional character array.
- **Parameters:**
  - `a` (`char[][]`) — The two-dimensional character array to count.
- **Returns:** The total number of character elements in the array.
- **Signature:** `public static long totalCountOfElements(final char[][][] a)`
- **Summary:** Calculates the total number of characters in a three-dimensional character array.
- **Parameters:**
  - `a` (`char[][][]`) — The three-dimensional character array to count.
- **Returns:** The total number of character elements in the array.
- **Signature:** `public static long totalCountOfElements(final byte[][] a)`
- **Summary:** Calculates the total count of elements in a two-dimensional byte array.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array.
- **Returns:** the total count of all elements across all sub-arrays.
- **Signature:** `public static long totalCountOfElements(final byte[][][] a)`
- **Summary:** Calculates the total count of elements in a three-dimensional byte array.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional byte array.
- **Returns:** the total count of all elements across all sub-arrays.
- **Signature:** `public static long totalCountOfElements(final short[][] a)`
- **Summary:** Calculates the total number of elements in a two-dimensional short array.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional array to count elements in.
- **Returns:** the total number of elements across all sub-arrays.
- **Signature:** `public static long totalCountOfElements(final short[][][] a)`
- **Summary:** Calculates the total number of elements in a three-dimensional short array.
- **Parameters:**
  - `a` (`short[][][]`) — the three-dimensional array to count elements in (can be {@code null} ).
- **Returns:** the total number of elements across all sub-arrays, or 0 if array is {@code null} /empty.
- **Signature:** `public static long totalCountOfElements(final int[][] a)`
- **Summary:** Calculates the total number of integer elements in a two-dimensional array.
- **Parameters:**
  - `a` (`int[][]`) — The two-dimensional integer array.
- **Returns:** The total count of integer elements.
- **Signature:** `public static long totalCountOfElements(final int[][][] a)`
- **Summary:** Calculates the total number of integer elements in a three-dimensional array.
- **Parameters:**
  - `a` (`int[][][]`) — The three-dimensional integer array.
- **Returns:** The total count of integer elements.
- **Signature:** `public static long totalCountOfElements(final long[][] a)`
- **Summary:** Calculates the total number of long elements in a two-dimensional array, handling null sub-arrays.
- **Parameters:**
  - `a` (`long[][]`) — The two-dimensional array to inspect.
- **Returns:** The total count of long elements.
- **Signature:** `public static long totalCountOfElements(final long[][][] a)`
- **Summary:** Calculates the total number of long elements in a three-dimensional array, handling null sub-arrays.
- **Parameters:**
  - `a` (`long[][][]`) — The three-dimensional array to inspect.
- **Returns:** The total count of long elements.
- **Signature:** `public static long totalCountOfElements(final float[][] a)`
- **Summary:** Calculates the total number of elements in a two-dimensional float array.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional array to count elements in.
- **Returns:** the total count of elements.
- **Signature:** `public static long totalCountOfElements(final float[][][] a)`
- **Summary:** Calculates the total number of elements in a three-dimensional float array.
- **Parameters:**
  - `a` (`float[][][]`) — the three-dimensional array to count elements in.
- **Returns:** the total count of elements.
- **Signature:** `public static long totalCountOfElements(final double[][] a)`
- **Summary:** Calculates the total number of double elements in a jagged two-dimensional array.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional array.
- **Returns:** the total count of elements.
- **Signature:** `public static long totalCountOfElements(final double[][][] a)`
- **Summary:** Calculates the total number of double elements in a jagged three-dimensional array.
- **Parameters:**
  - `a` (`double[][][]`) — the three-dimensional array.
- **Returns:** the total count of elements.
##### minSubArrayLen(...) -> int
- **Signature:** `public static int minSubArrayLen(final boolean[][] a)`
- **Summary:** Finds the minimum length among all sub-arrays in a two-dimensional boolean array.
- **Contract:**
  - Returns 0 if the input array is null or empty.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional boolean array.
- **Returns:** the minimum length of sub-arrays, or 0 if array is empty.
- **Signature:** `public static int minSubArrayLen(final char[][] a)`
- **Summary:** Finds the minimum length among all sub-arrays in a two-dimensional character array.
- **Parameters:**
  - `a` (`char[][]`) — The two-dimensional character array to inspect.
- **Returns:** The minimum length of any sub-array. Returns 0 if the input array is empty or null.
- **Signature:** `public static int minSubArrayLen(final byte[][] a)`
- **Summary:** Finds the minimum length among all sub-arrays in a two-dimensional byte array.
- **Contract:**
  - Returns 0 if the input array is null or empty.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array to analyze.
- **Returns:** the minimum sub-array length, or 0 if the array is empty.
- **Signature:** `public static int minSubArrayLen(final short[][] a)`
- **Summary:** Finds the minimum length among all sub-arrays in a two-dimensional short array.
- **Contract:**
  - Returns 0 if the array is null or contains only null sub-arrays.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional array to examine.
- **Returns:** the minimum length of any sub-array, or 0 if array is {@code null} .
- **Signature:** `public static int minSubArrayLen(final int[][] a)`
- **Summary:** Finds the minimum length among all sub-arrays in a two-dimensional integer array.
- **Parameters:**
  - `a` (`int[][]`) — The two-dimensional integer array.
- **Returns:** The minimum length of a sub-array, or 0 if the input array is {@code null} or empty.
- **Signature:** `public static int minSubArrayLen(final long[][] a)`
- **Summary:** Finds the minimum length among all sub-arrays in a two-dimensional long array.
- **Parameters:**
  - `a` (`long[][]`) — The two-dimensional long array.
- **Returns:** The minimum length of a sub-array, or 0 if the input array is {@code null} or empty.
- **Signature:** `public static int minSubArrayLen(final float[][] a)`
- **Summary:** Finds the minimum length of any sub-array within a two-dimensional float array.
- **Contract:**
  - Returns 0 for null or empty input array, or if a sub-array is null.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional array to inspect.
- **Returns:** the minimum sub-array length found.
- **Signature:** `public static int minSubArrayLen(final double[][] a)`
- **Summary:** Finds the minimum length of any sub-array in a two-dimensional array.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional array.
- **Returns:** the minimum sub-array length, or 0 if the input array is {@code null} or empty.
##### maxSubArrayLen(...) -> int
- **Signature:** `public static int maxSubArrayLen(final boolean[][] a)`
- **Summary:** Finds the maximum length among all sub-arrays in a two-dimensional boolean array.
- **Contract:**
  - Returns 0 if the input array is null or empty.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional boolean array.
- **Returns:** the maximum length of sub-arrays, or 0 if array is empty.
- **Signature:** `public static int maxSubArrayLen(final char[][] a)`
- **Summary:** Finds the maximum length among all sub-arrays in a two-dimensional character array.
- **Parameters:**
  - `a` (`char[][]`) — The two-dimensional character array to inspect.
- **Returns:** The maximum length of any sub-array. Returns 0 if the input array is empty or null.
- **Signature:** `public static int maxSubArrayLen(final byte[][] a)`
- **Summary:** Finds the maximum length among all sub-arrays in a two-dimensional byte array.
- **Contract:**
  - Returns 0 if the input array is null or empty.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array to analyze.
- **Returns:** the maximum sub-array length, or 0 if the array is empty.
- **Signature:** `public static int maxSubArrayLen(final short[][] a)`
- **Summary:** Finds the maximum length among all sub-arrays in a two-dimensional short array.
- **Contract:**
  - Returns 0 if the array is null or empty.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional array to examine.
- **Returns:** the maximum length of any sub-array, or 0 if array is {@code null} or empty.
- **Signature:** `public static int maxSubArrayLen(final int[][] a)`
- **Summary:** Finds the maximum length among all sub-arrays in a two-dimensional integer array.
- **Parameters:**
  - `a` (`int[][]`) — The two-dimensional integer array.
- **Returns:** The maximum length of a sub-array, or 0 if the input array is {@code null} or empty.
- **Signature:** `public static int maxSubArrayLen(final long[][] a)`
- **Summary:** Finds the maximum length among all sub-arrays in a two-dimensional long array.
- **Parameters:**
  - `a` (`long[][]`) — The two-dimensional long array.
- **Returns:** The maximum length of a sub-array, or 0 if the input array is {@code null} or empty.
- **Signature:** `public static int maxSubArrayLen(final float[][] a)`
- **Summary:** Finds the maximum length of any sub-array within a two-dimensional float array.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional array to inspect.
- **Returns:** the maximum sub-array length found.
- **Signature:** `public static int maxSubArrayLen(final double[][] a)`
- **Summary:** Finds the maximum length of any sub-array in a two-dimensional array.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional array.
- **Returns:** the maximum sub-array length, or 0 if the input array is {@code null} or empty.
##### toBoolean(...) -> boolean\[\]
- **Signature:** `public static boolean[] toBoolean(final byte[] a)`
- **Summary:** Converts an array of bytes to an array of booleans.
- **Parameters:**
  - `a` (`byte[]`) — the array of bytes to convert.
- **Returns:** a new boolean array, or an empty array if the input is {@code null} .
- **Signature:** `public static boolean[][] toBoolean(final byte[][] a)`
- **Summary:** Converts a two-dimensional array of bytes to a two-dimensional array of booleans.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional array of bytes to convert (can be {@code null} ).
- **Returns:** a new two-dimensional boolean array, or an empty array if the input is {@code null} .
- **See also:** #toBoolean(byte\[\])
- **Signature:** `public static boolean[][][] toBoolean(final byte[][][] a)`
- **Summary:** Converts a three-dimensional array of bytes to a three-dimensional array of booleans.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional array of bytes to convert (can be {@code null} ).
- **Returns:** a new three-dimensional boolean array, or an empty array if the input is {@code null} .
- **See also:** #toBoolean(byte\[\]\[\])
- **Signature:** `public static boolean[] toBoolean(final int[] a)`
- **Summary:** Converts an array of integers to an array of booleans.
- **Parameters:**
  - `a` (`int[]`) — the array of integers to convert.
- **Returns:** a new boolean array, or an empty array if the input is {@code null} .
- **Signature:** `public static boolean[][] toBoolean(final int[][] a)`
- **Summary:** Converts a two-dimensional array of integers to a two-dimensional array of booleans.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional array of integers to convert (can be {@code null} ).
- **Returns:** a new two-dimensional boolean array, or an empty array if the input is {@code null} .
- **See also:** #toBoolean(int\[\])
- **Signature:** `public static boolean[][][] toBoolean(final int[][][] a)`
- **Summary:** Converts a three-dimensional array of integers to a three-dimensional array of booleans.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional array of integers to convert (can be {@code null} ).
- **Returns:** a new three-dimensional boolean array, or an empty array if the input is {@code null} .
- **See also:** #toBoolean(int\[\]\[\])
##### toChar(...) -> char\[\]
- **Signature:** `public static char[] toChar(final int[] a)`
- **Summary:** Converts an array of integers to an array of chars by casting.
- **Parameters:**
  - `a` (`int[]`) — the array of integers to convert.
- **Returns:** a new char array, or an empty array if the input is {@code null} .
- **Signature:** `public static char[][] toChar(final int[][] a)`
- **Summary:** Converts a two-dimensional array of integers to a two-dimensional array of chars by casting.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional array of integers to convert (can be {@code null} ).
- **Returns:** a new two-dimensional char array, or an empty array if the input is {@code null} .
- **See also:** #toChar(int\[\])
- **Signature:** `public static char[][][] toChar(final int[][][] a)`
- **Summary:** Converts a three-dimensional array of integers to a three-dimensional array of chars by casting.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional array of integers to convert (can be {@code null} ).
- **Returns:** a new three-dimensional char array, or an empty array if the input is {@code null} .
- **See also:** #toChar(int\[\]\[\])
##### toByte(...) -> byte\[\]
- **Signature:** `public static byte[] toByte(final boolean[] a)`
- **Summary:** Converts an array of booleans to an array of bytes.
- **Parameters:**
  - `a` (`boolean[]`) — the array of booleans to convert.
- **Returns:** a new byte array, or an empty array if the input is {@code null} .
- **Signature:** `public static byte[][] toByte(final boolean[][] a)`
- **Summary:** Converts a two-dimensional array of booleans to a two-dimensional array of bytes.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional array of booleans to convert (can be {@code null} ).
- **Returns:** a new two-dimensional byte array, or an empty array if the input is {@code null} .
- **See also:** #toByte(boolean\[\])
- **Signature:** `public static byte[][][] toByte(final boolean[][][] a)`
- **Summary:** Converts a three-dimensional array of booleans to a three-dimensional array of bytes.
- **Parameters:**
  - `a` (`boolean[][][]`) — the three-dimensional array of booleans to convert (can be {@code null} ).
- **Returns:** a new three-dimensional byte array, or an empty array if the input is {@code null} .
- **See also:** #toByte(boolean\[\]\[\])
##### toShort(...) -> short\[\]
- **Signature:** `public static short[] toShort(final byte[] a)`
- **Summary:** Converts an array of bytes to an array of shorts by casting.
- **Parameters:**
  - `a` (`byte[]`) — the array of bytes to convert.
- **Returns:** a new short array, or an empty array if the input is {@code null} .
- **Signature:** `public static short[][] toShort(final byte[][] a)`
- **Summary:** Converts a two-dimensional array of bytes to a two-dimensional array of shorts by casting.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional array of bytes to convert (can be {@code null} ).
- **Returns:** a new two-dimensional short array, or an empty array if the input is {@code null} .
- **See also:** #toShort(byte\[\])
- **Signature:** `public static short[][][] toShort(final byte[][][] a)`
- **Summary:** Converts a three-dimensional array of bytes to a three-dimensional array of shorts by casting.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional array of bytes to convert (can be {@code null} ).
- **Returns:** a new three-dimensional short array, or an empty array if the input is {@code null} .
- **See also:** #toShort(byte\[\]\[\])
##### toInt(...) -> int\[\]
- **Signature:** `public static int[] toInt(final boolean[] a)`
- **Summary:** Converts an array of booleans to an array of integers.
- **Parameters:**
  - `a` (`boolean[]`) — the array of booleans to convert.
- **Returns:** a new integer array, or an empty array if the input is {@code null} .
- **Signature:** `public static int[][] toInt(final boolean[][] a)`
- **Summary:** Converts a two-dimensional array of booleans to a two-dimensional array of integers.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional array of booleans to convert (can be {@code null} ).
- **Returns:** a new two-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(boolean\[\])
- **Signature:** `public static int[][][] toInt(final boolean[][][] a)`
- **Summary:** Converts a three-dimensional array of booleans to a three-dimensional array of integers.
- **Parameters:**
  - `a` (`boolean[][][]`) — the three-dimensional array of booleans to convert (can be {@code null} ).
- **Returns:** a new three-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(boolean\[\]\[\])
- **Signature:** `public static int[] toInt(final char[] a)`
- **Summary:** Converts an array of chars to an array of integers by casting.
- **Parameters:**
  - `a` (`char[]`) — the array of chars to convert.
- **Returns:** a new integer array, or an empty array if the input is {@code null} .
- **Signature:** `public static int[][] toInt(final char[][] a)`
- **Summary:** Converts a two-dimensional array of chars to a two-dimensional array of integers by casting.
- **Parameters:**
  - `a` (`char[][]`) — the two-dimensional array of chars to convert (can be {@code null} ).
- **Returns:** a new two-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(char\[\])
- **Signature:** `public static int[][][] toInt(final char[][][] a)`
- **Summary:** Converts a three-dimensional array of chars to a three-dimensional array of integers by casting.
- **Parameters:**
  - `a` (`char[][][]`) — the three-dimensional array of chars to convert (can be {@code null} ).
- **Returns:** a new three-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(char\[\]\[\])
- **Signature:** `public static int[] toInt(final byte[] a)`
- **Summary:** Converts an array of bytes to an array of integers by casting.
- **Parameters:**
  - `a` (`byte[]`) — the array of bytes to convert.
- **Returns:** a new integer array, or an empty array if the input is {@code null} .
- **Signature:** `public static int[][] toInt(final byte[][] a)`
- **Summary:** Converts a two-dimensional array of bytes to a two-dimensional array of integers by casting.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional array of bytes to convert (can be {@code null} ).
- **Returns:** a new two-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(byte\[\])
- **Signature:** `public static int[][][] toInt(final byte[][][] a)`
- **Summary:** Converts a three-dimensional array of bytes to a three-dimensional array of integers by casting.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional array of bytes to convert (can be {@code null} ).
- **Returns:** a new three-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(byte\[\]\[\])
- **Signature:** `public static int[] toInt(final short[] a)`
- **Summary:** Converts an array of shorts to an array of integers by casting.
- **Parameters:**
  - `a` (`short[]`) — the array of shorts to convert.
- **Returns:** a new integer array, or an empty array if the input is {@code null} .
- **Signature:** `public static int[][] toInt(final short[][] a)`
- **Summary:** Converts a two-dimensional array of shorts to a two-dimensional array of integers by casting.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional array of shorts to convert (can be {@code null} ).
- **Returns:** a new two-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(short\[\])
- **Signature:** `public static int[][][] toInt(final short[][][] a)`
- **Summary:** Converts a three-dimensional array of shorts to a three-dimensional array of integers by casting.
- **Parameters:**
  - `a` (`short[][][]`) — the three-dimensional array of shorts to convert (can be {@code null} ).
- **Returns:** a new three-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(short\[\]\[\])
- **Signature:** `public static int[] toInt(final float[] a)`
- **Summary:** Converts an array of floats to an array of integers by casting (truncating).
- **Parameters:**
  - `a` (`float[]`) — the array of floats to convert.
- **Returns:** a new integer array, or an empty array if the input is {@code null} .
- **Signature:** `public static int[][] toInt(final float[][] a)`
- **Summary:** Converts a two-dimensional array of floats to a two-dimensional array of integers by casting (truncating).
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional array of floats to convert (can be {@code null} ).
- **Returns:** a new two-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(float\[\])
- **Signature:** `public static int[][][] toInt(final float[][][] a)`
- **Summary:** Converts a three-dimensional array of floats to a three-dimensional array of integers by casting (truncating).
- **Parameters:**
  - `a` (`float[][][]`) — the three-dimensional array of floats to convert (can be {@code null} ).
- **Returns:** a new three-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(float\[\]\[\])
- **Signature:** `public static int[] toInt(final double[] a)`
- **Summary:** Converts an array of doubles to an array of integers by casting (truncating).
- **Parameters:**
  - `a` (`double[]`) — the array of doubles to convert.
- **Returns:** a new integer array, or an empty array if the input is {@code null} .
- **Signature:** `public static int[][] toInt(final double[][] a)`
- **Summary:** Converts a two-dimensional array of doubles to a two-dimensional array of integers by casting (truncating).
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional array of doubles to convert (can be {@code null} ).
- **Returns:** a new two-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(double\[\])
- **Signature:** `public static int[][][] toInt(final double[][][] a)`
- **Summary:** Converts a three-dimensional array of doubles to a three-dimensional array of integers by casting (truncating).
- **Parameters:**
  - `a` (`double[][][]`) — the three-dimensional array of doubles to convert (can be {@code null} ).
- **Returns:** a new three-dimensional integer array, or an empty array if the input is {@code null} .
- **See also:** #toInt(double\[\]\[\])
##### toLong(...) -> long\[\]
- **Signature:** `public static long[] toLong(final byte[] a)`
- **Summary:** Converts an array of bytes to an array of longs by casting.
- **Parameters:**
  - `a` (`byte[]`) — the array of bytes to convert.
- **Returns:** a new long array, or an empty array if the input is {@code null} .
- **Signature:** `public static long[][] toLong(final byte[][] a)`
- **Summary:** Converts a two-dimensional array of bytes to a two-dimensional array of longs by casting.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional array of bytes to convert (can be {@code null} ).
- **Returns:** a new two-dimensional long array, or an empty array if the input is {@code null} .
- **See also:** #toLong(byte\[\])
- **Signature:** `public static long[][][] toLong(final byte[][][] a)`
- **Summary:** Converts a three-dimensional array of bytes to a three-dimensional array of longs by casting.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional array of bytes to convert (can be {@code null} ).
- **Returns:** a new three-dimensional long array, or an empty array if the input is {@code null} .
- **See also:** #toLong(byte\[\]\[\])
- **Signature:** `public static long[] toLong(final short[] a)`
- **Summary:** Converts a one-dimensional {@code short} array to a one-dimensional {@code long} array.
- **Parameters:**
  - `a` (`short[]`) — the one-dimensional {@code short} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code long} array, or an empty array if the input was {@code null} .
- **Signature:** `public static long[][] toLong(final short[][] a)`
- **Summary:** Converts a two-dimensional {@code short} array to a two-dimensional {@code long} array.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional {@code short} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code long} array, or an empty array if the input was {@code null} .
- **Signature:** `public static long[][][] toLong(final short[][][] a)`
- **Summary:** Converts a three-dimensional {@code short} array to a three-dimensional {@code long} array.
- **Parameters:**
  - `a` (`short[][][]`) — the three-dimensional {@code short} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code long} array, or an empty array if the input was {@code null} .
- **Signature:** `public static long[] toLong(final int[] a)`
- **Summary:** Converts a one-dimensional {@code int} array to a one-dimensional {@code long} array.
- **Parameters:**
  - `a` (`int[]`) — the one-dimensional {@code int} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code long} array, or an empty array if the input was {@code null} .
- **Signature:** `public static long[][] toLong(final int[][] a)`
- **Summary:** Converts a two-dimensional {@code int} array to a two-dimensional {@code long} array.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional {@code int} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code long} array, or an empty array if the input was {@code null} .
- **Signature:** `public static long[][][] toLong(final int[][][] a)`
- **Summary:** Converts a three-dimensional {@code int} array to a three-dimensional {@code long} array.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional {@code int} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code long} array, or an empty array if the input was {@code null} .
- **Signature:** `public static long[] toLong(final float[] a)`
- **Summary:** Converts a one-dimensional {@code float} array to a one-dimensional {@code long} array.
- **Parameters:**
  - `a` (`float[]`) — the one-dimensional {@code float} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code long} array, or an empty array if the input was {@code null} .
- **Signature:** `public static long[][] toLong(final float[][] a)`
- **Summary:** Converts a two-dimensional {@code float} array to a two-dimensional {@code long} array.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional {@code float} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code long} array, or an empty array if the input was {@code null} .
- **Signature:** `public static long[][][] toLong(final float[][][] a)`
- **Summary:** Converts a three-dimensional {@code float} array to a three-dimensional {@code long} array.
- **Parameters:**
  - `a` (`float[][][]`) — the three-dimensional {@code float} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code long} array, or an empty array if the input was {@code null} .
- **Signature:** `public static long[] toLong(final double[] a)`
- **Summary:** Converts a one-dimensional {@code double} array to a one-dimensional {@code long} array.
- **Parameters:**
  - `a` (`double[]`) — the one-dimensional {@code double} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code long} array, or an empty array if the input was {@code null} .
- **Signature:** `public static long[][] toLong(final double[][] a)`
- **Summary:** Converts a two-dimensional {@code double} array to a two-dimensional {@code long} array.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional {@code double} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code long} array, or an empty array if the input was {@code null} .
- **Signature:** `public static long[][][] toLong(final double[][][] a)`
- **Summary:** Converts a three-dimensional {@code double} array to a three-dimensional {@code long} array.
- **Parameters:**
  - `a` (`double[][][]`) — the three-dimensional {@code double} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code long} array, or an empty array if the input was {@code null} .
##### toFloat(...) -> float\[\]
- **Signature:** `public static float[] toFloat(final byte[] a)`
- **Summary:** Converts a one-dimensional {@code byte} array to a one-dimensional {@code float} array.
- **Parameters:**
  - `a` (`byte[]`) — the one-dimensional {@code byte} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code float} array, or an empty array if the input was {@code null} .
- **Signature:** `public static float[][] toFloat(final byte[][] a)`
- **Summary:** Converts a two-dimensional {@code byte} array to a two-dimensional {@code float} array.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional {@code byte} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code float} array, or an empty array if the input was {@code null} .
- **Signature:** `public static float[][][] toFloat(final byte[][][] a)`
- **Summary:** Converts a three-dimensional {@code byte} array to a three-dimensional {@code float} array.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional {@code byte} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code float} array, or an empty array if the input was {@code null} .
- **Signature:** `public static float[] toFloat(final short[] a)`
- **Summary:** Converts a one-dimensional {@code short} array to a one-dimensional {@code float} array.
- **Parameters:**
  - `a` (`short[]`) — the one-dimensional {@code short} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code float} array, or an empty array if the input was {@code null} .
- **Signature:** `public static float[][] toFloat(final short[][] a)`
- **Summary:** Converts a two-dimensional {@code short} array to a two-dimensional {@code float} array.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional {@code short} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code float} array, or an empty array if the input was {@code null} .
- **Signature:** `public static float[][][] toFloat(final short[][][] a)`
- **Summary:** Converts a three-dimensional {@code short} array to a three-dimensional {@code float} array.
- **Parameters:**
  - `a` (`short[][][]`) — the three-dimensional {@code short} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code float} array, or an empty array if the input was {@code null} .
- **Signature:** `public static float[] toFloat(final int[] a)`
- **Summary:** Converts a one-dimensional {@code int} array to a one-dimensional {@code float} array.
- **Parameters:**
  - `a` (`int[]`) — the one-dimensional {@code int} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code float} array, or an empty array if the input was {@code null} .
- **Signature:** `public static float[][] toFloat(final int[][] a)`
- **Summary:** Converts a two-dimensional {@code int} array to a two-dimensional {@code float} array.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional {@code int} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code float} array, or an empty array if the input was {@code null} .
- **Signature:** `public static float[][][] toFloat(final int[][][] a)`
- **Summary:** Converts a three-dimensional {@code int} array to a three-dimensional {@code float} array.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional {@code int} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code float} array, or an empty array if the input was {@code null} .
- **Signature:** `public static float[] toFloat(final long[] a)`
- **Summary:** Converts a one-dimensional {@code long} array to a one-dimensional {@code float} array.
- **Parameters:**
  - `a` (`long[]`) — the one-dimensional {@code long} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code float} array, or an empty array if the input was {@code null} .
- **Signature:** `public static float[][] toFloat(final long[][] a)`
- **Summary:** Converts a two-dimensional {@code long} array to a two-dimensional {@code float} array.
- **Parameters:**
  - `a` (`long[][]`) — the two-dimensional {@code long} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code float} array, or an empty array if the input was {@code null} .
- **Signature:** `public static float[][][] toFloat(final long[][][] a)`
- **Summary:** Converts a three-dimensional {@code long} array to a three-dimensional {@code float} array.
- **Parameters:**
  - `a` (`long[][][]`) — the three-dimensional {@code long} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code float} array, or an empty array if the input was {@code null} .
##### toDouble(...) -> double\[\]
- **Signature:** `public static double[] toDouble(final byte[] a)`
- **Summary:** Converts a one-dimensional {@code byte} array to a one-dimensional {@code double} array.
- **Parameters:**
  - `a` (`byte[]`) — the one-dimensional {@code byte} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[][] toDouble(final byte[][] a)`
- **Summary:** Converts a two-dimensional {@code byte} array to a two-dimensional {@code double} array.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional {@code byte} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[][][] toDouble(final byte[][][] a)`
- **Summary:** Converts a three-dimensional {@code byte} array to a three-dimensional {@code double} array.
- **Parameters:**
  - `a` (`byte[][][]`) — the three-dimensional {@code byte} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[] toDouble(final short[] a)`
- **Summary:** Converts a one-dimensional {@code short} array to a one-dimensional {@code double} array.
- **Parameters:**
  - `a` (`short[]`) — the one-dimensional {@code short} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[][] toDouble(final short[][] a)`
- **Summary:** Converts a two-dimensional {@code short} array to a two-dimensional {@code double} array.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional {@code short} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[][][] toDouble(final short[][][] a)`
- **Summary:** Converts a three-dimensional {@code short} array to a three-dimensional {@code double} array.
- **Parameters:**
  - `a` (`short[][][]`) — the three-dimensional {@code short} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[] toDouble(final int[] a)`
- **Summary:** Converts a one-dimensional {@code int} array to a one-dimensional {@code double} array.
- **Parameters:**
  - `a` (`int[]`) — the one-dimensional {@code int} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[][] toDouble(final int[][] a)`
- **Summary:** Converts a two-dimensional {@code int} array to a two-dimensional {@code double} array.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional {@code int} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[][][] toDouble(final int[][][] a)`
- **Summary:** Converts a three-dimensional {@code int} array to a three-dimensional {@code double} array.
- **Parameters:**
  - `a` (`int[][][]`) — the three-dimensional {@code int} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[] toDouble(final long[] a)`
- **Summary:** Converts a one-dimensional {@code long} array to a one-dimensional {@code double} array.
- **Parameters:**
  - `a` (`long[]`) — the one-dimensional {@code long} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[][] toDouble(final long[][] a)`
- **Summary:** Converts a two-dimensional {@code long} array to a two-dimensional {@code double} array.
- **Parameters:**
  - `a` (`long[][]`) — the two-dimensional {@code long} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[][][] toDouble(final long[][][] a)`
- **Summary:** Converts a three-dimensional {@code long} array to a three-dimensional {@code double} array.
- **Parameters:**
  - `a` (`long[][][]`) — the three-dimensional {@code long} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[] toDouble(final float[] a)`
- **Summary:** Converts a one-dimensional {@code float} array to a one-dimensional {@code double} array.
- **Parameters:**
  - `a` (`float[]`) — the one-dimensional {@code float} array to convert. Can be {@code null} .
- **Returns:** a new one-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[][] toDouble(final float[][] a)`
- **Summary:** Converts a two-dimensional {@code float} array to a two-dimensional {@code double} array.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional {@code float} array to convert. Can be {@code null} .
- **Returns:** a new two-dimensional {@code double} array, or an empty array if the input was {@code null} .
- **Signature:** `public static double[][][] toDouble(final float[][][] a)`
- **Summary:** Converts a three-dimensional {@code float} array to a three-dimensional {@code double} array.
- **Parameters:**
  - `a` (`float[][][]`) — the three-dimensional {@code float} array to convert. Can be {@code null} .
- **Returns:** a new three-dimensional {@code double} array, or an empty array if the input was {@code null} .

#### Public Instance Methods
- (none)

### Class f (com.landawn.abacus.util.Arrays.f)
A utility class that extends {@code com.landawn.abacus.util.Arrays} providing additional mapping methods for object arrays.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### map(...) -> R\[\]
- **Signature:** `public static <T, R, E extends Exception> R[] map(final T[] a, final Throwables.Function<? super T, ? extends R, E> mapper, final Class<R> targetElementType) throws E`
- **Summary:** Maps each element of the input array to a new type using the provided mapping function.
- **Parameters:**
  - `a` (`T[]`) — the input array to map (can be {@code null} ).
  - `mapper` (`Throwables.Function<? super T, ? extends R, E>`) — the mapping function to apply to each element (must not be {@code null} ).
  - `targetElementType` (`Class<R>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a new array containing the mapped elements, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the mapping function throws an exception.
##### mapToBoolean(...) -> boolean\[\]
- **Signature:** `public static <T, E extends Exception> boolean[] mapToBoolean(final T[] a, final Throwables.ToBooleanFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of the input array to a boolean value using the provided function.
- **Parameters:**
  - `a` (`T[]`) — the input array to map (can be {@code null} ).
  - `mapper` (`Throwables.ToBooleanFunction<? super T, E>`) — the function that maps each element to a boolean (must not be {@code null} ).
- **Returns:** a boolean array containing the mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the mapping function throws an exception.
##### mapToChar(...) -> char\[\]
- **Signature:** `public static <T, E extends Exception> char[] mapToChar(final T[] a, final Throwables.ToCharFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of the input array to a char value using the provided function.
- **Parameters:**
  - `a` (`T[]`) — the input array to map (can be {@code null} ).
  - `mapper` (`Throwables.ToCharFunction<? super T, E>`) — the function that maps each element to a char (must not be {@code null} ).
- **Returns:** a char array containing the mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the mapping function throws an exception.
##### mapToByte(...) -> byte\[\]
- **Signature:** `public static <T, E extends Exception> byte[] mapToByte(final T[] a, final Throwables.ToByteFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of the input array to a byte value using the provided function.
- **Parameters:**
  - `a` (`T[]`) — the input array to map (can be {@code null} ).
  - `mapper` (`Throwables.ToByteFunction<? super T, E>`) — the function that maps each element to a byte (must not be {@code null} ).
- **Returns:** a byte array containing the mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the mapping function throws an exception.
##### mapToShort(...) -> short\[\]
- **Signature:** `public static <T, E extends Exception> short[] mapToShort(final T[] a, final Throwables.ToShortFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of the input array to a short value using the provided function.
- **Parameters:**
  - `a` (`T[]`) — the input array to map (can be {@code null} ).
  - `mapper` (`Throwables.ToShortFunction<? super T, E>`) — the function that maps each element to a short (must not be {@code null} ).
- **Returns:** a short array containing the mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the mapping function throws an exception.
##### mapToInt(...) -> int\[\]
- **Signature:** `public static <T, E extends Exception> int[] mapToInt(final T[] a, final Throwables.ToIntFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of the input array to an int value using the provided function.
- **Parameters:**
  - `a` (`T[]`) — the input array to map.
  - `mapper` (`Throwables.ToIntFunction<? super T, E>`) — the function that maps each element to an int (must not be {@code null} ).
- **Returns:** an int array containing the mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the mapping function throws an exception.
##### mapToLong(...) -> long\[\]
- **Signature:** `public static <T, E extends Exception> long[] mapToLong(final T[] a, final Throwables.ToLongFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of the input array to a long value using the provided function.
- **Parameters:**
  - `a` (`T[]`) — the input array to map.
  - `mapper` (`Throwables.ToLongFunction<? super T, E>`) — the function that maps each element to a long (must not be {@code null} ).
- **Returns:** a long array containing the mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the mapping function throws an exception.
##### mapToFloat(...) -> float\[\]
- **Signature:** `public static <T, E extends Exception> float[] mapToFloat(final T[] a, final Throwables.ToFloatFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of the input array to a float value using the provided function.
- **Parameters:**
  - `a` (`T[]`) — the input array to map.
  - `mapper` (`Throwables.ToFloatFunction<? super T, E>`) — the function that maps each element to a float (must not be {@code null} ).
- **Returns:** a float array containing the mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the mapping function throws an exception.
##### mapToDouble(...) -> double\[\]
- **Signature:** `public static <T, E extends Exception> double[] mapToDouble(final T[] a, final Throwables.ToDoubleFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of the input array to a double value using the provided function.
- **Parameters:**
  - `a` (`T[]`) — the input array to map.
  - `mapper` (`Throwables.ToDoubleFunction<? super T, E>`) — the function that maps each element to a double (must not be {@code null} ).
- **Returns:** a double array containing the mapped values, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the mapping function throws an exception.

#### Public Instance Methods
- (none)

### Class ff (com.landawn.abacus.util.Arrays.ff)
A utility class providing functional-style operations on two-dimensional arrays.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### updateAll(...) -> void
- **Signature:** `public static <T, E extends Exception> void updateAll(final T[][] a, final Throwables.UnaryOperator<T, E> operator) throws E`
- **Summary:** Updates all elements in a two-dimensional array by applying the specified operator to each element.
- **Parameters:**
  - `a` (`T[][]`) — the two-dimensional array to update (can be {@code null} ).
  - `operator` (`Throwables.UnaryOperator<T, E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception during processing.
##### replaceIf(...) -> void
- **Signature:** `public static <T, E extends Exception> void replaceIf(final T[][] a, final Throwables.Predicate<? super T, E> predicate, final T newValue) throws E`
- **Summary:** Replaces all elements in a two-dimensional array that match the specified predicate with a new value.
- **Parameters:**
  - `a` (`T[][]`) — the two-dimensional array to modify (can be {@code null} ).
  - `predicate` (`Throwables.Predicate<? super T, E>`) — the condition to test each element against (must not be {@code null} ).
  - `newValue` (`T`) — the value to replace matching elements with (can be {@code null} ).
- **Throws:**
  - `E` — if the {@code predicate} throws an exception during testing.
##### reshape(...) -> T\[\]\[\]
- **Signature:** `public static <T> T[][] reshape(final T[] a, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional array into a two-dimensional array with the specified number of columns.
- **Contract:**
  - If the array length is not evenly divisible by the column count, the last row will contain fewer elements than specified columns.
- **Parameters:**
  - `a` (`T[]`) — the one-dimensional array to reshape.
  - `columnCount` (`int`) — the number of columns in each row.
- **Returns:** a new two-dimensional array with the specified column structure.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code columnCount} is not positive ( {@code columnCount <= 0} ).
##### flatten(...) -> T\[\]
- **Signature:** `public static <T> T[] flatten(final T[][] a) throws IllegalArgumentException`
- **Summary:** Flattens a two-dimensional array into a one-dimensional array by concatenating all sub-arrays.
- **Parameters:**
  - `a` (`T[][]`) — the two-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements from the input array.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the input array is {@code null} .
##### flatOp(...) -> void
- **Signature:** `public static <T, E extends Exception> void flatOp(final T[][] a, final Throwables.Consumer<? super T[], E> op) throws E`
- **Summary:** Performs an operation on a flattened view of a two-dimensional array, then copies the modified elements back to the original array structure.
- **Parameters:**
  - `a` (`T[][]`) — the two-dimensional array to operate on (can be {@code null} ). The operation modifies this array in-place.
  - `op` (`Throwables.Consumer<? super T[], E>`) — the consumer that operates on the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
##### map(...) -> T\[\]\[\]
- **Signature:** `public static <T, E extends Exception> T[][] map(final T[][] a, final Throwables.UnaryOperator<T, E> mapper) throws E`
- **Summary:** Maps each element of a two-dimensional array to a new value using the provided function.
- **Parameters:**
  - `a` (`T[][]`) — the source two-dimensional array (must not be {@code null} ).
  - `mapper` (`Throwables.UnaryOperator<T, E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Returns:** a new two-dimensional array with mapped elements.
- **Throws:**
  - `E` — if the function throws an exception during mapping.
- **Signature:** `public static <T, R, E extends Exception> R[][] map(final T[][] a, final Throwables.Function<? super T, ? extends R, E> mapper, final Class<R> targetElementType) throws E`
- **Summary:** Maps each element of a two-dimensional array to a new type using the provided function.
- **Parameters:**
  - `a` (`T[][]`) — the source two-dimensional array (can be {@code null} ).
  - `mapper` (`Throwables.Function<? super T, ? extends R, E>`) — the function to transform each element (must not be {@code null} ).
  - `targetElementType` (`Class<R>`) — the class of the target element type (must not be {@code null} ).
- **Returns:** a new two-dimensional array with transformed elements, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception during mapping.
##### mapToBoolean(...) -> boolean\[\]\[\]
- **Signature:** `public static <T, E extends Exception> boolean[][] mapToBoolean(final T[][] a, final Throwables.ToBooleanFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of a two-dimensional array to a boolean value using the provided predicate.
- **Parameters:**
  - `a` (`T[][]`) — the source two-dimensional array (can be {@code null} ).
  - `mapper` (`Throwables.ToBooleanFunction<? super T, E>`) — the predicate function to test each element (must not be {@code null} ).
- **Returns:** a new two-dimensional boolean array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception during mapping.
##### mapToChar(...) -> char\[\]\[\]
- **Signature:** `public static <T, E extends Exception> char[][] mapToChar(final T[][] a, final Throwables.ToCharFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of a two-dimensional array to a char value using the provided function.
- **Parameters:**
  - `a` (`T[][]`) — the source two-dimensional array (can be {@code null} ).
  - `mapper` (`Throwables.ToCharFunction<? super T, E>`) — the function to extract a char from each element (must not be {@code null} ).
- **Returns:** a new two-dimensional char array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception during mapping.
##### mapToByte(...) -> byte\[\]\[\]
- **Signature:** `public static <T, E extends Exception> byte[][] mapToByte(final T[][] a, final Throwables.ToByteFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of a two-dimensional array to a byte value using the provided function.
- **Parameters:**
  - `a` (`T[][]`) — the source two-dimensional array (can be {@code null} ).
  - `mapper` (`Throwables.ToByteFunction<? super T, E>`) — the function to convert each element to a byte (must not be {@code null} ).
- **Returns:** a new two-dimensional byte array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception during mapping.
##### mapToShort(...) -> short\[\]\[\]
- **Signature:** `public static <T, E extends Exception> short[][] mapToShort(final T[][] a, final Throwables.ToShortFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of a two-dimensional array to a short value using the provided function.
- **Parameters:**
  - `a` (`T[][]`) — the source two-dimensional array (can be {@code null} ).
  - `mapper` (`Throwables.ToShortFunction<? super T, E>`) — the function to convert each element to a short (must not be {@code null} ).
- **Returns:** a new two-dimensional short array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception during mapping.
##### mapToInt(...) -> int\[\]\[\]
- **Signature:** `public static <T, E extends Exception> int[][] mapToInt(final T[][] a, final Throwables.ToIntFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of a two-dimensional array to an int value using the provided function.
- **Parameters:**
  - `a` (`T[][]`) — the source two-dimensional array (can be {@code null} ).
  - `mapper` (`Throwables.ToIntFunction<? super T, E>`) — the function to convert each element to an int (must not be {@code null} ).
- **Returns:** a new two-dimensional int array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception during mapping.
##### mapToLong(...) -> long\[\]\[\]
- **Signature:** `public static <T, E extends Exception> long[][] mapToLong(final T[][] a, final Throwables.ToLongFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of a two-dimensional array to a long value using the provided function.
- **Parameters:**
  - `a` (`T[][]`) — the source two-dimensional array (can be {@code null} ).
  - `mapper` (`Throwables.ToLongFunction<? super T, E>`) — the function to convert each element to a long (must not be {@code null} ).
- **Returns:** a new two-dimensional long array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception during mapping.
##### mapToFloat(...) -> float\[\]\[\]
- **Signature:** `public static <T, E extends Exception> float[][] mapToFloat(final T[][] a, final Throwables.ToFloatFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of a two-dimensional array to a float value using the provided function.
- **Parameters:**
  - `a` (`T[][]`) — the source two-dimensional array (can be {@code null} ).
  - `mapper` (`Throwables.ToFloatFunction<? super T, E>`) — the function to convert each element to a float (must not be {@code null} ).
- **Returns:** a new two-dimensional float array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception during mapping.
##### mapToDouble(...) -> double\[\]\[\]
- **Signature:** `public static <T, E extends Exception> double[][] mapToDouble(final T[][] a, final Throwables.ToDoubleFunction<? super T, E> mapper) throws E`
- **Summary:** Maps each element of a two-dimensional array to a double value using the provided function.
- **Parameters:**
  - `a` (`T[][]`) — the source two-dimensional array (can be {@code null} ).
  - `mapper` (`Throwables.ToDoubleFunction<? super T, E>`) — the function to convert each element to a double (must not be {@code null} ).
- **Returns:** a new two-dimensional double array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception during mapping.
##### zip(...) -> A\[\]\[\]
- **Signature:** `public static <A, B, E extends Exception> A[][] zip(final A[][] a, final B[][] b, final Throwables.BiFunction<? super A, ? super B, A, E> zipFunction) throws E`
- **Summary:** Combines corresponding elements from two two-dimensional arrays using a binary function.
- **Contract:**
  - If arrays have different dimensions, extra elements are ignored.
- **Parameters:**
  - `a` (`A[][]`) — the first two-dimensional array.
  - `b` (`B[][]`) — the second two-dimensional array.
  - `zipFunction` (`Throwables.BiFunction<? super A, ? super B, A, E>`) — the function to combine paired elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the combined elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, R, E extends Exception> R[][] zip(final A[][] a, final B[][] b, final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines corresponding elements from two two-dimensional arrays into a new array of a specified type.
- **Parameters:**
  - `a` (`A[][]`) — the first two-dimensional array.
  - `b` (`B[][]`) — the second two-dimensional array.
  - `zipFunction` (`Throwables.BiFunction<? super A, ? super B, ? extends R, E>`) — the function to combine paired elements (must not be {@code null} ).
  - `targetElementType` (`Class<R>`) — the class of the result element type (must not be {@code null} ).
- **Returns:** a new two-dimensional array of the specified type containing combined elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, E extends Exception> A[][] zip(final A[][] a, final B[][] b, final A defaultValueA, final B defaultValueB, final Throwables.BiFunction<? super A, ? super B, A, E> zipFunction) throws E`
- **Summary:** Combines elements from two two-dimensional arrays with default values for missing elements.
- **Contract:**
  - <p> When one array is shorter than the other, the default values are used for the missing elements during combination.
- **Parameters:**
  - `a` (`A[][]`) — the first two-dimensional array. can be {@code null} .
  - `b` (`B[][]`) — the second two-dimensional array. can be {@code null} .
  - `defaultValueA` (`A`) — default value used when first array has no element at a position.
  - `defaultValueB` (`B`) — default value used when second array has no element at a position.
  - `zipFunction` (`Throwables.BiFunction<? super A, ? super B, A, E>`) — the function to combine elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with combined elements using defaults where needed.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, R, E extends Exception> R[][] zip(final A[][] a, final B[][] b, final A defaultValueA, final B defaultValueB, final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines elements from two two-dimensional arrays into a result array of a specified type, using default values for missing elements.
- **Parameters:**
  - `a` (`A[][]`) — the first two-dimensional array. can be {@code null} .
  - `b` (`B[][]`) — the second two-dimensional array. can be {@code null} .
  - `defaultValueA` (`A`) — default value for the first array.
  - `defaultValueB` (`B`) — default value for the second array.
  - `zipFunction` (`Throwables.BiFunction<? super A, ? super B, ? extends R, E>`) — the function to combine elements (must not be {@code null} ).
  - `targetElementType` (`Class<R>`) — the class of the result element type (must not be {@code null} ).
- **Returns:** a new two-dimensional array of the specified type with combined elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, C, E extends Exception> A[][] zip(final A[][] a, final B[][] b, final C[][] c, final Throwables.TriFunction<? super A, ? super B, ? super C, A, E> zipFunction) throws E`
- **Summary:** Combines corresponding elements from three two-dimensional arrays using a tri-function.
- **Parameters:**
  - `a` (`A[][]`) — the first two-dimensional array.
  - `b` (`B[][]`) — the second two-dimensional array.
  - `c` (`C[][]`) — the third two-dimensional array.
  - `zipFunction` (`Throwables.TriFunction<? super A, ? super B, ? super C, A, E>`) — the function to combine three elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array containing the combined elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, C, R, E extends Exception> R[][] zip(final A[][] a, final B[][] b, final C[][] c, final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines elements from three two-dimensional arrays into a new array of a specified type.
- **Contract:**
  - This method allows flexible type transformation when combining three arrays.
- **Parameters:**
  - `a` (`A[][]`) — the first two-dimensional array.
  - `b` (`B[][]`) — the second two-dimensional array.
  - `c` (`C[][]`) — the third two-dimensional array.
  - `zipFunction` (`Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E>`) — the function to combine three elements (must not be {@code null} ).
  - `targetElementType` (`Class<R>`) — the class of the result element type (must not be {@code null} ).
- **Returns:** a new two-dimensional array of the specified type.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, C, E extends Exception> A[][] zip(final A[][] a, final B[][] b, final C[][] c, final A defaultValueA, final B defaultValueB, final C valueForNoneC, final Throwables.TriFunction<? super A, ? super B, ? super C, A, E> zipFunction) throws E`
- **Summary:** Combines elements from three two-dimensional arrays with default values for missing elements.
- **Parameters:**
  - `a` (`A[][]`) — the first two-dimensional array. can be {@code null} .
  - `b` (`B[][]`) — the second two-dimensional array. can be {@code null} .
  - `c` (`C[][]`) — the third two-dimensional array. can be {@code null} .
  - `defaultValueA` (`A`) — default value for the first array.
  - `defaultValueB` (`B`) — default value for the second array.
  - `valueForNoneC` (`C`) — default value for the third array.
  - `zipFunction` (`Throwables.TriFunction<? super A, ? super B, ? super C, A, E>`) — the function to combine three elements (must not be {@code null} ).
- **Returns:** a new two-dimensional array with combined elements using defaults where needed.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, C, R, E extends Exception> R[][] zip(final A[][] a, final B[][] b, final C[][] c, final A defaultValueA, final B defaultValueB, final C valueForNoneC, final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines elements from three two-dimensional arrays into a result array of a specified type, using default values for missing elements.
- **Parameters:**
  - `a` (`A[][]`) — the first two-dimensional array. can be {@code null} .
  - `b` (`B[][]`) — the second two-dimensional array. can be {@code null} .
  - `c` (`C[][]`) — the third two-dimensional array. can be {@code null} .
  - `defaultValueA` (`A`) — default value for the first array.
  - `defaultValueB` (`B`) — default value for the second array.
  - `valueForNoneC` (`C`) — default value for the third array.
  - `zipFunction` (`Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E>`) — the function to combine three elements (must not be {@code null} ).
  - `targetElementType` (`Class<R>`) — the class of the result element type (must not be {@code null} ).
- **Returns:** a new two-dimensional array of the specified type with combined elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
##### totalCountOfElements(...) -> long
- **Signature:** `public static long totalCountOfElements(final Object[][] a)`
- **Summary:** Calculates the total number of elements across all sub-arrays in a two-dimensional array.
- **Parameters:**
  - `a` (`Object[][]`) — the two-dimensional array to count elements in. can be {@code null} .
- **Returns:** the total number of elements across all sub-arrays, or 0 if the array is {@code null} .
##### minSubArrayLen(...) -> int
- **Signature:** `public static int minSubArrayLen(final Object[][] a)`
- **Summary:** Finds the minimum length among all sub-arrays in a two-dimensional array.
- **Parameters:**
  - `a` (`Object[][]`) — the two-dimensional array to examine. can be {@code null} .
- **Returns:** the minimum sub-array length, or 0 if the array is {@code null} or empty.
##### maxSubArrayLen(...) -> int
- **Signature:** `public static int maxSubArrayLen(final Object[][] a)`
- **Summary:** Finds the maximum length among all sub-arrays in a two-dimensional array.
- **Parameters:**
  - `a` (`Object[][]`) — the two-dimensional array to examine. can be {@code null} .
- **Returns:** the maximum sub-array length, or 0 if the array is {@code null} or empty.

#### Public Instance Methods
- (none)

### Class fff (com.landawn.abacus.util.Arrays.fff)
A utility class providing functional-style operations on three-dimensional arrays.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### updateAll(...) -> void
- **Signature:** `public static <T, E extends Exception> void updateAll(final T[][][] a, final Throwables.UnaryOperator<T, E> operator) throws E`
- **Summary:** Updates all elements in a three-dimensional array by applying the specified unary operator to each element.
- **Parameters:**
  - `a` (`T[][][]`) — the three-dimensional array to update (can be {@code null} ).
  - `operator` (`Throwables.UnaryOperator<T, E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Throws:**
  - `E` — if the {@code operator} throws an exception during execution.
##### replaceIf(...) -> void
- **Signature:** `public static <T, E extends Exception> void replaceIf(final T[][][] a, final Throwables.Predicate<? super T, E> predicate, final T newValue) throws E`
- **Summary:** Replaces all elements in a three-dimensional array that satisfy the given predicate with the specified new value.
- **Parameters:**
  - `a` (`T[][][]`) — the three-dimensional array to modify (can be {@code null} ).
  - `predicate` (`Throwables.Predicate<? super T, E>`) — the condition to test for each element. Elements that match will be replaced (must not be {@code null} ).
  - `newValue` (`T`) — the value to replace matching elements with (can be {@code null} ).
- **Throws:**
  - `E` — if the {@code predicate} throws an exception during evaluation.
##### reshape(...) -> T\[\]\[\]\[\]
- **Signature:** `public static <T> T[][][] reshape(final T[] a, final int rows, final int columnCount) throws IllegalArgumentException`
- **Summary:** Reshapes a one-dimensional array into a three-dimensional array with the specified dimensions.
- **Contract:**
  - If the total number of elements doesn't evenly divide into the specified dimensions, the last slices may be partially filled.
- **Parameters:**
  - `a` (`T[]`) — the one-dimensional array to reshape.
  - `rows` (`int`) — the number of rows for each two-dimensional slice. Must be positive.
  - `columnCount` (`int`) — the number of columns for each two-dimensional slice. Must be positive.
- **Returns:** a new three-dimensional array containing all elements from the input.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rows <= 0} , {@code columnCount <= 0} , or {@code (long) rows * columnCount > Integer.MAX_VALUE} .
##### flatten(...) -> T\[\]
- **Signature:** `public static <T> T[] flatten(final T[][][] a) throws IllegalArgumentException`
- **Summary:** Flattens a three-dimensional array into a one-dimensional array by concatenating all elements in their natural order.
- **Parameters:**
  - `a` (`T[][][]`) — the three-dimensional array to flatten.
- **Returns:** a new one-dimensional array containing all elements in order.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the input array is null.
##### flatOp(...) -> void
- **Signature:** `public static <T, E extends Exception> void flatOp(final T[][][] a, final Throwables.Consumer<? super T[], E> op) throws E`
- **Summary:** Flattens a three-dimensional array, applies an operation to the flattened result, then copies the modified elements back into the original three-dimensional structure.
- **Parameters:**
  - `a` (`T[][][]`) — the three-dimensional array to operate on. Modified in-place.
  - `op` (`Throwables.Consumer<? super T[], E>`) — the consumer operation to apply to the flattened array (must not be {@code null} ).
- **Throws:**
  - `E` — if the operation throws an exception.
##### map(...) -> T\[\]\[\]\[\]
- **Signature:** `public static <T, E extends Exception> T[][][] map(final T[][][] a, final Throwables.UnaryOperator<T, E> mapper) throws E`
- **Summary:** Maps each element in a three-dimensional array to a new value using the provided unary operator, creating a new array with the same structure but transformed elements.
- **Parameters:**
  - `a` (`T[][][]`) — the source three-dimensional array. must not be {@code null} .
  - `mapper` (`Throwables.UnaryOperator<T, E>`) — the unary operator to apply to each element (must not be {@code null} ).
- **Returns:** a new array with mapped elements.
- **Throws:**
  - `E` — if the function throws an exception.
- **Signature:** `public static <T, R, E extends Exception> R[][][] map(final T[][][] a, final Throwables.Function<? super T, ? extends R, E> mapper, final Class<R> targetElementType) throws E`
- **Summary:** Maps each element in a three-dimensional array of type T to a new three-dimensional array of type R by applying a transformation function.
- **Parameters:**
  - `a` (`T[][][]`) — the source three-dimensional array. can be {@code null} .
  - `mapper` (`Throwables.Function<? super T, ? extends R, E>`) — the function to transform each element (must not be {@code null} ).
  - `targetElementType` (`Class<R>`) — the class of the result array's element type (must not be {@code null} ).
- **Returns:** a new array with transformed elements, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception.
##### mapToBoolean(...) -> boolean\[\]\[\]\[\]
- **Signature:** `public static <T, E extends Exception> boolean[][][] mapToBoolean(final T[][][] a, final Throwables.ToBooleanFunction<? super T, E> mapper) throws E`
- **Summary:** Maps a three-dimensional array to a three-dimensional boolean array by applying a predicate function to each element.
- **Parameters:**
  - `a` (`T[][][]`) — the source three-dimensional array. can be {@code null} .
  - `mapper` (`Throwables.ToBooleanFunction<? super T, E>`) — the predicate function to test each element (must not be {@code null} ).
- **Returns:** a new boolean array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception.
##### mapToChar(...) -> char\[\]\[\]\[\]
- **Signature:** `public static <T, E extends Exception> char[][][] mapToChar(final T[][][] a, final Throwables.ToCharFunction<? super T, E> mapper) throws E`
- **Summary:** Maps a three-dimensional array to a three-dimensional char array by applying a function that extracts or computes a char value from each element.
- **Contract:**
  - <p> This method is particularly useful when working with string data where you need to extract specific characters or perform character-based transformations.
- **Parameters:**
  - `a` (`T[][][]`) — the source three-dimensional array. can be {@code null} .
  - `mapper` (`Throwables.ToCharFunction<? super T, E>`) — the function to extract a char from each element (must not be {@code null} ).
- **Returns:** a new char array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception.
##### mapToByte(...) -> byte\[\]\[\]\[\]
- **Signature:** `public static <T, E extends Exception> byte[][][] mapToByte(final T[][][] a, final Throwables.ToByteFunction<? super T, E> mapper) throws E`
- **Summary:** Maps a three-dimensional array to a three-dimensional byte array by applying a function that converts each element to a byte value.
- **Contract:**
  - Useful for data compression or when working with byte-oriented operations.
  - <p> Care should be taken to ensure that the conversion doesn't result in data loss due to byte's limited range (-128 to 127).
- **Parameters:**
  - `a` (`T[][][]`) — the source three-dimensional array. can be {@code null} .
  - `mapper` (`Throwables.ToByteFunction<? super T, E>`) — the function to convert each element to byte (must not be {@code null} ).
- **Returns:** a new byte array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception.
##### mapToShort(...) -> short\[\]\[\]\[\]
- **Signature:** `public static <T, E extends Exception> short[][][] mapToShort(final T[][][] a, final Throwables.ToShortFunction<? super T, E> mapper) throws E`
- **Summary:** Maps a three-dimensional array to a three-dimensional short array by applying a function that converts each element to a short value.
- **Contract:**
  - This is useful when working with numeric data that fits within the short range.
- **Parameters:**
  - `a` (`T[][][]`) — the source three-dimensional array. can be {@code null} .
  - `mapper` (`Throwables.ToShortFunction<? super T, E>`) — the function to convert each element to short (must not be {@code null} ).
- **Returns:** a new short array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception.
##### mapToInt(...) -> int\[\]\[\]\[\]
- **Signature:** `public static <T, E extends Exception> int[][][] mapToInt(final T[][][] a, final Throwables.ToIntFunction<? super T, E> mapper) throws E`
- **Summary:** Maps a three-dimensional array to a three-dimensional int array by applying a function that converts each element to an integer.
- **Parameters:**
  - `a` (`T[][][]`) — the source three-dimensional array. can be {@code null} .
  - `mapper` (`Throwables.ToIntFunction<? super T, E>`) — the function to convert each element to int (must not be {@code null} ).
- **Returns:** a new int array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception.
##### mapToLong(...) -> long\[\]\[\]\[\]
- **Signature:** `public static <T, E extends Exception> long[][][] mapToLong(final T[][][] a, final Throwables.ToLongFunction<? super T, E> mapper) throws E`
- **Summary:** Maps a three-dimensional array to a three-dimensional long array by applying a function that converts each element to a long value.
- **Parameters:**
  - `a` (`T[][][]`) — the source three-dimensional array. can be {@code null} .
  - `mapper` (`Throwables.ToLongFunction<? super T, E>`) — the function to convert each element to long (must not be {@code null} ).
- **Returns:** a new long array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception.
##### mapToFloat(...) -> float\[\]\[\]\[\]
- **Signature:** `public static <T, E extends Exception> float[][][] mapToFloat(final T[][][] a, final Throwables.ToFloatFunction<? super T, E> mapper) throws E`
- **Summary:** Maps a three-dimensional array to a three-dimensional float array by applying a function that converts each element to a float value.
- **Parameters:**
  - `a` (`T[][][]`) — the source three-dimensional array. can be {@code null} .
  - `mapper` (`Throwables.ToFloatFunction<? super T, E>`) — the function to convert each element to float (must not be {@code null} ).
- **Returns:** a new float array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception.
##### mapToDouble(...) -> double\[\]\[\]\[\]
- **Signature:** `public static <T, E extends Exception> double[][][] mapToDouble(final T[][][] a, final Throwables.ToDoubleFunction<? super T, E> mapper) throws E`
- **Summary:** Maps a three-dimensional array to a three-dimensional double array by applying a function that converts each element to a double value.
- **Parameters:**
  - `a` (`T[][][]`) — the source three-dimensional array. can be {@code null} .
  - `mapper` (`Throwables.ToDoubleFunction<? super T, E>`) — the function to convert each element to double (must not be {@code null} ).
- **Returns:** a new double array, or an empty array if input is {@code null} .
- **Throws:**
  - `E` — if the function throws an exception.
##### zip(...) -> A\[\]\[\]\[\]
- **Signature:** `public static <A, B, E extends Exception> A[][][] zip(final A[][][] a, final B[][][] b, final Throwables.BiFunction<? super A, ? super B, A, E> zipFunction) throws E`
- **Summary:** Combines two three-dimensional arrays element-wise using a binary function.
- **Parameters:**
  - `a` (`A[][][]`) — the first three-dimensional array.
  - `b` (`B[][][]`) — the second three-dimensional array.
  - `zipFunction` (`Throwables.BiFunction<? super A, ? super B, A, E>`) — the binary function to combine corresponding elements (must not be {@code null} ).
- **Returns:** a new array with combined elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, R, E extends Exception> R[][][] zip(final A[][][] a, final B[][][] b, final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines two three-dimensional arrays element-wise using a binary function, producing a result array of a specified type.
- **Parameters:**
  - `a` (`A[][][]`) — the first three-dimensional array.
  - `b` (`B[][][]`) — the second three-dimensional array.
  - `zipFunction` (`Throwables.BiFunction<? super A, ? super B, ? extends R, E>`) — the function to combine corresponding elements (must not be {@code null} ).
  - `targetElementType` (`Class<R>`) — the class of the result array's element type (must not be {@code null} ).
- **Returns:** a new array with combined elements of type R.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, E extends Exception> A[][][] zip(final A[][][] a, final B[][][] b, final A defaultValueA, final B defaultValueB, final Throwables.BiFunction<? super A, ? super B, A, E> zipFunction) throws E`
- **Summary:** Combines two three-dimensional arrays element-wise with default values for missing elements.
- **Contract:**
  - When arrays have different dimensions, the default values are used in place of missing elements, allowing the operation to continue.
  - <p> This method is particularly useful when you want to combine arrays of different sizes without truncation, filling gaps with specified defaults.
- **Parameters:**
  - `a` (`A[][][]`) — the first three-dimensional array.
  - `b` (`B[][][]`) — the second three-dimensional array.
  - `defaultValueA` (`A`) — default value when first array element is missing.
  - `defaultValueB` (`B`) — default value when second array element is missing.
  - `zipFunction` (`Throwables.BiFunction<? super A, ? super B, A, E>`) — the function to combine elements (must not be {@code null} ).
- **Returns:** a new array with combined elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, R, E extends Exception> R[][][] zip(final A[][][] a, final B[][][] b, final A defaultValueA, final B defaultValueB, final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines two three-dimensional arrays element-wise into a result array of a specified type, using default values for missing elements.
- **Parameters:**
  - `a` (`A[][][]`) — the first three-dimensional array.
  - `b` (`B[][][]`) — the second three-dimensional array.
  - `defaultValueA` (`A`) — default value when first array element is missing.
  - `defaultValueB` (`B`) — default value when second array element is missing.
  - `zipFunction` (`Throwables.BiFunction<? super A, ? super B, ? extends R, E>`) — the function to combine elements (must not be {@code null} ).
  - `targetElementType` (`Class<R>`) — the class of the result array's element type (must not be {@code null} ).
- **Returns:** a new array with combined elements of type R.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, C, E extends Exception> A[][][] zip(final A[][][] a, final B[][][] b, final C[][][] c, final Throwables.TriFunction<? super A, ? super B, ? super C, A, E> zipFunction) throws E`
- **Summary:** Combines three three-dimensional arrays element-wise using a ternary function.
- **Parameters:**
  - `a` (`A[][][]`) — the first three-dimensional array.
  - `b` (`B[][][]`) — the second three-dimensional array.
  - `c` (`C[][][]`) — the third three-dimensional array.
  - `zipFunction` (`Throwables.TriFunction<? super A, ? super B, ? super C, A, E>`) — the ternary function to combine corresponding elements (must not be {@code null} ).
- **Returns:** a new array with combined elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, C, R, E extends Exception> R[][][] zip(final A[][][] a, final B[][][] b, final C[][][] c, final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines three three-dimensional arrays element-wise using a ternary function, producing a result array of a specified type.
- **Parameters:**
  - `a` (`A[][][]`) — the first three-dimensional array.
  - `b` (`B[][][]`) — the second three-dimensional array.
  - `c` (`C[][][]`) — the third three-dimensional array.
  - `zipFunction` (`Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E>`) — the function to combine corresponding elements (must not be {@code null} ).
  - `targetElementType` (`Class<R>`) — the class of the result array's element type (must not be {@code null} ).
- **Returns:** a new array with combined elements of type R.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, C, E extends Exception> A[][][] zip(final A[][][] a, final B[][][] b, final C[][][] c, final A defaultValueA, final B defaultValueB, final C valueForNoneC, final Throwables.TriFunction<? super A, ? super B, ? super C, A, E> zipFunction) throws E`
- **Summary:** Combines three three-dimensional arrays element-wise with default values for missing elements.
- **Parameters:**
  - `a` (`A[][][]`) — the first three-dimensional array.
  - `b` (`B[][][]`) — the second three-dimensional array.
  - `c` (`C[][][]`) — the third three-dimensional array.
  - `defaultValueA` (`A`) — default value when first array element is missing.
  - `defaultValueB` (`B`) — default value when second array element is missing.
  - `valueForNoneC` (`C`) — default value when third array element is missing.
  - `zipFunction` (`Throwables.TriFunction<? super A, ? super B, ? super C, A, E>`) — the function to combine elements (must not be {@code null} ).
- **Returns:** a new array with combined elements.
- **Throws:**
  - `E` — if the zip function throws an exception.
- **Signature:** `public static <A, B, C, R, E extends Exception> R[][][] zip(final A[][][] a, final B[][][] b, final C[][][] c, final A defaultValueA, final B defaultValueB, final C valueForNoneC, final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines three three-dimensional arrays element-wise into a result array of a specified type, using default values for missing elements.
- **Parameters:**
  - `a` (`A[][][]`) — the first three-dimensional array.
  - `b` (`B[][][]`) — the second three-dimensional array.
  - `c` (`C[][][]`) — the third three-dimensional array.
  - `defaultValueA` (`A`) — default value when first array element is missing.
  - `defaultValueB` (`B`) — default value when second array element is missing.
  - `valueForNoneC` (`C`) — default value when third array element is missing.
  - `zipFunction` (`Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E>`) — the function to combine elements (must not be {@code null} ).
  - `targetElementType` (`Class<R>`) — the class of the result array's element type (must not be {@code null} ).
- **Returns:** a new array with combined elements of type R.
- **Throws:**
  - `E` — if the zip function throws an exception.
##### totalCountOfElements(...) -> long
- **Signature:** `public static long totalCountOfElements(final Object[][][] a)`
- **Summary:** Calculates the total number of elements in a three-dimensional array.
- **Parameters:**
  - `a` (`Object[][][]`) — the three-dimensional array to count elements in.
- **Returns:** the total number of non-null elements across all dimensions.

#### Public Instance Methods
- (none)

### Class BooleanMatrix (com.landawn.abacus.util.BooleanMatrix)
A matrix implementation for boolean primitive values, providing efficient storage and operations for two-dimensional boolean arrays.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### empty(...) -> BooleanMatrix
- **Signature:** `public static BooleanMatrix empty()`
- **Summary:** Creates an empty matrix with zero rows and zero columns.
- **Parameters:**
  - (none)
- **Returns:** an empty boolean matrix
##### of(...) -> BooleanMatrix
- **Signature:** `public static BooleanMatrix of(final boolean[]... a)`
- **Summary:** Creates a BooleanMatrix from a two-dimensional boolean array.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional boolean array to create the matrix from, or null/empty for an empty matrix
- **Returns:** a new BooleanMatrix containing the provided data, or an empty BooleanMatrix if input is null or empty
##### random(...) -> BooleanMatrix
- **Signature:** `public static BooleanMatrix random(final int size)`
- **Summary:** Creates a new 1xsize matrix filled with random boolean values.
- **Parameters:**
  - `size` (`int`) — the number of columns in the new matrix
- **Returns:** a new BooleanMatrix of dimensions 1 x size filled with random values
- **Signature:** `public static BooleanMatrix random(final int rowCount, final int columnCount)`
- **Summary:** Creates a new matrix of the specified dimensions filled with random boolean values.
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
- **Returns:** a new BooleanMatrix of dimensions rowCount x columnCount filled with random values
##### repeat(...) -> BooleanMatrix
- **Signature:** `public static BooleanMatrix repeat(final int rowCount, final int columnCount, final boolean element)`
- **Summary:** Creates a new matrix of the specified dimensions where every element is the provided {@code element} .
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
  - `element` (`boolean`) — the boolean value to fill the matrix with
- **Returns:** a new BooleanMatrix of dimensions rowCount x columnCount filled with the specified element
##### diagonalLU2RD(...) -> BooleanMatrix
- **Signature:** `public static BooleanMatrix diagonalLU2RD(final boolean[] leftUp2RightDownDiagonal)`
- **Summary:** Creates a square matrix from the specified main diagonal elements (left-up to right-down).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`boolean[]`) — the array of main diagonal elements
- **Returns:** a square matrix with the specified main diagonal (n×n where n = diagonal length)
##### diagonalRU2LD(...) -> BooleanMatrix
- **Signature:** `public static BooleanMatrix diagonalRU2LD(final boolean[] rightUp2LeftDownDiagonal)`
- **Summary:** Creates a square matrix from the specified anti-diagonal elements (right-upper to left-down).
- **Parameters:**
  - `rightUp2LeftDownDiagonal` (`boolean[]`) — the array of anti-diagonal elements
- **Returns:** a square matrix with the specified anti-diagonal (n×n where n = diagonal length)
##### diagonal(...) -> BooleanMatrix
- **Signature:** `public static BooleanMatrix diagonal(final boolean[] leftUp2RightDownDiagonal, final boolean[] rightUp2LeftDownDiagonal) throws IllegalArgumentException`
- **Summary:** Creates a square matrix from the specified main diagonal and anti-diagonal elements.
- **Contract:**
  - If both arrays are provided, they must have the same length.
  - The resulting matrix has dimensions n×n where n is the length of the non-null/non-empty array (or the maximum length if both are provided).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`boolean[]`) — the array of main diagonal elements (can be null or empty)
  - `rightUp2LeftDownDiagonal` (`boolean[]`) — the array of anti-diagonal elements (can be null or empty)
- **Returns:** a square matrix with the specified diagonals, or an empty matrix if both inputs are null or empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — if both arrays are non-empty and have different lengths
##### unbox(...) -> BooleanMatrix
- **Signature:** `public static BooleanMatrix unbox(final Matrix<Boolean> x)`
- **Summary:** Converts a boxed Boolean Matrix to a primitive BooleanMatrix.
- **Contract:**
  - This conversion improves memory efficiency and performance when working with large matrices.
- **Parameters:**
  - `x` (`Matrix<Boolean>`) — the boxed Boolean Matrix to convert; must not be null
- **Returns:** a new BooleanMatrix with primitive boolean values
- **See also:** #boxed()

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public BooleanMatrix(final boolean[][] a)`
- **Summary:** Constructs a new BooleanMatrix with the specified two-dimensional boolean array.
- **Contract:**
  - If the input array is null, an empty matrix (0x0) is created.
- **Parameters:**
  - `a` (`boolean[][]`) — the two-dimensional boolean array to initialize the matrix with, or null for an empty matrix
##### componentType(...) -> Class
- **Signature:** `@SuppressWarnings("rawtypes") @Override public Class componentType()`
- **Summary:** Returns the component type of the matrix elements, which is always {@code boolean.class} .
- **Parameters:**
  - (none)
- **Returns:** {@code boolean.class}
##### get(...) -> boolean
- **Signature:** `public boolean get(final int i, final int j)`
- **Summary:** Returns the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** the element at position (rowIndex, columnIndex)
- **Signature:** `public boolean get(final Point point)`
- **Summary:** Returns the element at the specified point.
- **Parameters:**
  - `point` (`Point`) — the point containing row and column indices (must not be null)
- **Returns:** the boolean element at the specified point
- **See also:** #get(int, int)
##### set(...) -> void
- **Signature:** `public void set(final int i, final int j, final boolean val)`
- **Summary:** Sets the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
  - `val` (`boolean`) — the value to set
- **Signature:** `public void set(final Point point, final boolean val)`
- **Summary:** Sets the element at the specified point to the given value.
- **Parameters:**
  - `point` (`Point`) — the point containing row and column indices (must not be null)
  - `val` (`boolean`) — the new boolean value to set at the specified point
- **See also:** #set(int, int, boolean)
##### upOf(...) -> OptionalBoolean
- **Signature:** `public OptionalBoolean upOf(final int i, final int j)`
- **Summary:** Returns the element above the specified position, if it exists.
- **Contract:**
  - Returns the element above the specified position, if it exists.
  - This method provides safe access to the element directly above the given position without throwing an exception when at the top edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalBoolean containing the element at position (rowIndex - 1, columnIndex), or empty if rowIndex == 0
##### downOf(...) -> OptionalBoolean
- **Signature:** `public OptionalBoolean downOf(final int i, final int j)`
- **Summary:** Returns the element below the specified position, if it exists.
- **Contract:**
  - Returns the element below the specified position, if it exists.
  - This method provides safe access to the element directly below the given position without throwing an exception when at the bottom edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalBoolean containing the element at position (rowIndex + 1, columnIndex), or empty if rowIndex == rowCount - 1
##### leftOf(...) -> OptionalBoolean
- **Signature:** `public OptionalBoolean leftOf(final int i, final int j)`
- **Summary:** Returns the element to the left of the specified position, if it exists.
- **Contract:**
  - Returns the element to the left of the specified position, if it exists.
  - This method provides safe access to the element directly to the left of the given position without throwing an exception when at the leftmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalBoolean containing the element at position (rowIndex, columnIndex - 1), or empty if columnIndex == 0
##### rightOf(...) -> OptionalBoolean
- **Signature:** `public OptionalBoolean rightOf(final int i, final int j)`
- **Summary:** Returns the element to the right of the specified position, if it exists.
- **Contract:**
  - Returns the element to the right of the specified position, if it exists.
  - This method provides safe access to the element directly to the right of the given position without throwing an exception when at the rightmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalBoolean containing the element at position (rowIndex, columnIndex + 1), or empty if columnIndex == columnCount - 1
##### row(...) -> boolean\[\]
- **Signature:** `public boolean[] row(final int rowIndex) throws IllegalArgumentException`
- **Summary:** Returns the specified row as a boolean array.
- **Contract:**
  - If you need an independent copy, use {@code Arrays.copyOf(matrix.row(i), matrix.columnCount())} .
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to retrieve (0-based)
- **Returns:** the specified row array (direct reference to internal storage)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex &lt; 0 or rowIndex &gt; = rowCount
##### column(...) -> boolean\[\]
- **Signature:** `public boolean[] column(final int columnIndex) throws IllegalArgumentException`
- **Summary:** Returns a copy of the specified column as a new boolean array.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to retrieve (0-based)
- **Returns:** a new array containing the values from the specified column
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex &lt; 0 or columnIndex &gt; = columnCount
##### setRow(...) -> void
- **Signature:** `public void setRow(final int rowIndex, final boolean[] row) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified row by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of columns in the matrix.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to set (0-based)
  - `row` (`boolean[]`) — the array of values to copy into the row; must have length equal to the number of columns
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex is out of bounds or row length does not match columnCount
##### setColumn(...) -> void
- **Signature:** `public void setColumn(final int columnIndex, final boolean[] column) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified column by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of rows in the matrix.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to set (0-based)
  - `column` (`boolean[]`) — the array of values to copy into the column; must have length equal to the number of rows
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex is out of bounds or column length does not match rowCount
##### updateRow(...) -> void
- **Signature:** `public <E extends Exception> void updateRow(final int rowIndex, final Throwables.BooleanUnaryOperator<E> operator) throws E`
- **Summary:** Updates all values in the specified row by applying the given operator to each element.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to update (0-based)
  - `operator` (`Throwables.BooleanUnaryOperator<E>`) — the unary operator to apply to each element in the row; must not be null
- **Throws:**
  - `E` — if the operator throws an exception
##### updateColumn(...) -> void
- **Signature:** `public <E extends Exception> void updateColumn(final int columnIndex, final Throwables.BooleanUnaryOperator<E> operator) throws E`
- **Summary:** Updates all values in the specified column by applying the given operator to each element.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to update (0-based)
  - `operator` (`Throwables.BooleanUnaryOperator<E>`) — the unary operator to apply to each element in the column; must not be null
- **Throws:**
  - `E` — if the operator throws an exception
##### getLU2RD(...) -> boolean\[\]
- **Signature:** `public boolean[] getLU2RD() throws IllegalStateException`
- **Summary:** Returns a copy of the elements on the main diagonal from left-upper to right-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new boolean array containing a copy of the main diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setLU2RD(...) -> void
- **Signature:** `public void setLU2RD(final boolean[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the main diagonal from left-upper to right-down (main diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array must have exactly as many elements as the matrix has rows.
  - The diagonal array length must exactly match the number of rows; extra elements will not be ignored.
- **Parameters:**
  - `diagonal` (`boolean[]`) — the new values for the main diagonal; must have length equal to rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal to rows
##### updateLU2RD(...) -> void
- **Signature:** `public <E extends Exception> void updateLU2RD(final Throwables.BooleanUnaryOperator<E> operator) throws E`
- **Summary:** Updates the diagonal elements from left-up to right-down by applying the given operator.
- **Contract:**
  - The matrix must be square (rows == columns).
- **Parameters:**
  - `operator` (`Throwables.BooleanUnaryOperator<E>`) — the unary operator to apply to each diagonal element; must not be null
- **Throws:**
  - `E` — if the operator throws an exception
##### getRU2LD(...) -> boolean\[\]
- **Signature:** `public boolean[] getRU2LD() throws IllegalStateException`
- **Summary:** Returns a copy of the elements on the anti-diagonal from right-upper to left-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new boolean array containing a copy of the anti-diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setRU2LD(...) -> void
- **Signature:** `public void setRU2LD(final boolean[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the anti-diagonal from right-upper to left-down (anti-diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array must have exactly as many elements as the matrix has rows.
  - The diagonal array length must exactly match the number of rows; extra elements will not be ignored.
- **Parameters:**
  - `diagonal` (`boolean[]`) — the new values for the anti-diagonal; must have length equal to rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal to rows
##### updateRU2LD(...) -> void
- **Signature:** `public <E extends Exception> void updateRU2LD(final Throwables.BooleanUnaryOperator<E> operator) throws E`
- **Summary:** Updates the diagonal elements from right-up to left-down by applying the given operator.
- **Contract:**
  - The matrix must be square (rows == columns).
- **Parameters:**
  - `operator` (`Throwables.BooleanUnaryOperator<E>`) — the unary operator to apply to each anti-diagonal element; must not be null
- **Throws:**
  - `E` — if the operator throws an exception
##### updateAll(...) -> void
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.BooleanUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the matrix in-place by applying the given operator to each element.
- **Contract:**
  - Elements are processed in row-major order when not parallelized.
- **Parameters:**
  - `operator` (`Throwables.BooleanUnaryOperator<E>`) — the unary operator to apply to each element; must not be null
- **Throws:**
  - `E` — if the operator throws an exception
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.IntBiFunction<Boolean, E> operator) throws E`
- **Summary:** Updates all elements in the matrix in-place based on their position using the given operator.
- **Parameters:**
  - `operator` (`Throwables.IntBiFunction<Boolean, E>`) — the operator that takes (rowIndex, columnIndex) and returns a boolean value; must not be null
- **Throws:**
  - `E` — if the operator throws an exception
##### replaceIf(...) -> void
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.BooleanPredicate<E> predicate, final boolean newValue) throws E`
- **Summary:** Replaces all elements that match the predicate with the specified new value.
- **Contract:**
  - If the predicate returns true, the element is replaced with the new value; otherwise, it remains unchanged.
- **Parameters:**
  - `predicate` (`Throwables.BooleanPredicate<E>`) — the predicate to test each element; must not be null
  - `newValue` (`boolean`) — the value to replace matching elements with
- **Throws:**
  - `E` — if the predicate throws an exception
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.IntBiPredicate<E> predicate, final boolean newValue) throws E`
- **Summary:** Replaces elements based on their position using the given predicate.
- **Contract:**
  - If the predicate returns true for a position, the element at that position is replaced with the new value; otherwise, it remains unchanged.
- **Parameters:**
  - `predicate` (`Throwables.IntBiPredicate<E>`) — the predicate that takes (rowIndex, columnIndex) and returns true for positions to replace; must not be null
  - `newValue` (`boolean`) — the value to replace at matching positions
- **Throws:**
  - `E` — if the predicate throws an exception
##### map(...) -> BooleanMatrix
- **Signature:** `public <E extends Exception> BooleanMatrix map(final Throwables.BooleanUnaryOperator<E> mapper) throws E`
- **Summary:** Creates a new BooleanMatrix by applying the given function to each element of this matrix.
- **Contract:**
  - Use this method when you want to preserve the original matrix and create a transformed copy.
- **Parameters:**
  - `mapper` (`Throwables.BooleanUnaryOperator<E>`) — the unary operator to apply to each element; must not be null
- **Returns:** a new BooleanMatrix with the function applied to all elements
- **Throws:**
  - `E` — if the function throws an exception
##### mapToObj(...) -> Matrix<T>
- **Signature:** `public <T, E extends Exception> Matrix<T> mapToObj(final Throwables.BooleanFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Creates a new object Matrix by transforming each boolean element to an object of the specified target type.
- **Parameters:**
  - `mapper` (`Throwables.BooleanFunction<? extends T, E>`) — the function to convert boolean values to the target type; must not be null
  - `targetElementType` (`Class<T>`) — the Class object representing the target element type; must not be null
- **Returns:** a new Matrix &lt; T &gt; containing the mapped values
- **Throws:**
  - `E` — if the function throws an exception
##### fill(...) -> void
- **Signature:** `public void fill(final boolean val)`
- **Summary:** Fills all elements in the matrix with the specified value.
- **Parameters:**
  - `val` (`boolean`) — the boolean value to fill the matrix with
- **Signature:** `public void fill(final boolean[][] b)`
- **Summary:** Fills the matrix with values from the provided two-dimensional array, starting from position (0, 0).
- **Parameters:**
  - `b` (`boolean[][]`) — the two-dimensional boolean array to copy values from; must not be null
- **Signature:** `public void fill(final int fromRowIndex, final int fromColumnIndex, final boolean[][] b) throws IllegalArgumentException`
- **Summary:** Fills a portion of the matrix with values from the provided two-dimensional array.
- **Contract:**
  - If the input array extends beyond the matrix boundaries, only the overlapping portion is copied.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index in this matrix (0-based)
  - `fromColumnIndex` (`int`) — the starting column index in this matrix (0-based)
  - `b` (`boolean[][]`) — the source array to copy values from
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the starting indices are negative or exceed matrix dimensions
##### copy(...) -> BooleanMatrix
- **Signature:** `@Override public BooleanMatrix copy()`
- **Summary:** Returns a copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is a copy of this matrix
- **Signature:** `@Override public BooleanMatrix copy(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a row range from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a new BooleanMatrix containing the specified rows
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if {@code fromRowIndex} &lt; 0, {@code toRowIndex} &gt; rows, or {@code fromRowIndex} &gt; {@code toRowIndex}
- **Signature:** `@Override public BooleanMatrix copy(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a rectangular region from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a new BooleanMatrix containing the specified rectangular region
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if {@code fromRowIndex} &lt; 0, {@code toRowIndex} &gt; rows, {@code fromColumnIndex} &lt; 0, {@code toColumnIndex} &gt; columnCount, {@code fromRowIndex} &gt; {@code toRowIndex} , or {@code fromColumnIndex} &gt; {@code toColumnIndex}
##### extend(...) -> BooleanMatrix
- **Signature:** `public BooleanMatrix extend(final int newRowCount, final int newColumnCount)`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with false.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of current matrix but must be non-negative
- **Returns:** a new BooleanMatrix with the specified dimensions
- **Signature:** `public BooleanMatrix extend(final int newRowCount, final int newColumnCount, final boolean defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated from the top-left corner.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with the specified default value.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of current matrix but must be non-negative
  - `defaultValueForNewCell` (`boolean`) — the boolean value to fill new cells with during extension
- **Returns:** a new BooleanMatrix with the specified dimensions
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code newRowCount} or {@code newColumnCount} is negative, or if the resulting matrix would be too large (dimensions exceeding Integer.MAX_VALUE elements)
- **Signature:** `public BooleanMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight)`
- **Summary:** Creates a new matrix by extending this matrix in all four directions.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
- **Returns:** a new extended BooleanMatrix with dimensions ((toUp+rowCount+toDown) x (toLeft+columnCount+toRight))
- **Signature:** `public BooleanMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight, final boolean defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending this matrix in all four directions with padding.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
  - `defaultValueForNewCell` (`boolean`) — the boolean value to fill all new cells with
- **Returns:** a new extended BooleanMatrix with dimensions ((toUp+rowCount+toDown) x (toLeft+columnCount+toRight))
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any padding parameter is negative, or if the resulting dimensions would exceed Integer.MAX_VALUE
##### reverseH(...) -> void
- **Signature:** `public void reverseH()`
- **Summary:** Reverses the order of elements in each row in-place (horizontal reversal).
- **Contract:**
  - Unlike {@link #flipH()} , which returns a new matrix, this method modifies the current matrix in place, making it more memory efficient when you don't need to preserve the original state.
- **Parameters:**
  - (none)
##### reverseV(...) -> void
- **Signature:** `public void reverseV()`
- **Summary:** Reverses the order of rows in the matrix (vertical flip in-place).
- **Contract:**
  - Unlike {@link #flipV()} , which returns a new matrix, this method modifies the current matrix in place, making it more memory efficient when you don't need to preserve the original state.
- **Parameters:**
  - (none)
##### flipH(...) -> BooleanMatrix
- **Signature:** `public BooleanMatrix flipH()`
- **Summary:** Creates a new matrix that is horizontally flipped (each row reversed).
- **Parameters:**
  - (none)
- **Returns:** a new BooleanMatrix with horizontally flipped content
- **See also:** #flipV(), IntMatrix#flipH(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1,</a>
##### flipV(...) -> BooleanMatrix
- **Signature:** `public BooleanMatrix flipV()`
- **Summary:** Creates a new matrix that is vertically flipped (each column reversed).
- **Parameters:**
  - (none)
- **Returns:** a new BooleanMatrix with vertically flipped content
- **See also:** #flipH(), IntMatrix#flipV(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1,</a>
##### rotate90(...) -> BooleanMatrix
- **Signature:** `@Override public BooleanMatrix rotate90()`
- **Summary:** Returns a new matrix rotated 90 degrees clockwise.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 90 degrees clockwise
##### rotate180(...) -> BooleanMatrix
- **Signature:** `@Override public BooleanMatrix rotate180()`
- **Summary:** Returns a new matrix rotated 180 degrees.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 180 degrees
##### rotate270(...) -> BooleanMatrix
- **Signature:** `@Override public BooleanMatrix rotate270()`
- **Summary:** Returns a new matrix rotated 270 degrees clockwise (or 90 degrees counter-clockwise).
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 270 degrees clockwise
##### transpose(...) -> BooleanMatrix
- **Signature:** `@Override public BooleanMatrix transpose()`
- **Summary:** Creates the transpose of this matrix by swapping rows and columns.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is the transpose of this matrix with dimensions columnCount × rows
##### reshape(...) -> BooleanMatrix
- **Signature:** `@SuppressFBWarnings("ICAST_INTEGER_MULTIPLY_CAST_TO_LONG") @Override public BooleanMatrix reshape(final int newRowCount, final int newColumnCount)`
- **Summary:** Reshapes this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new shape requires more elements than available, the excess positions will be filled with {@code false} .
  - If the new shape requires fewer elements, only the first elements are used.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the reshaped matrix; must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the reshaped matrix; must be non-negative
- **Returns:** a new BooleanMatrix with the specified shape
##### repelem(...) -> BooleanMatrix
- **Signature:** `@Override public BooleanMatrix repelem(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats each element in the matrix the specified number of times in both dimensions.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat each element vertically
  - `colRepeats` (`int`) — number of times to repeat each element horizontally
- **Returns:** a new BooleanMatrix with dimensions (rows*rowRepeats x columnCount*colRepeats)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
##### repmat(...) -> BooleanMatrix
- **Signature:** `@Override public BooleanMatrix repmat(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats the entire matrix the specified number of times in both dimensions.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat the matrix vertically
  - `colRepeats` (`int`) — number of times to repeat the matrix horizontally
- **Returns:** a new BooleanMatrix with dimensions (rows*rowRepeats x columnCount*colRepeats)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
##### flatten(...) -> BooleanList
- **Signature:** `@Override public BooleanList flatten()`
- **Summary:** Returns a list containing all matrix elements in row-major order.
- **Parameters:**
  - (none)
- **Returns:** a list of all elements in row-major order
##### flatOp(...) -> void
- **Signature:** `@Override public <E extends Exception> void flatOp(final Throwables.Consumer<? super boolean[], E> op) throws E`
- **Summary:** Applies an operation to each row array of the matrix.
- **Parameters:**
  - `op` (`Throwables.Consumer<? super boolean[], E>`) — the operation to apply to each row array
- **Throws:**
  - `E` — if the operation throws an exception
- **See also:** Arrays#flatOp(boolean\[\]\[\], Throwables.Consumer)
##### vstack(...) -> BooleanMatrix
- **Signature:** `public BooleanMatrix vstack(final BooleanMatrix other) throws IllegalArgumentException`
- **Summary:** Vertically stacks this matrix on top of the specified matrix.
- **Contract:**
  - Both matrices must have the same number of columns.
- **Parameters:**
  - `other` (`BooleanMatrix`) — the matrix to stack below this matrix
- **Returns:** a new BooleanMatrix with dimensions ((this.rowCount + other.rowCount) x columnCount)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different column counts
##### hstack(...) -> BooleanMatrix
- **Signature:** `public BooleanMatrix hstack(final BooleanMatrix other) throws IllegalArgumentException`
- **Summary:** Horizontally stacks this matrix to the left of the specified matrix.
- **Contract:**
  - Both matrices must have the same number of rows.
  - <p> This operation is useful for combining matrices side by side, such as when concatenating feature matrices or building wider data structures from narrower ones.
- **Parameters:**
  - `other` (`BooleanMatrix`) — the matrix to stack to the right of this matrix
- **Returns:** a new BooleanMatrix with dimensions (rowCount x (this.columnCount + other.columnCount))
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different row counts
##### boxed(...) -> Matrix<Boolean>
- **Signature:** `public Matrix<Boolean> boxed()`
- **Summary:** Converts this primitive boolean matrix to a boxed Boolean Matrix.
- **Contract:**
  - <p> This conversion is useful when you need to work with APIs that require object types rather than primitives, or when you need null values in the matrix.
- **Parameters:**
  - (none)
- **Returns:** a new Matrix &lt; Boolean &gt; with the same dimensions and values as this matrix
##### zipWith(...) -> BooleanMatrix
- **Signature:** `public <E extends Exception> BooleanMatrix zipWith(final BooleanMatrix matrixB, final Throwables.BooleanBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Performs element-wise combination of this matrix with another matrix using the provided binary function.
- **Contract:**
  - Both matrices must have exactly the same dimensions.
- **Parameters:**
  - `matrixB` (`BooleanMatrix`) — the second matrix to combine with this matrix
  - `zipFunction` (`Throwables.BooleanBinaryOperator<E>`) — the binary operator to apply to corresponding elements
- **Returns:** a new BooleanMatrix containing the results of the element-wise operation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
  - `E` — if the zip function throws an exception
- **Signature:** `public <E extends Exception> BooleanMatrix zipWith(final BooleanMatrix matrixB, final BooleanMatrix matrixC, final Throwables.BooleanTernaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Performs element-wise combination of this matrix with two other matrices using the provided ternary function.
- **Contract:**
  - All three matrices must have exactly the same dimensions.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code BooleanMatrix a = BooleanMatrix.of(new boolean\[\]\[\] {{true, false}, {true, true}}); BooleanMatrix b = BooleanMatrix.of(new boolean\[\]\[\] {{true, true}, {false, true}}); BooleanMatrix c = BooleanMatrix.of(new boolean\[\]\[\] {{false, true}, {true, false}}); // Majority vote: true if at least 2 out of 3 are true BooleanMatrix majority = a.zipWith(b, c, (x, y, z) -> (x && y) || (x && z) || (y && z)); // Conditional operation: if a then b else c BooleanMatrix conditional = a.zipWith(b, c, (x, y, z) -> x ?
- **Parameters:**
  - `matrixB` (`BooleanMatrix`) — the second matrix
  - `matrixC` (`BooleanMatrix`) — the third matrix
  - `zipFunction` (`Throwables.BooleanTernaryOperator<E>`) — the ternary operator to apply to corresponding elements
- **Returns:** a new BooleanMatrix containing the results of the element-wise operation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
  - `E` — if the zip function throws an exception
##### streamLU2RD(...) -> Stream<Boolean>
- **Signature:** `@Override public Stream<Boolean> streamLU2RD()`
- **Summary:** Returns a stream of Boolean values from the main diagonal (left-up to right-down).
- **Contract:**
  - The matrix must be square (same number of rows and columns).
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code BooleanMatrix matrix = BooleanMatrix.of(new boolean\[\]\[\] { {true, false, false}, {false, true, false}, {false, false, true} }); List<Boolean> diagonal = matrix.streamLU2RD().toList(); // \[true, true, true\] // Check if it's an identity-like matrix boolean allTrue = matrix.streamLU2RD().allMatch(b -> b); } </pre>
- **Parameters:**
  - (none)
- **Returns:** a Stream &lt; Boolean &gt; containing the diagonal elements from top-left to bottom-right
##### streamRU2LD(...) -> Stream<Boolean>
- **Signature:** `@Override public Stream<Boolean> streamRU2LD()`
- **Summary:** Returns a stream of Boolean values from the anti-diagonal (right-up to left-down).
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a Stream &lt; Boolean &gt; containing the anti-diagonal elements from top-right to bottom-left
##### streamH(...) -> Stream<Boolean>
- **Signature:** `@Override public Stream<Boolean> streamH()`
- **Summary:** Returns a stream of all elements in row-major order (horizontal).
- **Parameters:**
  - (none)
- **Returns:** a Stream &lt; Boolean &gt; of all elements in row-major order, or an empty stream if the matrix is empty
- **Signature:** `@Override public Stream<Boolean> streamH(final int rowIndex)`
- **Summary:** Returns a stream of elements from a single row.
- **Contract:**
  - <p> This method is particularly useful when you need to process or analyze a specific row of the matrix independently.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code BooleanMatrix matrix = BooleanMatrix.of(new boolean\[\]\[\] { {true, false, true}, {false, true, false} }); Stream<Boolean> firstRow = matrix.streamH(0); // Stream of \[true, false, true\] // Check if any value in the second row is true boolean hasTrue = matrix.streamH(1).anyMatch(b -> b); // Returns true } </pre>
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to stream (0-based)
- **Returns:** a Stream &lt; Boolean &gt; of elements from the specified row
- **Signature:** `@Override public Stream<Boolean> streamH(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of elements from a range of rows in row-major order.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a Stream &lt; Boolean &gt; of elements from the specified row range, or an empty stream if the matrix is empty
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rows, or fromRowIndex &gt; toRowIndex
##### streamV(...) -> Stream<Boolean>
- **Signature:** `@Override @Beta public Stream<Boolean> streamV()`
- **Summary:** Returns a stream of all elements in column-major order (vertical).
- **Parameters:**
  - (none)
- **Returns:** a Stream &lt; Boolean &gt; of all elements in column-major order, or an empty stream if the matrix is empty
- **Signature:** `@Override public Stream<Boolean> streamV(final int columnIndex)`
- **Summary:** Returns a stream of elements from a single column.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code BooleanMatrix matrix = BooleanMatrix.of(new boolean\[\]\[\] { {true, false, true}, {true, true, false} }); Stream<Boolean> firstCol = matrix.streamV(0); // Stream of \[true, true\] // Check if all values in a column are true boolean allTrue = matrix.streamV(0).allMatch(b -> b); // Returns true } </pre>
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to stream (0-based)
- **Returns:** a Stream &lt; Boolean &gt; of elements from the specified column
- **Signature:** `@Override @Beta public Stream<Boolean> streamV(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of elements from a range of columns in column-major order.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a Stream &lt; Boolean &gt; of elements from the specified column range in column-major order, or an empty stream if the matrix is empty
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromColumnIndex &lt; 0, toColumnIndex &gt; columnCount, or fromColumnIndex &gt; toColumnIndex
##### streamR(...) -> Stream<Stream<Boolean>>
- **Signature:** `@Override public Stream<Stream<Boolean>> streamR()`
- **Summary:** Returns a stream of Stream &lt; Boolean &gt; objects, where each inner stream represents a complete row.
- **Parameters:**
  - (none)
- **Returns:** a Stream of Stream &lt; Boolean &gt; objects, one for each row in the matrix, or an empty stream if the matrix is empty
- **Signature:** `@Override public Stream<Stream<Boolean>> streamR(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of Stream &lt; Boolean &gt; objects for a range of rows.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code BooleanMatrix matrix = BooleanMatrix.of(new boolean\[\]\[\] { {true, true, false}, {false, true, true}, {true, false, true} }); // Process middle rows only List<Boolean> hasPattern = matrix.streamR(1, 3) .map(row -> { List<Boolean> list = row.toList(); return list.get(0) != list.get(2); // Check if first != last }) .toList(); // \[true, false\] } </pre>
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a Stream of Stream &lt; Boolean &gt; objects for the specified row range, or an empty stream if the matrix is empty
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rows, or fromRowIndex &gt; toRowIndex
##### streamC(...) -> Stream<Stream<Boolean>>
- **Signature:** `@Override @Beta public Stream<Stream<Boolean>> streamC()`
- **Summary:** Returns a stream of Stream &lt; Boolean &gt; objects, where each inner stream represents a complete column.
- **Parameters:**
  - (none)
- **Returns:** a Stream of Stream &lt; Boolean &gt; objects, one for each column in the matrix, or an empty stream if the matrix is empty
- **Signature:** `@Override @Beta public Stream<Stream<Boolean>> streamC(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of Stream &lt; Boolean &gt; objects for a range of columns.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a Stream of Stream &lt; Boolean &gt; objects for the specified column range, or an empty stream if the matrix is empty
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromColumnIndex &lt; 0, toColumnIndex &gt; columnCount, or fromColumnIndex &gt; toColumnIndex
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.BooleanConsumer<E> action) throws E`
- **Summary:** Applies the given action to each element in the matrix.
- **Contract:**
  - <p> The operation may be parallelized internally if the matrix is large enough to benefit from parallel processing, based on internal heuristics.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code BooleanMatrix matrix = BooleanMatrix.of(new boolean\[\]\[\] {{true, false}, {false, true}}); // Count true values int\[\] trueCount = {0}; matrix.forEach(value -> { if (value) trueCount\[0\]++; }); // trueCount\[0\] is now 2 // Print all values matrix.forEach(value -> System.out.print(value ?
- **Parameters:**
  - `action` (`Throwables.BooleanConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the action throws an exception
- **Signature:** `public <E extends Exception> void forEach(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.BooleanConsumer<E> action) throws IndexOutOfBoundsException, E`
- **Summary:** Applies the given action to each element in the specified sub-matrix region.
- **Contract:**
  - The operation may be parallelized internally if the sub-matrix is large enough to benefit from parallel processing.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code BooleanMatrix matrix = BooleanMatrix.of(new boolean\[\]\[\] { {true, false, true}, {false, true, false}, {true, true, true} }); // Process only the center 2x2 sub-matrix List<Boolean> center = new ArrayList<>(); matrix.forEach(0, 2, 0, 2, value -> center.add(value)); // center contains \[true, false, false, true\] // Count true values in bottom row int\[\] bottomRowTrue = {0}; matrix.forEach(2, 3, 0, 3, value -> { if (value) bottomRowTrue\[0\]++; }); // bottomRowTrue\[0\] is 3 } </pre>
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
  - `action` (`Throwables.BooleanConsumer<E>`) — the action to be performed for each element in the sub-matrix
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is out of bounds
  - `E` — if the action throws an exception
##### println(...) -> String
- **Signature:** `@Override public String println()`
- **Summary:** Prints the matrix to standard output in a formatted manner.
- **Parameters:**
  - (none)
- **Returns:** the formatted string representation of the matrix
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this matrix.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this matrix
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this matrix to the specified object for equality.
- **Contract:**
  - Returns {@code true} if the given object is also a BooleanMatrix with the same dimensions and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the objects are equal, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this matrix

### Class BooleanTuple (com.landawn.abacus.util.BooleanTuple)
Abstract base class for immutable tuple implementations that hold primitive boolean values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> BooleanTuple1
- **Signature:** `public static BooleanTuple1 of(final boolean _1)`
- **Summary:** Creates a BooleanTuple.BooleanTuple1 containing a single boolean value.
- **Parameters:**
  - `_1` (`boolean`) — the boolean value to store in the tuple
- **Returns:** a new BooleanTuple.BooleanTuple1 containing the specified value
- **Signature:** `public static BooleanTuple2 of(final boolean _1, final boolean _2)`
- **Summary:** Creates a BooleanTuple.BooleanTuple2 containing two boolean values.
- **Parameters:**
  - `_1` (`boolean`) — the first boolean value
  - `_2` (`boolean`) — the second boolean value
- **Returns:** a new BooleanTuple.BooleanTuple2 containing the specified values
- **Signature:** `public static BooleanTuple3 of(final boolean _1, final boolean _2, final boolean _3)`
- **Summary:** Creates a BooleanTuple.BooleanTuple3 containing three boolean values.
- **Parameters:**
  - `_1` (`boolean`) — the first boolean value
  - `_2` (`boolean`) — the second boolean value
  - `_3` (`boolean`) — the third boolean value
- **Returns:** a new BooleanTuple.BooleanTuple3 containing the specified values
- **Signature:** `public static BooleanTuple4 of(final boolean _1, final boolean _2, final boolean _3, final boolean _4)`
- **Summary:** Creates a BooleanTuple.BooleanTuple4 containing four boolean values.
- **Parameters:**
  - `_1` (`boolean`) — the first boolean value
  - `_2` (`boolean`) — the second boolean value
  - `_3` (`boolean`) — the third boolean value
  - `_4` (`boolean`) — the fourth boolean value
- **Returns:** a new BooleanTuple.BooleanTuple4 containing the specified values
- **Signature:** `public static BooleanTuple5 of(final boolean _1, final boolean _2, final boolean _3, final boolean _4, final boolean _5)`
- **Summary:** Creates a BooleanTuple.BooleanTuple5 containing five boolean values.
- **Parameters:**
  - `_1` (`boolean`) — the first boolean value
  - `_2` (`boolean`) — the second boolean value
  - `_3` (`boolean`) — the third boolean value
  - `_4` (`boolean`) — the fourth boolean value
  - `_5` (`boolean`) — the fifth boolean value
- **Returns:** a new BooleanTuple.BooleanTuple5 containing the specified values
- **Signature:** `public static BooleanTuple6 of(final boolean _1, final boolean _2, final boolean _3, final boolean _4, final boolean _5, final boolean _6)`
- **Summary:** Creates a BooleanTuple.BooleanTuple6 containing six boolean values.
- **Parameters:**
  - `_1` (`boolean`) — the first boolean value
  - `_2` (`boolean`) — the second boolean value
  - `_3` (`boolean`) — the third boolean value
  - `_4` (`boolean`) — the fourth boolean value
  - `_5` (`boolean`) — the fifth boolean value
  - `_6` (`boolean`) — the sixth boolean value
- **Returns:** a new BooleanTuple.BooleanTuple6 containing the specified values
- **Signature:** `public static BooleanTuple7 of(final boolean _1, final boolean _2, final boolean _3, final boolean _4, final boolean _5, final boolean _6, final boolean _7)`
- **Summary:** Creates a BooleanTuple.BooleanTuple7 containing seven boolean values.
- **Parameters:**
  - `_1` (`boolean`) — the first boolean value
  - `_2` (`boolean`) — the second boolean value
  - `_3` (`boolean`) — the third boolean value
  - `_4` (`boolean`) — the fourth boolean value
  - `_5` (`boolean`) — the fifth boolean value
  - `_6` (`boolean`) — the sixth boolean value
  - `_7` (`boolean`) — the seventh boolean value
- **Returns:** a new BooleanTuple.BooleanTuple7 containing the specified values
- **Signature:** `@Deprecated public static BooleanTuple8 of(final boolean _1, final boolean _2, final boolean _3, final boolean _4, final boolean _5, final boolean _6, final boolean _7, final boolean _8)`
- **Summary:** Creates a BooleanTuple.BooleanTuple8 containing eight boolean values.
- **Parameters:**
  - `_1` (`boolean`) — the first boolean value
  - `_2` (`boolean`) — the second boolean value
  - `_3` (`boolean`) — the third boolean value
  - `_4` (`boolean`) — the fourth boolean value
  - `_5` (`boolean`) — the fifth boolean value
  - `_6` (`boolean`) — the sixth boolean value
  - `_7` (`boolean`) — the seventh boolean value
  - `_8` (`boolean`) — the eighth boolean value
- **Returns:** a new BooleanTuple.BooleanTuple8 containing the specified values
- **Signature:** `@Deprecated public static BooleanTuple9 of(final boolean _1, final boolean _2, final boolean _3, final boolean _4, final boolean _5, final boolean _6, final boolean _7, final boolean _8, final boolean _9)`
- **Summary:** Creates a BooleanTuple.BooleanTuple9 containing nine boolean values.
- **Parameters:**
  - `_1` (`boolean`) — the first boolean value
  - `_2` (`boolean`) — the second boolean value
  - `_3` (`boolean`) — the third boolean value
  - `_4` (`boolean`) — the fourth boolean value
  - `_5` (`boolean`) — the fifth boolean value
  - `_6` (`boolean`) — the sixth boolean value
  - `_7` (`boolean`) — the seventh boolean value
  - `_8` (`boolean`) — the eighth boolean value
  - `_9` (`boolean`) — the ninth boolean value
- **Returns:** a new BooleanTuple.BooleanTuple9 containing the specified values
##### create(...) -> TP
- **Signature:** `@SuppressWarnings("deprecation") public static <TP extends BooleanTuple<TP>> TP create(final boolean[] values)`
- **Summary:** Creates a BooleanTuple from an array of boolean values.
- **Parameters:**
  - `values` (`boolean[]`) — the array of boolean values (must have length 0-9), may be {@code null}
- **Returns:** a BooleanTuple of appropriate size containing the array values, or an empty BooleanTuple if the array is null or empty

#### Public Instance Methods
##### reverse(...) -> TP
- **Signature:** `public abstract TP reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new tuple with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `public abstract boolean contains(boolean valueToFind)`
- **Summary:** Checks if this tuple contains the specified boolean value.
- **Contract:**
  - Checks if this tuple contains the specified boolean value.
  - <p> This method performs a linear search through all elements in the tuple to determine if any element matches the specified value.
  - Returns {@code true} if at least one element equals the search value, {@code false} otherwise.
- **Parameters:**
  - `valueToFind` (`boolean`) — the boolean value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### toArray(...) -> boolean\[\]
- **Signature:** `public boolean[] toArray()`
- **Summary:** Returns a new array containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new boolean array containing all tuple elements
##### toList(...) -> BooleanList
- **Signature:** `public BooleanList toList()`
- **Summary:** Returns a new BooleanList containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new BooleanList containing all tuple elements
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.BooleanConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code BooleanTuple.BooleanTuple3 tuple = BooleanTuple.of(true, false, true); tuple.forEach(b -> System.out.println("Value: " + b)); // Output: Value: true, Value: false, Value: true // Count true values java.util.concurrent.atomic.AtomicInteger count = new java.util.concurrent.atomic.AtomicInteger(); tuple.forEach(b -> { if (b) count.incrementAndGet(); }); // count is now 2 } </pre>
- **Parameters:**
  - `consumer` (`Throwables.BooleanConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `E` — if the consumer throws an exception during execution
##### stream(...) -> Stream<Boolean>
- **Signature:** `public Stream<Boolean> stream()`
- **Summary:** Returns a Stream of Boolean objects containing all elements in this tuple.
- **Parameters:**
  - (none)
- **Returns:** a Stream containing all tuple elements as Boolean objects
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this tuple
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Contract:**
  - <p> Two tuples are considered equal if and only if: </p> <ul> <li> They are the same object (reference equality), or </li> <li> They are instances of the exact same class, and </li> <li> They contain the same boolean values in the same order </li> </ul> This method is consistent with {@link #hashCode()} .
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is equal to this tuple, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this tuple

### Class BooleanTuple1 (com.landawn.abacus.util.BooleanTuple.BooleanTuple1)
A BooleanTuple containing exactly one boolean element.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 1.
- **Parameters:**
  - (none)
- **Returns:** 1
##### reverse(...) -> BooleanTuple1
- **Signature:** `@Override public BooleanTuple1 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new BooleanTuple.BooleanTuple1 with the same element
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final boolean valueToFind)`
- **Summary:** Checks if this tuple contains the specified boolean value.
- **Contract:**
  - Checks if this tuple contains the specified boolean value.
- **Parameters:**
  - `valueToFind` (`boolean`) — the boolean value to search for
- **Returns:** {@code true} if the element equals valueToFind, {@code false} otherwise
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** 1231 if the value is true, 1237 if false
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a BooleanTuple.BooleanTuple1 with the same element
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element)"

### Class BooleanTuple2 (com.landawn.abacus.util.BooleanTuple.BooleanTuple2)
A BooleanTuple containing exactly two boolean elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 2.
- **Parameters:**
  - (none)
- **Returns:** 2
##### reverse(...) -> BooleanTuple2
- **Signature:** `@Override public BooleanTuple2 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new BooleanTuple.BooleanTuple2 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final boolean valueToFind)`
- **Summary:** Checks if this tuple contains the specified boolean value.
- **Contract:**
  - Checks if this tuple contains the specified boolean value.
- **Parameters:**
  - `valueToFind` (`boolean`) — the boolean value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.BooleanConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.BooleanConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.BooleanBiConsumer<E> action) throws E`
- **Summary:** Applies the given action to both elements of this tuple.
- **Parameters:**
  - `action` (`Throwables.BooleanBiConsumer<E>`) — the bi-consumer action to be performed on both elements, must not be {@code null}
- **Throws:**
  - `E` — if the action throws an exception during execution
##### map(...) -> U
- **Signature:** `public <U, E extends Exception> U map(final Throwables.BooleanBiFunction<U, E> mapper) throws E`
- **Summary:** Applies the given function to both elements of this tuple and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.BooleanBiFunction<U, E>`) — the bi-function to apply to both elements, must not be {@code null}
- **Returns:** the result of applying the mapping function to both elements
- **Throws:**
  - `E` — if the mapper throws an exception during execution
##### filter(...) -> Optional<BooleanTuple2>
- **Signature:** `public <E extends Exception> Optional<BooleanTuple2> filter(final Throwables.BooleanBiPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if it matches the given predicate, otherwise returns an empty Optional.
- **Contract:**
  - Returns an Optional containing this tuple if it matches the given predicate, otherwise returns an empty Optional.
  - If the predicate returns {@code true} , the tuple is wrapped in an Optional; otherwise, an empty Optional is returned.
- **Parameters:**
  - `predicate` (`Throwables.BooleanBiPredicate<E>`) — the bi-predicate to test both elements, must not be {@code null}
- **Returns:** an Optional containing this tuple if the predicate returns {@code true} , empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception during evaluation
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from both elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a BooleanTuple.BooleanTuple2 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2)"

### Class BooleanTuple3 (com.landawn.abacus.util.BooleanTuple.BooleanTuple3)
A BooleanTuple containing exactly three boolean elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 3.
- **Parameters:**
  - (none)
- **Returns:** 3
##### reverse(...) -> BooleanTuple3
- **Signature:** `@Override public BooleanTuple3 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new BooleanTuple.BooleanTuple3 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final boolean valueToFind)`
- **Summary:** Checks if this tuple contains the specified boolean value.
- **Contract:**
  - Checks if this tuple contains the specified boolean value.
- **Parameters:**
  - `valueToFind` (`boolean`) — the boolean value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.BooleanConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.BooleanConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.BooleanTriConsumer<E> action) throws E`
- **Summary:** Applies the given action to all three elements of this tuple.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code BooleanTuple.BooleanTuple3 tuple = BooleanTuple.of(true, false, true); tuple.accept((a, b, c) -> System.out.println(a + ", " + b + ", " + c)); // Counting true values java.util.concurrent.atomic.AtomicInteger count = new java.util.concurrent.atomic.AtomicInteger(); tuple.accept((a, b, c) -> { if (a) count.incrementAndGet(); if (b) count.incrementAndGet(); if (c) count.incrementAndGet(); }); } </pre>
- **Parameters:**
  - `action` (`Throwables.BooleanTriConsumer<E>`) — the tri-consumer action to be performed on all three elements, must not be {@code null}
- **Throws:**
  - `E` — if the action throws an exception during execution
##### map(...) -> U
- **Signature:** `public <U, E extends Exception> U map(final Throwables.BooleanTriFunction<U, E> mapper) throws E`
- **Summary:** Applies the given function to all three elements of this tuple and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.BooleanTriFunction<U, E>`) — the tri-function to apply to all three elements, must not be {@code null}
- **Returns:** the result of applying the mapping function to all three elements
- **Throws:**
  - `E` — if the mapper throws an exception during execution
##### filter(...) -> Optional<BooleanTuple3>
- **Signature:** `public <E extends Exception> Optional<BooleanTuple3> filter(final Throwables.BooleanTriPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if it matches the given predicate, otherwise returns an empty Optional.
- **Contract:**
  - Returns an Optional containing this tuple if it matches the given predicate, otherwise returns an empty Optional.
  - If the predicate returns {@code true} , the tuple is wrapped in an Optional; otherwise, an empty Optional is returned.
- **Parameters:**
  - `predicate` (`Throwables.BooleanTriPredicate<E>`) — the tri-predicate to test all three elements, must not be {@code null}
- **Returns:** an Optional containing this tuple if the predicate returns {@code true} , empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception during evaluation
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from all three elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a BooleanTuple.BooleanTuple3 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3)"

### Class BooleanTuple4 (com.landawn.abacus.util.BooleanTuple.BooleanTuple4)
A BooleanTuple containing exactly four boolean elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 4.
- **Parameters:**
  - (none)
- **Returns:** 4
##### reverse(...) -> BooleanTuple4
- **Signature:** `@Override public BooleanTuple4 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new BooleanTuple.BooleanTuple4 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final boolean valueToFind)`
- **Summary:** Checks if this tuple contains the specified boolean value.
- **Contract:**
  - Checks if this tuple contains the specified boolean value.
- **Parameters:**
  - `valueToFind` (`boolean`) — the boolean value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.BooleanConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.BooleanConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from all four elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a BooleanTuple.BooleanTuple4 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3, element4)"

### Class BooleanTuple5 (com.landawn.abacus.util.BooleanTuple.BooleanTuple5)
A BooleanTuple containing exactly five boolean elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 5.
- **Parameters:**
  - (none)
- **Returns:** 5
##### reverse(...) -> BooleanTuple5
- **Signature:** `@Override public BooleanTuple5 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new BooleanTuple.BooleanTuple5 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final boolean valueToFind)`
- **Summary:** Checks if this tuple contains the specified boolean value.
- **Contract:**
  - Checks if this tuple contains the specified boolean value.
- **Parameters:**
  - `valueToFind` (`boolean`) — the boolean value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.BooleanConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.BooleanConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from all five elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a BooleanTuple.BooleanTuple5 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3, element4, element5)"

### Class BooleanTuple6 (com.landawn.abacus.util.BooleanTuple.BooleanTuple6)
A BooleanTuple containing exactly six boolean elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 6.
- **Parameters:**
  - (none)
- **Returns:** 6
##### reverse(...) -> BooleanTuple6
- **Signature:** `@Override public BooleanTuple6 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new BooleanTuple.BooleanTuple6 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final boolean valueToFind)`
- **Summary:** Checks if this tuple contains the specified boolean value.
- **Contract:**
  - Checks if this tuple contains the specified boolean value.
- **Parameters:**
  - `valueToFind` (`boolean`) — the boolean value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.BooleanConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.BooleanConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from all six elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a BooleanTuple.BooleanTuple6 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3, element4, element5, element6)"

### Class BooleanTuple7 (com.landawn.abacus.util.BooleanTuple.BooleanTuple7)
A BooleanTuple containing exactly seven boolean elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 7.
- **Parameters:**
  - (none)
- **Returns:** 7
##### reverse(...) -> BooleanTuple7
- **Signature:** `@Override public BooleanTuple7 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new BooleanTuple.BooleanTuple7 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final boolean valueToFind)`
- **Summary:** Checks if this tuple contains the specified boolean value.
- **Contract:**
  - Checks if this tuple contains the specified boolean value.
- **Parameters:**
  - `valueToFind` (`boolean`) — the boolean value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.BooleanConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.BooleanConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from all seven elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a BooleanTuple.BooleanTuple7 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3, element4, element5, element6, element7)"

### Class BooleanTuple8 (com.landawn.abacus.util.BooleanTuple.BooleanTuple8)
A BooleanTuple containing exactly eight boolean elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 8.
- **Parameters:**
  - (none)
- **Returns:** 8
##### reverse(...) -> BooleanTuple8
- **Signature:** `@Override public BooleanTuple8 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new BooleanTuple.BooleanTuple8 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final boolean valueToFind)`
- **Summary:** Checks if this tuple contains the specified boolean value.
- **Contract:**
  - Checks if this tuple contains the specified boolean value.
- **Parameters:**
  - `valueToFind` (`boolean`) — the boolean value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.BooleanConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.BooleanConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from all eight elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a BooleanTuple.BooleanTuple8 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, ..., element8)"

### Class BooleanTuple9 (com.landawn.abacus.util.BooleanTuple.BooleanTuple9)
A BooleanTuple containing exactly nine boolean elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 9.
- **Parameters:**
  - (none)
- **Returns:** 9
##### reverse(...) -> BooleanTuple9
- **Signature:** `@Override public BooleanTuple9 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new BooleanTuple.BooleanTuple9 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final boolean valueToFind)`
- **Summary:** Checks if this tuple contains the specified boolean value.
- **Contract:**
  - Checks if this tuple contains the specified boolean value.
- **Parameters:**
  - `valueToFind` (`boolean`) — the boolean value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.BooleanConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.BooleanConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from all nine elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a BooleanTuple.BooleanTuple9 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, ..., element9)"

### Class ByteMatrix (com.landawn.abacus.util.ByteMatrix)
A matrix implementation for byte primitive values, providing efficient storage and operations for two-dimensional byte arrays.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### empty(...) -> ByteMatrix
- **Signature:** `public static ByteMatrix empty()`
- **Summary:** Creates an empty matrix with zero rowCount and zero columnCount.
- **Parameters:**
  - (none)
- **Returns:** an empty byte matrix
##### of(...) -> ByteMatrix
- **Signature:** `public static ByteMatrix of(final byte[]... a)`
- **Summary:** Creates a ByteMatrix from a two-dimensional byte array.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array to create the matrix from, or null/empty for an empty matrix
- **Returns:** a new ByteMatrix containing the provided data, or an empty ByteMatrix if input is null or empty
##### random(...) -> ByteMatrix
- **Signature:** `public static ByteMatrix random(final int size)`
- **Summary:** Creates a new 1xsize matrix filled with random byte values.
- **Parameters:**
  - `size` (`int`) — the number of columns in the new matrix
- **Returns:** a new ByteMatrix of dimensions 1 x size filled with random values
- **Signature:** `public static ByteMatrix random(final int rowCount, final int columnCount)`
- **Summary:** Creates a new matrix of the specified dimensions filled with random byte values.
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
- **Returns:** a new ByteMatrix of dimensions rowCount x columnCount filled with random values
##### repeat(...) -> ByteMatrix
- **Signature:** `public static ByteMatrix repeat(final int rowCount, final int columnCount, final byte element)`
- **Summary:** Creates a new matrix of the specified dimensions where every element is the provided {@code element} .
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
  - `element` (`byte`) — the byte value to fill the matrix with
- **Returns:** a new ByteMatrix of dimensions rowCount x columnCount filled with the specified element
##### range(...) -> ByteMatrix
- **Signature:** `public static ByteMatrix range(final byte startInclusive, final byte endExclusive)`
- **Summary:** Creates a 1-row ByteMatrix containing a range of byte values from startInclusive to endExclusive.
- **Parameters:**
  - `startInclusive` (`byte`) — the starting value (inclusive)
  - `endExclusive` (`byte`) — the ending value (exclusive)
- **Returns:** a new ByteMatrix containing the range of values
- **Signature:** `public static ByteMatrix range(final byte startInclusive, final byte endExclusive, final byte by)`
- **Summary:** Creates a 1-row ByteMatrix containing a range of byte values with a specified step.
- **Contract:**
  - If the step would not reach endExclusive from startInclusive, an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`byte`) — the starting value (inclusive)
  - `endExclusive` (`byte`) — the ending value (exclusive)
  - `by` (`byte`) — the step size (must not be zero; can be positive or negative)
- **Returns:** a new 1×n ByteMatrix with values incremented by the step size
##### rangeClosed(...) -> ByteMatrix
- **Signature:** `public static ByteMatrix rangeClosed(final byte startInclusive, final byte endInclusive)`
- **Summary:** Creates a 1-row ByteMatrix containing a closed range of byte values from startInclusive to endInclusive.
- **Parameters:**
  - `startInclusive` (`byte`) — the starting value (inclusive)
  - `endInclusive` (`byte`) — the ending value (inclusive)
- **Returns:** a new ByteMatrix containing the range of values
- **Signature:** `public static ByteMatrix rangeClosed(final byte startInclusive, final byte endInclusive, final byte by)`
- **Summary:** Creates a 1-row ByteMatrix containing a closed range of byte values with a specified step.
- **Contract:**
  - The end value is included only if it is reachable by stepping from start.
  - If the step would not reach endInclusive from startInclusive, an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`byte`) — the starting value (inclusive)
  - `endInclusive` (`byte`) — the ending value (inclusive, if reachable by stepping)
  - `by` (`byte`) — the step size (must not be zero; can be positive or negative)
- **Returns:** a new 1×n ByteMatrix with values incremented by the step size
##### diagonalLU2RD(...) -> ByteMatrix
- **Signature:** `public static ByteMatrix diagonalLU2RD(final byte[] leftUp2RightDownDiagonal)`
- **Summary:** Creates a square matrix from the specified main diagonal elements.
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`byte[]`) — the array of diagonal elements
- **Returns:** a square matrix with the specified main diagonal
##### diagonalRU2LD(...) -> ByteMatrix
- **Signature:** `public static ByteMatrix diagonalRU2LD(final byte[] rightUp2LeftDownDiagonal)`
- **Summary:** Creates a square matrix from the specified anti-diagonal elements (right-upper to left-down).
- **Parameters:**
  - `rightUp2LeftDownDiagonal` (`byte[]`) — the array of anti-diagonal elements
- **Returns:** a square matrix with the specified anti-diagonal (n×n where n = diagonal length)
##### diagonal(...) -> ByteMatrix
- **Signature:** `public static ByteMatrix diagonal(final byte[] leftUp2RightDownDiagonal, final byte[] rightUp2LeftDownDiagonal) throws IllegalArgumentException`
- **Summary:** Creates a square matrix from the specified main diagonal and anti-diagonal elements.
- **Contract:**
  - If both arrays are provided, they must have the same length.
  - The resulting matrix has dimensions n×n where n is the length of the non-null/non-empty array (or the maximum length if both are provided).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`byte[]`) — the array of main diagonal elements (can be null or empty)
  - `rightUp2LeftDownDiagonal` (`byte[]`) — the array of anti-diagonal elements (can be null or empty)
- **Returns:** a square matrix with the specified diagonals, or an empty matrix if both inputs are null or empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — if both arrays are non-empty and have different lengths
##### unbox(...) -> ByteMatrix
- **Signature:** `public static ByteMatrix unbox(final Matrix<Byte> x)`
- **Summary:** Converts a boxed Byte Matrix to a primitive ByteMatrix.
- **Contract:**
  - This conversion improves memory efficiency and performance when working with large matrices.
- **Parameters:**
  - `x` (`Matrix<Byte>`) — the boxed Byte Matrix to convert; must not be null
- **Returns:** a new ByteMatrix with primitive byte values
- **See also:** #boxed()

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public ByteMatrix(final byte[][] a)`
- **Summary:** Constructs a ByteMatrix from a two-dimensional byte array.
- **Contract:**
  - If the input array is null, an empty matrix (0x0) is created.
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array to wrap as a matrix. Can be null.
##### componentType(...) -> Class
- **Signature:** `@SuppressWarnings("rawtypes") @Override public Class componentType()`
- **Summary:** Returns the component type of the matrix elements, which is always {@code byte.class} .
- **Parameters:**
  - (none)
- **Returns:** {@code byte.class}
##### get(...) -> byte
- **Signature:** `public byte get(final int i, final int j)`
- **Summary:** Returns the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** the element at position (rowIndex, columnIndex)
- **Signature:** `public byte get(final Point point)`
- **Summary:** Returns the element at the specified point.
- **Parameters:**
  - `point` (`Point`) — the point containing row and column indices (must not be null)
- **Returns:** the byte element at the specified point
- **See also:** #get(int, int)
##### set(...) -> void
- **Signature:** `public void set(final int i, final int j, final byte val)`
- **Summary:** Sets the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
  - `val` (`byte`) — the value to set
- **Signature:** `public void set(final Point point, final byte val)`
- **Summary:** Sets the element at the specified point to the given value.
- **Parameters:**
  - `point` (`Point`) — the point containing row and column indices (must not be null)
  - `val` (`byte`) — the new byte value to set at the specified point
- **See also:** #set(int, int, byte)
##### upOf(...) -> OptionalByte
- **Signature:** `public OptionalByte upOf(final int i, final int j)`
- **Summary:** Returns the element above the specified position, if it exists.
- **Contract:**
  - Returns the element above the specified position, if it exists.
  - This method provides safe access to the element directly above the given position without throwing an exception when at the top edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalByte containing the element at position (rowIndex - 1, columnIndex), or empty if rowIndex == 0
##### downOf(...) -> OptionalByte
- **Signature:** `public OptionalByte downOf(final int i, final int j)`
- **Summary:** Returns the element below the specified position, if it exists.
- **Contract:**
  - Returns the element below the specified position, if it exists.
  - This method provides safe access to the element directly below the given position without throwing an exception when at the bottom edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalByte containing the element at position (rowIndex + 1, columnIndex), or empty if rowIndex == rowCount - 1
##### leftOf(...) -> OptionalByte
- **Signature:** `public OptionalByte leftOf(final int i, final int j)`
- **Summary:** Returns the element to the left of the specified position, if it exists.
- **Contract:**
  - Returns the element to the left of the specified position, if it exists.
  - This method provides safe access to the element directly to the left of the given position without throwing an exception when at the leftmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalByte containing the element at position (rowIndex, columnIndex - 1), or empty if columnIndex == 0
##### rightOf(...) -> OptionalByte
- **Signature:** `public OptionalByte rightOf(final int i, final int j)`
- **Summary:** Returns the element to the right of the specified position, if it exists.
- **Contract:**
  - Returns the element to the right of the specified position, if it exists.
  - This method provides safe access to the element directly to the right of the given position without throwing an exception when at the rightmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalByte containing the element at position (rowIndex, columnIndex + 1), or empty if columnIndex == columnCount - 1
##### row(...) -> byte\[\]
- **Signature:** `public byte[] row(final int rowIndex) throws IllegalArgumentException`
- **Summary:** Returns the specified row as a byte array.
- **Contract:**
  - If you need an independent copy, use {@code Arrays.copyOf(matrix.row(i), matrix.columnCount())} .
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to retrieve (0-based)
- **Returns:** the specified row array (direct reference to internal storage)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex &lt; 0 or rowIndex &gt; = rowCount
##### column(...) -> byte\[\]
- **Signature:** `public byte[] column(final int columnIndex) throws IllegalArgumentException`
- **Summary:** Returns a copy of the specified column as a new byte array.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to retrieve (0-based)
- **Returns:** a new array containing the values from the specified column
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex &lt; 0 or columnIndex &gt; = columnCount
##### setRow(...) -> void
- **Signature:** `public void setRow(final int rowIndex, final byte[] row) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified row by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of columns in the matrix.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to set (0-based)
  - `row` (`byte[]`) — the array of values to copy into the row; must have length equal to the number of columns
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex is out of bounds or row length does not match columnCount
##### setColumn(...) -> void
- **Signature:** `public void setColumn(final int columnIndex, final byte[] column) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified column by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of rows in the matrix.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to set (0-based)
  - `column` (`byte[]`) — the array of values to copy into the column; must have length equal to the number of rows
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex is out of bounds or column length does not match rowCount
##### updateRow(...) -> void
- **Signature:** `public <E extends Exception> void updateRow(final int rowIndex, final Throwables.ByteUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the specified row by applying the given operator to each element.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to update (0-based)
  - `operator` (`Throwables.ByteUnaryOperator<E>`) — the unary operator to apply to each element in the row, taking a byte and returning a byte
- **Throws:**
  - `E` — if the operator throws an exception
##### updateColumn(...) -> void
- **Signature:** `public <E extends Exception> void updateColumn(final int columnIndex, final Throwables.ByteUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the specified column by applying the given operator to each element.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to update (0-based)
  - `operator` (`Throwables.ByteUnaryOperator<E>`) — the unary operator to apply to each element in the column, taking a byte and returning a byte
- **Throws:**
  - `E` — if the operator throws an exception
##### getLU2RD(...) -> byte\[\]
- **Signature:** `public byte[] getLU2RD() throws IllegalStateException`
- **Summary:** Returns the elements on the main diagonal from left-upper to right-down.
- **Contract:**
  - The matrix must be square (rowCount == columnCount) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new byte array containing the main diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rowCount != columnCount)
##### setLU2RD(...) -> void
- **Signature:** `public void setLU2RD(final byte[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the main diagonal from left-upper to right-down (main diagonal).
- **Contract:**
  - The matrix must be square (rowCount == columnCount), and the diagonal array must have exactly as many elements as the matrix has rows.
- **Parameters:**
  - `diagonal` (`byte[]`) — the new values for the main diagonal; must have length equal to rowCount
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rowCount != columnCount)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal to rowCount
##### updateLU2RD(...) -> void
- **Signature:** `public <E extends Exception> void updateLU2RD(final Throwables.ByteUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements on the main diagonal (left-up to right-down) by applying the given operator.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - `operator` (`Throwables.ByteUnaryOperator<E>`) — the operator to apply to each diagonal element
- **Throws:**
  - `E` — if the operator throws an exception
##### getRU2LD(...) -> byte\[\]
- **Signature:** `public byte[] getRU2LD() throws IllegalStateException`
- **Summary:** Returns the elements on the anti-diagonal from right-upper to left-down.
- **Contract:**
  - The matrix must be square (rowCount == columnCount) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new byte array containing the anti-diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rowCount != columnCount)
##### setRU2LD(...) -> void
- **Signature:** `public void setRU2LD(final byte[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the anti-diagonal from right-upper to left-down (anti-diagonal).
- **Contract:**
  - The matrix must be square (rowCount == columnCount), and the diagonal array must have exactly as many elements as the matrix has rows.
- **Parameters:**
  - `diagonal` (`byte[]`) — the new values for the anti-diagonal; must have length equal to rowCount
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rowCount != columnCount)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal to rowCount
##### updateRU2LD(...) -> void
- **Signature:** `public <E extends Exception> void updateRU2LD(final Throwables.ByteUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements on the anti-diagonal (right-up to left-down) by applying the given operator.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - `operator` (`Throwables.ByteUnaryOperator<E>`) — the operator to apply to each anti-diagonal element
- **Throws:**
  - `E` — if the operator throws an exception
##### updateAll(...) -> void
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.ByteUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the matrix by applying the given operator to each element.
- **Parameters:**
  - `operator` (`Throwables.ByteUnaryOperator<E>`) — the unary operator to apply to each element, taking a byte and returning a byte
- **Throws:**
  - `E` — if the operator throws an exception
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.IntBiFunction<Byte, E> operator) throws E`
- **Summary:** Updates all elements in the matrix based on their position by applying the given operator.
- **Parameters:**
  - `operator` (`Throwables.IntBiFunction<Byte, E>`) — the bi-function that takes (rowIndex, columnIndex) and returns the new byte value
- **Throws:**
  - `E` — if the operator throws an exception
##### replaceIf(...) -> void
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.BytePredicate<E> predicate, final byte newValue) throws E`
- **Summary:** Conditionally replaces elements in the matrix based on a predicate.
- **Parameters:**
  - `predicate` (`Throwables.BytePredicate<E>`) — the condition to test each element; returns {@code true} if the element should be replaced
  - `newValue` (`byte`) — the value to use as replacement
- **Throws:**
  - `E` — if the predicate throws an exception
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.IntBiPredicate<E> predicate, final byte newValue) throws E`
- **Summary:** Conditionally replaces elements in the matrix based on their position.
- **Parameters:**
  - `predicate` (`Throwables.IntBiPredicate<E>`) — the bi-predicate that takes (rowIndex, columnIndex) and returns {@code true} if element should be replaced
  - `newValue` (`byte`) — the value to use as replacement
- **Throws:**
  - `E` — if the predicate throws an exception
##### map(...) -> ByteMatrix
- **Signature:** `public <E extends Exception> ByteMatrix map(final Throwables.ByteUnaryOperator<E> mapper) throws E`
- **Summary:** Creates a new ByteMatrix by applying the given function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.ByteUnaryOperator<E>`) — the unary operator to apply to each element, taking a byte and returning a byte
- **Returns:** a new ByteMatrix with the transformed values; the original matrix is unchanged
- **Throws:**
  - `E` — if the function throws an exception
##### mapToObj(...) -> Matrix<T>
- **Signature:** `public <T, E extends Exception> Matrix<T> mapToObj(final Throwables.ByteFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Creates a new object matrix by applying the given function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.ByteFunction<? extends T, E>`) — the function to transform each byte to an object of type T
  - `targetElementType` (`Class<T>`) — the class of the target element type (used for array creation)
- **Returns:** a new Matrix &lt; T &gt; with the transformed object values; the original matrix is unchanged
- **Throws:**
  - `E` — if the function throws an exception
##### fill(...) -> void
- **Signature:** `public void fill(final byte val)`
- **Summary:** Fills all elements of the matrix with the specified value.
- **Parameters:**
  - `val` (`byte`) — the value to fill the matrix with
- **Signature:** `public void fill(final byte[][] b)`
- **Summary:** Fills this matrix with values from another two-dimensional byte array, starting from position \[0,0\].
- **Contract:**
  - If the source array is smaller than this matrix, only the overlapping portion is modified.
  - If the source array is larger, only the portion that fits within this matrix is copied.
- **Parameters:**
  - `b` (`byte[][]`) — the source array to copy values from
- **See also:** #fill(int, int, byte\[\]\[\])
- **Signature:** `public void fill(final int fromRowIndex, final int fromColumnIndex, final byte[][] b) throws IllegalArgumentException`
- **Summary:** Fills a portion of this matrix with values from another two-dimensional byte array.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index in this matrix
  - `fromColumnIndex` (`int`) — the starting column index in this matrix
  - `b` (`byte[][]`) — the source array to copy values from
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the starting indices are negative or exceed matrix dimensions
##### copy(...) -> ByteMatrix
- **Signature:** `@Override public ByteMatrix copy()`
- **Summary:** Creates a copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is a copy of this matrix
- **Signature:** `@Override public ByteMatrix copy(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a row range from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a new ByteMatrix containing the specified rows
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds
- **Signature:** `@Override public ByteMatrix copy(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a rectangular region from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a new ByteMatrix containing the specified region
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any indices are out of bounds
##### extend(...) -> ByteMatrix
- **Signature:** `public ByteMatrix extend(final int newRowCount, final int newColumnCount)`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with 0.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of current matrix but must be non-negative
- **Returns:** a new ByteMatrix with the specified dimensions
- **Signature:** `public ByteMatrix extend(final int newRowCount, final int newColumnCount, final byte defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated from the top-left corner.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with the specified default value.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of current matrix but must be non-negative
  - `defaultValueForNewCell` (`byte`) — the byte value to fill new cells with during extension
- **Returns:** a new ByteMatrix with the specified dimensions
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code newRowCount} or {@code newColumnCount} is negative, or if the resulting matrix would be too large (dimensions exceeding Integer.MAX_VALUE elements)
- **Signature:** `public ByteMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight)`
- **Summary:** Creates a new matrix by extending this matrix in all four directions.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
- **Returns:** a new extended ByteMatrix with dimensions ((toUp+rowCount+toDown) x (toLeft+columnCount+toRight))
- **Signature:** `public ByteMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight, final byte defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending this matrix in all four directions with padding.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
  - `defaultValueForNewCell` (`byte`) — the byte value to fill all new cells with
- **Returns:** a new extended ByteMatrix with dimensions ((toUp+rowCount+toDown) x (toLeft+columnCount+toRight))
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any padding parameter is negative, or if the resulting dimensions would exceed Integer.MAX_VALUE
##### reverseH(...) -> void
- **Signature:** `public void reverseH()`
- **Summary:** Reverses the order of elements in each row horizontally in-place.
- **Parameters:**
  - (none)
- **See also:** #flipH()
##### reverseV(...) -> void
- **Signature:** `public void reverseV()`
- **Summary:** Reverses the order of rowCount in the matrix (vertical flip in-place).
- **Parameters:**
  - (none)
- **See also:** #flipV()
##### flipH(...) -> ByteMatrix
- **Signature:** `public ByteMatrix flipH()`
- **Summary:** Creates a new matrix that is horizontally flipped (each row reversed).
- **Parameters:**
  - (none)
- **Returns:** a new ByteMatrix with rowCount reversed
- **See also:** #flipV(), IntMatrix#flipH(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1,</a>
##### flipV(...) -> ByteMatrix
- **Signature:** `public ByteMatrix flipV()`
- **Summary:** Creates a new matrix that is vertically flipped (each column reversed).
- **Parameters:**
  - (none)
- **Returns:** a new ByteMatrix with columns reversed
- **See also:** #flipH(), IntMatrix#flipV(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1,</a>
##### rotate90(...) -> ByteMatrix
- **Signature:** `@Override public ByteMatrix rotate90()`
- **Summary:** Returns a new matrix rotated 90 degrees clockwise.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 90 degrees clockwise with dimensions (columnCount x rowCount)
- **See also:** #rotate180(), #rotate270()
##### rotate180(...) -> ByteMatrix
- **Signature:** `@Override public ByteMatrix rotate180()`
- **Summary:** Returns a new matrix rotated 180 degrees.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 180 degrees with the same dimensions
- **See also:** #rotate90(), #rotate270()
##### rotate270(...) -> ByteMatrix
- **Signature:** `@Override public ByteMatrix rotate270()`
- **Summary:** Returns a new matrix rotated 270 degrees clockwise (or 90 degrees counter-clockwise).
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 270 degrees clockwise with dimensions (columnCount x rowCount)
- **See also:** #rotate90(), #rotate180()
##### transpose(...) -> ByteMatrix
- **Signature:** `@Override public ByteMatrix transpose()`
- **Summary:** Creates the transpose of this matrix by swapping rowCount and columnCount.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is the transpose of this matrix with dimensions columnCount × rowCount
##### reshape(...) -> ByteMatrix
- **Signature:** `@SuppressFBWarnings("ICAST_INTEGER_MULTIPLY_CAST_TO_LONG") @Override public ByteMatrix reshape(final int newRowCount, final int newColumnCount)`
- **Summary:** Reshapes the matrix to new dimensions while preserving element order.
- **Contract:**
  - <p> The reshaping process follows these rules: <ul> <li> Elements are extracted from the original matrix in row-major order (left to right, top to bottom) </li> <li> Elements are placed into the new matrix in row-major order </li> <li> If the new shape has fewer total elements than the original, excess elements are truncated </li> <li> If the new shape has more total elements, the additional positions are filled with zeros </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code ByteMatrix matrix = ByteMatrix.of(new byte\[\]\[\] {{1, 2, 3}, {4, 5, 6}}); ByteMatrix reshaped = matrix.reshape(3, 2); // Becomes \[\[1, 2\], \[3, 4\], \[5, 6\]\] ByteMatrix extended = matrix.reshape(2, 4); // Becomes \[\[1, 2, 3, 4\], \[5, 6, 0, 0\]\] ByteMatrix truncated = matrix.reshape(1, 4); // Becomes \[\[1, 2, 3, 4\]\] } </pre>
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the reshaped matrix (must be non-negative)
  - `newColumnCount` (`int`) — the number of columns in the reshaped matrix (must be non-negative)
- **Returns:** a new ByteMatrix with the specified shape containing this matrix's elements
- **See also:** #extend(int, int)
##### repelem(...) -> ByteMatrix
- **Signature:** `@Override public ByteMatrix repelem(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by repeating each element multiple times.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat each element vertically
  - `colRepeats` (`int`) — number of times to repeat each element horizontally
- **Returns:** a new matrix with repeated elements
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
- **See also:** IntMatrix#repelem(int, int)
##### repmat(...) -> ByteMatrix
- **Signature:** `@Override public ByteMatrix repmat(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by repeating the entire matrix multiple times.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat the matrix vertically
  - `colRepeats` (`int`) — number of times to repeat the matrix horizontally
- **Returns:** a new matrix with the original matrix repeated
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
- **See also:** IntMatrix#repmat(int, int)
##### flatten(...) -> ByteList
- **Signature:** `@Override public ByteList flatten()`
- **Summary:** Returns a list containing all matrix elements in row-major order.
- **Contract:**
  - This is useful for bulk operations or when you need all matrix values as a flat collection.
- **Parameters:**
  - (none)
- **Returns:** a new ByteList containing all elements in row-major order
- **See also:** #streamH()
##### flatOp(...) -> void
- **Signature:** `@Override public <E extends Exception> void flatOp(final Throwables.Consumer<? super byte[], E> op) throws E`
- **Summary:** Applies an operation to each row's internal array using a flattened operation approach.
- **Parameters:**
  - `op` (`Throwables.Consumer<? super byte[], E>`) — the operation to apply to each row's internal array
- **Throws:**
  - `E` — if the operation throws an exception
- **See also:** Arrays#flatOp(byte\[\]\[\], Throwables.Consumer)
##### vstack(...) -> ByteMatrix
- **Signature:** `public ByteMatrix vstack(final ByteMatrix other) throws IllegalArgumentException`
- **Summary:** Stacks this matrix vertically with another matrix (row-wise concatenation).
- **Contract:**
  - The matrices must have the same number of columns.
- **Parameters:**
  - `other` (`ByteMatrix`) — the matrix to stack below this matrix
- **Returns:** a new ByteMatrix with other appended below this matrix
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different column counts
- **See also:** IntMatrix#vstack(IntMatrix)
##### hstack(...) -> ByteMatrix
- **Signature:** `public ByteMatrix hstack(final ByteMatrix other) throws IllegalArgumentException`
- **Summary:** Stacks this matrix horizontally with another matrix (column-wise concatenation).
- **Contract:**
  - The matrices must have the same number of rowCount.
- **Parameters:**
  - `other` (`ByteMatrix`) — the matrix to concatenate to the right of this matrix
- **Returns:** a new ByteMatrix with other appended to the right of this matrix
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different rowCount
- **See also:** IntMatrix#hstack(IntMatrix)
##### add(...) -> ByteMatrix
- **Signature:** `public ByteMatrix add(final ByteMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise addition with another matrix of the same dimensions.
- **Contract:**
  - If the sum exceeds the byte range (-128 to 127), the result will wrap around.
- **Parameters:**
  - `other` (`ByteMatrix`) — the matrix to add to this matrix; must have the same dimensions
- **Returns:** a new ByteMatrix containing the element-wise sum
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions (rows or columns don't match)
- **See also:** #subtract(ByteMatrix)
##### subtract(...) -> ByteMatrix
- **Signature:** `public ByteMatrix subtract(final ByteMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise subtraction with another matrix of the same dimensions.
- **Contract:**
  - If the difference goes below the byte range (-128 to 127), the result will wrap around.
- **Parameters:**
  - `other` (`ByteMatrix`) — the matrix to subtract from this matrix; must have the same dimensions
- **Returns:** a new ByteMatrix containing the element-wise difference
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions (rows or columns don't match)
- **See also:** #add(ByteMatrix)
##### multiply(...) -> ByteMatrix
- **Signature:** `public ByteMatrix multiply(final ByteMatrix other) throws IllegalArgumentException`
- **Summary:** Multiplies this matrix by another matrix (matrix multiplication).
- **Contract:**
  - The number of columns in this matrix must equal the number of rows in the other matrix.
- **Parameters:**
  - `other` (`ByteMatrix`) — the matrix to multiply with; must have row count equal to this matrix's column count
- **Returns:** a new ByteMatrix containing the matrix product with dimensions (this.rowCount x other.columnCount)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if this.columnCount != other.rowCount (incompatible dimensions for multiplication)
##### boxed(...) -> Matrix<Byte>
- **Signature:** `public Matrix<Byte> boxed()`
- **Summary:** Converts this primitive byte matrix to a boxed Byte Matrix.
- **Contract:**
  - <p> This conversion is useful when you need to work with APIs that require object types rather than primitives, or when you need null values in the matrix.
- **Parameters:**
  - (none)
- **Returns:** a new Matrix &lt; Byte &gt; with the same dimensions and values as this matrix
##### toIntMatrix(...) -> IntMatrix
- **Signature:** `public IntMatrix toIntMatrix()`
- **Summary:** Converts this ByteMatrix to an IntMatrix by widening each byte value to int.
- **Parameters:**
  - (none)
- **Returns:** a new IntMatrix with the same dimensions and values converted to int
- **See also:** #toLongMatrix(), #toFloatMatrix(), #toDoubleMatrix(), IntMatrix#from(byte\[\]\[\])
##### toLongMatrix(...) -> LongMatrix
- **Signature:** `public LongMatrix toLongMatrix()`
- **Summary:** Converts this ByteMatrix to a LongMatrix by widening each byte value to long.
- **Parameters:**
  - (none)
- **Returns:** a new LongMatrix with the same dimensions and values converted to long
- **See also:** #toIntMatrix(), #toFloatMatrix(), #toDoubleMatrix()
##### toFloatMatrix(...) -> FloatMatrix
- **Signature:** `public FloatMatrix toFloatMatrix()`
- **Summary:** Converts this ByteMatrix to a FloatMatrix by converting each byte value to float.
- **Parameters:**
  - (none)
- **Returns:** a new FloatMatrix with the same dimensions and values converted to float
- **See also:** #toIntMatrix(), #toLongMatrix(), #toDoubleMatrix()
##### toDoubleMatrix(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix toDoubleMatrix()`
- **Summary:** Converts this ByteMatrix to a DoubleMatrix by converting each byte value to double.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleMatrix with the same dimensions and values converted to double
- **See also:** #toIntMatrix(), #toLongMatrix(), #toFloatMatrix()
##### zipWith(...) -> ByteMatrix
- **Signature:** `public <E extends Exception> ByteMatrix zipWith(final ByteMatrix matrixB, final Throwables.ByteBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Applies a binary operation element-wise to this matrix and another matrix of the same shape.
- **Parameters:**
  - `matrixB` (`ByteMatrix`) — the second matrix
  - `zipFunction` (`Throwables.ByteBinaryOperator<E>`) — the binary operation to apply to corresponding elements
- **Returns:** a new ByteMatrix containing the results
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different shapes
  - `E` — if the zip function throws an exception
- **Signature:** `public <E extends Exception> ByteMatrix zipWith(final ByteMatrix matrixB, final ByteMatrix matrixC, final Throwables.ByteTernaryOperator<E> zipFunction) throws E`
- **Summary:** Applies a ternary operation element-wise to this matrix and two other matrices of the same shape.
- **Parameters:**
  - `matrixB` (`ByteMatrix`) — the second matrix
  - `matrixC` (`ByteMatrix`) — the third matrix
  - `zipFunction` (`Throwables.ByteTernaryOperator<E>`) — the ternary operation to apply to corresponding elements
- **Returns:** a new ByteMatrix containing the results
- **Throws:**
  - `E` — if the zip function throws an exception
##### streamLU2RD(...) -> ByteStream
- **Signature:** `@Override public ByteStream streamLU2RD()`
- **Summary:** Returns a stream of elements on the main diagonal (left-up to right-down).
- **Contract:**
  - The matrix must be square (rowCount == columnCount) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a ByteStream of diagonal elements
##### streamRU2LD(...) -> ByteStream
- **Signature:** `@Override public ByteStream streamRU2LD()`
- **Summary:** Returns a stream of elements on the anti-diagonal (right-up to left-down).
- **Contract:**
  - The matrix must be square (rowCount == columnCount) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a ByteStream of anti-diagonal elements
##### streamH(...) -> ByteStream
- **Signature:** `@Override public ByteStream streamH()`
- **Summary:** Returns a stream of all elements in row-major order (horizontally).
- **Parameters:**
  - (none)
- **Returns:** a ByteStream of all matrix elements in row-major order
- **See also:** #streamV(), #streamR()
- **Signature:** `@Override public ByteStream streamH(final int rowIndex)`
- **Summary:** Returns a stream of elements from a specific row.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to stream (0-based)
- **Returns:** a ByteStream of elements from the specified row
- **Signature:** `@Override public ByteStream streamH(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of elements from a range of rows in row-major order.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a ByteStream of elements from the specified rows
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds
##### streamV(...) -> ByteStream
- **Signature:** `@Override @Beta public ByteStream streamV()`
- **Summary:** Returns a stream of all elements in column-major order (vertically).
- **Parameters:**
  - (none)
- **Returns:** a ByteStream of all matrix elements in column-major order
- **See also:** #streamH(), #streamC()
- **Signature:** `@Override public ByteStream streamV(final int columnIndex)`
- **Summary:** Returns a stream of elements from a specific column.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to stream (0-based)
- **Returns:** a ByteStream of elements from the specified column
- **Signature:** `@Override @Beta public ByteStream streamV(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of elements from a range of columns in column-major order.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a ByteStream of elements from the specified columns
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds
##### streamR(...) -> Stream<ByteStream>
- **Signature:** `@Override public Stream<ByteStream> streamR()`
- **Summary:** Returns a stream where each element is a ByteStream representing a row of the matrix.
- **Contract:**
  - This is useful for row-wise operations or when you need to apply stream operations to individual rows.
- **Parameters:**
  - (none)
- **Returns:** a Stream of ByteStream, one for each row in the matrix
- **See also:** #streamC(), #streamH()
- **Signature:** `@Override public Stream<ByteStream> streamR(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream where each element is a ByteStream representing a row from the specified range.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a Stream of ByteStream, one for each row in the range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds
##### streamC(...) -> Stream<ByteStream>
- **Signature:** `@Override @Beta public Stream<ByteStream> streamC()`
- **Summary:** Returns a stream where each element is a ByteStream representing a column of the matrix.
- **Contract:**
  - This is useful for column-wise operations or when you need to apply stream operations to individual columns.
- **Parameters:**
  - (none)
- **Returns:** a Stream of ByteStream, one for each column in the matrix
- **See also:** #streamR(), #streamV()
- **Signature:** `@Override @Beta public Stream<ByteStream> streamC(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream where each element is a ByteStream representing a column from the specified range.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a Stream of ByteStream, one for each column in the range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.ByteConsumer<E> action) throws E`
- **Summary:** Applies the specified action to each element in the matrix.
- **Parameters:**
  - `action` (`Throwables.ByteConsumer<E>`) — the consumer to apply to each element
- **Throws:**
  - `E` — if the action throws an exception
- **Signature:** `public <E extends Exception> void forEach(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.ByteConsumer<E> action) throws IndexOutOfBoundsException, E`
- **Summary:** Applies the specified action to each element in a rectangular sub-region of the matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
  - `action` (`Throwables.ByteConsumer<E>`) — the consumer to apply to each element in the region
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is out of bounds or fromIndex &gt; toIndex
  - `E` — if the action throws an exception
##### println(...) -> String
- **Signature:** `@Override public String println()`
- **Summary:** Prints the matrix to standard output in a human-readable formatted manner.
- **Parameters:**
  - (none)
- **Returns:** the formatted string representation of the matrix
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this matrix based on its contents.
- **Contract:**
  - <p> This implementation is consistent with the {@link #equals(Object)} method: if two matrices are equal according to {@code equals()} , they will have the same hash code.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this matrix based on its contents
- **See also:** #equals(Object)
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this matrix to the specified object for equality.
- **Contract:**
  - Two ByteMatrix objects are considered equal if and only if: <ul> <li> They have the same number of rows </li> <li> They have the same number of columns </li> <li> All corresponding elements are equal </li> </ul> <p> This method performs a deep comparison of all matrix elements.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with this matrix
- **Returns:** {@code true} if the objects are equal ByteMatrix instances with identical contents, {@code false} otherwise
- **See also:** #hashCode()
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this matrix in a compact two-dimensional array format.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this matrix in two-dimensional array format
- **See also:** #println()

### Class ByteTuple (com.landawn.abacus.util.ByteTuple)
Abstract base class for immutable tuple implementations that hold primitive byte values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ByteTuple1
- **Signature:** `public static ByteTuple1 of(final byte _1)`
- **Summary:** Creates a ByteTuple.ByteTuple1 containing a single byte value.
- **Parameters:**
  - `_1` (`byte`) — the byte value to store in the tuple
- **Returns:** a new ByteTuple.ByteTuple1 containing the specified value
- **Signature:** `public static ByteTuple2 of(final byte _1, final byte _2)`
- **Summary:** Creates a ByteTuple.ByteTuple2 containing two byte values.
- **Parameters:**
  - `_1` (`byte`) — the first byte value
  - `_2` (`byte`) — the second byte value
- **Returns:** a new ByteTuple.ByteTuple2 containing the specified values
- **Signature:** `public static ByteTuple3 of(final byte _1, final byte _2, final byte _3)`
- **Summary:** Creates a ByteTuple.ByteTuple3 containing three byte values.
- **Parameters:**
  - `_1` (`byte`) — the first byte value
  - `_2` (`byte`) — the second byte value
  - `_3` (`byte`) — the third byte value
- **Returns:** a new ByteTuple.ByteTuple3 containing the specified values
- **Signature:** `public static ByteTuple4 of(final byte _1, final byte _2, final byte _3, final byte _4)`
- **Summary:** Creates a ByteTuple.ByteTuple4 containing four byte values.
- **Parameters:**
  - `_1` (`byte`) — the first byte value
  - `_2` (`byte`) — the second byte value
  - `_3` (`byte`) — the third byte value
  - `_4` (`byte`) — the fourth byte value
- **Returns:** a new ByteTuple.ByteTuple4 containing the specified values
- **Signature:** `public static ByteTuple5 of(final byte _1, final byte _2, final byte _3, final byte _4, final byte _5)`
- **Summary:** Creates a ByteTuple.ByteTuple5 containing five byte values.
- **Parameters:**
  - `_1` (`byte`) — the first byte value
  - `_2` (`byte`) — the second byte value
  - `_3` (`byte`) — the third byte value
  - `_4` (`byte`) — the fourth byte value
  - `_5` (`byte`) — the fifth byte value
- **Returns:** a new ByteTuple.ByteTuple5 containing the specified values
- **Signature:** `public static ByteTuple6 of(final byte _1, final byte _2, final byte _3, final byte _4, final byte _5, final byte _6)`
- **Summary:** Creates a ByteTuple.ByteTuple6 containing six byte values.
- **Parameters:**
  - `_1` (`byte`) — the first byte value
  - `_2` (`byte`) — the second byte value
  - `_3` (`byte`) — the third byte value
  - `_4` (`byte`) — the fourth byte value
  - `_5` (`byte`) — the fifth byte value
  - `_6` (`byte`) — the sixth byte value
- **Returns:** a new ByteTuple.ByteTuple6 containing the specified values
- **Signature:** `public static ByteTuple7 of(final byte _1, final byte _2, final byte _3, final byte _4, final byte _5, final byte _6, final byte _7)`
- **Summary:** Creates a ByteTuple.ByteTuple7 containing seven byte values.
- **Parameters:**
  - `_1` (`byte`) — the first byte value
  - `_2` (`byte`) — the second byte value
  - `_3` (`byte`) — the third byte value
  - `_4` (`byte`) — the fourth byte value
  - `_5` (`byte`) — the fifth byte value
  - `_6` (`byte`) — the sixth byte value
  - `_7` (`byte`) — the seventh byte value
- **Returns:** a new ByteTuple.ByteTuple7 containing the specified values
- **Signature:** `@Deprecated public static ByteTuple8 of(final byte _1, final byte _2, final byte _3, final byte _4, final byte _5, final byte _6, final byte _7, final byte _8)`
- **Summary:** Creates a ByteTuple.ByteTuple8 containing eight byte values.
- **Parameters:**
  - `_1` (`byte`) — the first byte value
  - `_2` (`byte`) — the second byte value
  - `_3` (`byte`) — the third byte value
  - `_4` (`byte`) — the fourth byte value
  - `_5` (`byte`) — the fifth byte value
  - `_6` (`byte`) — the sixth byte value
  - `_7` (`byte`) — the seventh byte value
  - `_8` (`byte`) — the eighth byte value
- **Returns:** a new ByteTuple.ByteTuple8 containing the specified values
- **Signature:** `@Deprecated public static ByteTuple9 of(final byte _1, final byte _2, final byte _3, final byte _4, final byte _5, final byte _6, final byte _7, final byte _8, final byte _9)`
- **Summary:** Creates a ByteTuple.ByteTuple9 containing nine byte values.
- **Parameters:**
  - `_1` (`byte`) — the first byte value
  - `_2` (`byte`) — the second byte value
  - `_3` (`byte`) — the third byte value
  - `_4` (`byte`) — the fourth byte value
  - `_5` (`byte`) — the fifth byte value
  - `_6` (`byte`) — the sixth byte value
  - `_7` (`byte`) — the seventh byte value
  - `_8` (`byte`) — the eighth byte value
  - `_9` (`byte`) — the ninth byte value
- **Returns:** a new ByteTuple.ByteTuple9 containing the specified values
##### create(...) -> TP
- **Signature:** `@SuppressWarnings("deprecation") public static <TP extends ByteTuple<TP>> TP create(final byte[] values)`
- **Summary:** Creates a ByteTuple from an array of byte values.
- **Parameters:**
  - `values` (`byte[]`) — the array of byte values (must have length 0-9), may be {@code null}
- **Returns:** a ByteTuple of appropriate size containing the array values, or an empty ByteTuple if the array is null or empty

#### Public Instance Methods
##### min(...) -> byte
- **Signature:** `public byte min()`
- **Summary:** Returns the minimum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the minimum byte value in this tuple
##### max(...) -> byte
- **Signature:** `public byte max()`
- **Summary:** Returns the maximum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the maximum byte value in this tuple
##### median(...) -> byte
- **Signature:** `public byte median()`
- **Summary:** Returns the median byte value in this tuple.
- **Contract:**
  - <p> The median is the middle value when all elements are sorted.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Odd number of elements ByteTuple.ByteTuple3 tuple3 = ByteTuple.of((byte) 30, (byte) 10, (byte) 20); byte median = tuple3.median(); // 20 (middle value when sorted: 10, 20, 30) // Even number of elements ByteTuple.ByteTuple4 tuple4 = ByteTuple.of((byte) 10, (byte) 20, (byte) 30, (byte) 40); byte median2 = tuple4.median(); // 20 (lower middle element) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median byte value in this tuple
##### sum(...) -> int
- **Signature:** `public int sum()`
- **Summary:** Returns the sum of all byte values in this tuple as an integer.
- **Contract:**
  - The result is returned as an int to prevent overflow issues that could occur if the sum exceeds the byte range (-128 to 127).
- **Parameters:**
  - (none)
- **Returns:** the sum of all byte values in this tuple as an integer
##### average(...) -> double
- **Signature:** `public double average()`
- **Summary:** Returns the average of all byte values in this tuple as a double.
- **Parameters:**
  - (none)
- **Returns:** the average of all byte values in this tuple as a double
##### reverse(...) -> TP
- **Signature:** `public abstract TP reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new tuple with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `public abstract boolean contains(byte valueToFind)`
- **Summary:** Checks if this tuple contains the specified byte value.
- **Contract:**
  - Checks if this tuple contains the specified byte value.
  - <p> This method performs a linear search through all elements in the tuple to determine if any element matches the specified value.
  - Returns {@code true} if at least one element equals the search value, {@code false} otherwise.
- **Parameters:**
  - `valueToFind` (`byte`) — the byte value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### toArray(...) -> byte\[\]
- **Signature:** `public byte[] toArray()`
- **Summary:** Returns a new array containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new byte array containing all tuple elements
##### toList(...) -> ByteList
- **Signature:** `public ByteList toList()`
- **Summary:** Returns a new ByteList containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new ByteList containing all tuple elements
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.ByteConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.ByteConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `E` — if the consumer throws an exception during execution
##### stream(...) -> ByteStream
- **Signature:** `public ByteStream stream()`
- **Summary:** Returns a ByteStream of all elements in this tuple.
- **Parameters:**
  - (none)
- **Returns:** a ByteStream containing all tuple elements
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this tuple
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Contract:**
  - <p> Two tuples are considered equal if and only if: </p> <ul> <li> They are the same object (reference equality), or </li> <li> They are instances of the exact same class, and </li> <li> They contain the same byte values in the same order </li> </ul> This method is consistent with {@link #hashCode()} .
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is equal to this tuple, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this tuple

### Class ByteTuple1 (com.landawn.abacus.util.ByteTuple.ByteTuple1)
A ByteTuple containing exactly one byte element.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 1.
- **Parameters:**
  - (none)
- **Returns:** 1
##### min(...) -> byte
- **Signature:** `@Override public byte min()`
- **Summary:** Returns the minimum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single byte value in this tuple
##### max(...) -> byte
- **Signature:** `@Override public byte max()`
- **Summary:** Returns the maximum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single byte value in this tuple
##### median(...) -> byte
- **Signature:** `@Override public byte median()`
- **Summary:** Returns the median byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single byte value in this tuple
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single byte value as an integer
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single byte value as a double
##### reverse(...) -> ByteTuple1
- **Signature:** `@Override public ByteTuple1 reverse()`
- **Summary:** Returns a new ByteTuple.ByteTuple1 with the same element.
- **Parameters:**
  - (none)
- **Returns:** a new ByteTuple.ByteTuple1 with the same element
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final byte valueToFind)`
- **Summary:** Checks if this tuple contains the specified byte value.
- **Contract:**
  - Checks if this tuple contains the specified byte value.
- **Parameters:**
  - `valueToFind` (`byte`) — the byte value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** the byte value as the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a ByteTuple.ByteTuple1 with the same element
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element)"

### Class ByteTuple2 (com.landawn.abacus.util.ByteTuple.ByteTuple2)
A ByteTuple containing exactly two byte elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 2.
- **Parameters:**
  - (none)
- **Returns:** 2
##### min(...) -> byte
- **Signature:** `@Override public byte min()`
- **Summary:** Returns the minimum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smaller of the two byte values
##### max(...) -> byte
- **Signature:** `@Override public byte max()`
- **Summary:** Returns the maximum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the larger of the two byte values
##### median(...) -> byte
- **Signature:** `@Override public byte median()`
- **Summary:** Returns the median byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the median (lower) byte value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of both byte values as an integer
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of both byte values as a double
##### reverse(...) -> ByteTuple2
- **Signature:** `@Override public ByteTuple2 reverse()`
- **Summary:** Returns a new ByteTuple.ByteTuple2 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ByteTuple.ByteTuple2 with elements swapped
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final byte valueToFind)`
- **Summary:** Checks if this tuple contains the specified byte value.
- **Contract:**
  - Checks if this tuple contains the specified byte value.
- **Parameters:**
  - `valueToFind` (`byte`) — the byte value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ByteConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Contract:**
  - This method is useful for side effects that should be applied to each element separately.
- **Parameters:**
  - `consumer` (`Throwables.ByteConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `E` — if the consumer throws an exception during execution
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.ByteBiConsumer<E> action) throws E`
- **Summary:** Applies the given bi-consumer to both elements of this tuple.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code ByteTuple.ByteTuple2 tuple = ByteTuple.of((byte) 10, (byte) 20); // Print both values tuple.accept((a, b) -> System.out.println(a + " + " + b + " = " + (a + b))); // Output: 10 + 20 = 30 // Update external state with both values Map<String, Integer> results = new HashMap<>(); tuple.accept((a, b) -> results.put("sum", (int)(a + b))); // Compare and log tuple.accept((a, b) -> { if (a < b) { System.out.println(a + " is less than " + b); } }); } </pre>
- **Parameters:**
  - `action` (`Throwables.ByteBiConsumer<E>`) — the bi-consumer to apply to both elements, must not be {@code null}
- **Throws:**
  - `E` — if the action throws an exception during execution
##### map(...) -> U
- **Signature:** `public <U, E extends Exception> U map(final Throwables.ByteBiFunction<U, E> mapper) throws E`
- **Summary:** Applies the given bi-function to both elements of this tuple and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.ByteBiFunction<U, E>`) — the bi-function to apply to both elements, must not be {@code null}
- **Returns:** the result of applying the bi-function to both elements
- **Throws:**
  - `E` — if the mapper throws an exception during execution
##### filter(...) -> Optional<ByteTuple2>
- **Signature:** `public <E extends Exception> Optional<ByteTuple2> filter(final Throwables.ByteBiPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if it matches the given bi-predicate, otherwise returns an empty Optional.
- **Contract:**
  - Returns an Optional containing this tuple if it matches the given bi-predicate, otherwise returns an empty Optional.
  - If the bi-predicate evaluates to {@code true} when applied to both elements, the tuple is wrapped in an Optional and returned.
- **Parameters:**
  - `predicate` (`Throwables.ByteBiPredicate<E>`) — the bi-predicate to test both elements, must not be {@code null}
- **Returns:** an Optional containing this tuple if the predicate returns {@code true} , empty Optional otherwise
- **Throws:**
  - `E` — if the predicate throws an exception during evaluation
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from both elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a ByteTuple.ByteTuple2 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2)"

### Class ByteTuple3 (com.landawn.abacus.util.ByteTuple.ByteTuple3)
A ByteTuple containing exactly three byte elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 3.
- **Parameters:**
  - (none)
- **Returns:** 3
##### min(...) -> byte
- **Signature:** `@Override public byte min()`
- **Summary:** Returns the minimum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the three byte values
##### max(...) -> byte
- **Signature:** `@Override public byte max()`
- **Summary:** Returns the maximum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the three byte values
##### median(...) -> byte
- **Signature:** `@Override public byte median()`
- **Summary:** Returns the median byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the middle byte value when sorted
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of all three byte values as an integer
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of all three byte values as a double
##### reverse(...) -> ByteTuple3
- **Signature:** `@Override public ByteTuple3 reverse()`
- **Summary:** Returns a new ByteTuple.ByteTuple3 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ByteTuple.ByteTuple3 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final byte valueToFind)`
- **Summary:** Checks if this tuple contains the specified byte value.
- **Contract:**
  - Checks if this tuple contains the specified byte value.
- **Parameters:**
  - `valueToFind` (`byte`) — the byte value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ByteConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Contract:**
  - This method is useful for side effects that should be applied to each element separately.
- **Parameters:**
  - `consumer` (`Throwables.ByteConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `E` — if the consumer throws an exception during execution
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.ByteTriConsumer<E> action) throws E`
- **Summary:** Applies the given tri-consumer to all three elements of this tuple.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code ByteTuple.ByteTuple3 tuple = ByteTuple.of((byte) 10, (byte) 20, (byte) 30); // Print all three values tuple.accept((a, b, c) -> System.out.println(a + ", " + b + ", " + c)); // Output: 10, 20, 30 // Calculate and store result Map<String, Integer> results = new HashMap<>(); tuple.accept((a, b, c) -> results.put("sum", (int)(a + b + c))); // Validate and log tuple.accept((a, b, c) -> { if (a < b && b < c) { System.out.println("Values are in ascending order"); } }); // Update external state java.util.concurrent.atomic.AtomicInteger max = new java.util.concurrent.atomic.AtomicInteger(); tuple.accept((a, b, c) -> max.set(Math.max(Math.max(a, b), c))); } </pre>
- **Parameters:**
  - `action` (`Throwables.ByteTriConsumer<E>`) — the tri-consumer to apply to all three elements, must not be {@code null}
- **Throws:**
  - `E` — if the action throws an exception during execution
##### map(...) -> U
- **Signature:** `public <U, E extends Exception> U map(final Throwables.ByteTriFunction<U, E> mapper) throws E`
- **Summary:** Applies the given tri-function to all three elements of this tuple and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.ByteTriFunction<U, E>`) — the tri-function to apply to all three elements, must not be {@code null}
- **Returns:** the result of applying the tri-function to all three elements
- **Throws:**
  - `E` — if the mapper throws an exception during execution
##### filter(...) -> Optional<ByteTuple3>
- **Signature:** `public <E extends Exception> Optional<ByteTuple3> filter(final Throwables.ByteTriPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if it matches the given tri-predicate, otherwise returns an empty Optional.
- **Contract:**
  - Returns an Optional containing this tuple if it matches the given tri-predicate, otherwise returns an empty Optional.
  - If the tri-predicate evaluates to {@code true} when applied to all three elements, the tuple is wrapped in an Optional and returned.
- **Parameters:**
  - `predicate` (`Throwables.ByteTriPredicate<E>`) — the tri-predicate to test all three elements, must not be {@code null}
- **Returns:** an Optional containing this tuple if the predicate returns {@code true} , empty Optional otherwise
- **Throws:**
  - `E` — if the predicate throws an exception during evaluation
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from all three elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a ByteTuple.ByteTuple3 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3)"

### Class ByteTuple4 (com.landawn.abacus.util.ByteTuple.ByteTuple4)
A ByteTuple containing exactly four byte elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 4.
- **Parameters:**
  - (none)
- **Returns:** 4
##### min(...) -> byte
- **Signature:** `@Override public byte min()`
- **Summary:** Returns the minimum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the four byte values
##### max(...) -> byte
- **Signature:** `@Override public byte max()`
- **Summary:** Returns the maximum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the four byte values
##### median(...) -> byte
- **Signature:** `@Override public byte median()`
- **Summary:** Returns the median byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the median byte value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of all four byte values as an integer
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of all four byte values as a double
##### reverse(...) -> ByteTuple4
- **Signature:** `@Override public ByteTuple4 reverse()`
- **Summary:** Returns a new ByteTuple.ByteTuple4 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ByteTuple.ByteTuple4 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final byte valueToFind)`
- **Summary:** Checks if this tuple contains the specified byte value.
- **Contract:**
  - Checks if this tuple contains the specified byte value.
- **Parameters:**
  - `valueToFind` (`byte`) — the byte value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ByteConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Contract:**
  - This method is useful for side effects that should be applied to each element separately.
- **Parameters:**
  - `consumer` (`Throwables.ByteConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `E` — if the consumer throws an exception during execution
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all four elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ByteTuple.ByteTuple4 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ByteTuple.ByteTuple4 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3, element4)"

### Class ByteTuple5 (com.landawn.abacus.util.ByteTuple.ByteTuple5)
A ByteTuple containing exactly five byte elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 5.
- **Parameters:**
  - (none)
- **Returns:** 5
##### min(...) -> byte
- **Signature:** `@Override public byte min()`
- **Summary:** Returns the minimum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the five byte values
##### max(...) -> byte
- **Signature:** `@Override public byte max()`
- **Summary:** Returns the maximum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the five byte values
##### median(...) -> byte
- **Signature:** `@Override public byte median()`
- **Summary:** Returns the median byte value in this tuple.
- **Contract:**
  - For tuples with an odd number of elements, returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the median byte value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of all five byte values as an integer
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of all five byte values as a double
##### reverse(...) -> ByteTuple5
- **Signature:** `@Override public ByteTuple5 reverse()`
- **Summary:** Returns a new ByteTuple.ByteTuple5 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ByteTuple.ByteTuple5 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final byte valueToFind)`
- **Summary:** Checks if this tuple contains the specified byte value.
- **Contract:**
  - Checks if this tuple contains the specified byte value.
- **Parameters:**
  - `valueToFind` (`byte`) — the byte value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ByteConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Contract:**
  - This method is useful for side effects that should be applied to each element separately.
- **Parameters:**
  - `consumer` (`Throwables.ByteConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `E` — if the consumer throws an exception during execution
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all five elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ByteTuple.ByteTuple5 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ByteTuple.ByteTuple5 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3, element4, element5)"

### Class ByteTuple6 (com.landawn.abacus.util.ByteTuple.ByteTuple6)
A ByteTuple containing exactly six byte elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 6.
- **Parameters:**
  - (none)
- **Returns:** 6
##### min(...) -> byte
- **Signature:** `@Override public byte min()`
- **Summary:** Returns the minimum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the six byte values
##### max(...) -> byte
- **Signature:** `@Override public byte max()`
- **Summary:** Returns the maximum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the six byte values
##### median(...) -> byte
- **Signature:** `@Override public byte median()`
- **Summary:** Returns the median byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the median byte value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of all six byte values as an integer
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of all six byte values as a double
##### reverse(...) -> ByteTuple6
- **Signature:** `@Override public ByteTuple6 reverse()`
- **Summary:** Returns a new ByteTuple.ByteTuple6 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ByteTuple.ByteTuple6 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final byte valueToFind)`
- **Summary:** Checks if this tuple contains the specified byte value.
- **Contract:**
  - Checks if this tuple contains the specified byte value.
- **Parameters:**
  - `valueToFind` (`byte`) — the byte value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ByteConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Contract:**
  - This method is useful for side effects that should be applied to each element separately.
- **Parameters:**
  - `consumer` (`Throwables.ByteConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `E` — if the consumer throws an exception during execution
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all six elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ByteTuple.ByteTuple6 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ByteTuple.ByteTuple6 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3, element4, element5, element6)"

### Class ByteTuple7 (com.landawn.abacus.util.ByteTuple.ByteTuple7)
A ByteTuple containing exactly seven byte elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 7.
- **Parameters:**
  - (none)
- **Returns:** 7
##### min(...) -> byte
- **Signature:** `@Override public byte min()`
- **Summary:** Returns the minimum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the seven byte values
##### max(...) -> byte
- **Signature:** `@Override public byte max()`
- **Summary:** Returns the maximum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the seven byte values
##### median(...) -> byte
- **Signature:** `@Override public byte median()`
- **Summary:** Returns the median byte value in this tuple.
- **Contract:**
  - For tuples with an odd number of elements, returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the median byte value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of all seven byte values as an integer
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of all seven byte values as a double
##### reverse(...) -> ByteTuple7
- **Signature:** `@Override public ByteTuple7 reverse()`
- **Summary:** Returns a new ByteTuple.ByteTuple7 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ByteTuple.ByteTuple7 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final byte valueToFind)`
- **Summary:** Checks if this tuple contains the specified byte value.
- **Contract:**
  - Checks if this tuple contains the specified byte value.
- **Parameters:**
  - `valueToFind` (`byte`) — the byte value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ByteConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Contract:**
  - This method is useful for side effects that should be applied to each element separately.
- **Parameters:**
  - `consumer` (`Throwables.ByteConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `E` — if the consumer throws an exception during execution
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all seven elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ByteTuple.ByteTuple7 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ByteTuple.ByteTuple7 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3, element4, element5, element6, element7)"

### Class ByteTuple8 (com.landawn.abacus.util.ByteTuple.ByteTuple8)
A ByteTuple containing exactly eight byte elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 8.
- **Parameters:**
  - (none)
- **Returns:** 8
##### min(...) -> byte
- **Signature:** `@Override public byte min()`
- **Summary:** Returns the minimum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the eight byte values
##### max(...) -> byte
- **Signature:** `@Override public byte max()`
- **Summary:** Returns the maximum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the eight byte values
##### median(...) -> byte
- **Signature:** `@Override public byte median()`
- **Summary:** Returns the median byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the median byte value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of all eight byte values as an integer
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of all eight byte values as a double
##### reverse(...) -> ByteTuple8
- **Signature:** `@Override public ByteTuple8 reverse()`
- **Summary:** Returns a new ByteTuple.ByteTuple8 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ByteTuple.ByteTuple8 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final byte valueToFind)`
- **Summary:** Checks if this tuple contains the specified byte value.
- **Contract:**
  - Checks if this tuple contains the specified byte value.
- **Parameters:**
  - `valueToFind` (`byte`) — the byte value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ByteConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Contract:**
  - This method is useful for side effects that should be applied to each element separately.
- **Parameters:**
  - `consumer` (`Throwables.ByteConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `E` — if the consumer throws an exception during execution
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all eight elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ByteTuple.ByteTuple8 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ByteTuple.ByteTuple8 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3, element4, element5, element6, element7, element8)"

### Class ByteTuple9 (com.landawn.abacus.util.ByteTuple.ByteTuple9)
A ByteTuple containing exactly nine byte elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 9.
- **Parameters:**
  - (none)
- **Returns:** 9
##### min(...) -> byte
- **Signature:** `@Override public byte min()`
- **Summary:** Returns the minimum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the nine byte values
##### max(...) -> byte
- **Signature:** `@Override public byte max()`
- **Summary:** Returns the maximum byte value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the nine byte values
##### median(...) -> byte
- **Signature:** `@Override public byte median()`
- **Summary:** Returns the median byte value in this tuple.
- **Contract:**
  - For tuples with an odd number of elements, returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the median byte value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of all nine byte values as an integer
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all byte values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of all nine byte values as a double
##### reverse(...) -> ByteTuple9
- **Signature:** `@Override public ByteTuple9 reverse()`
- **Summary:** Returns a new ByteTuple.ByteTuple9 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ByteTuple.ByteTuple9 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final byte valueToFind)`
- **Summary:** Checks if this tuple contains the specified byte value.
- **Contract:**
  - Checks if this tuple contains the specified byte value.
- **Parameters:**
  - `valueToFind` (`byte`) — the byte value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ByteConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Contract:**
  - This method is useful for side effects that should be applied to each element separately.
- **Parameters:**
  - `consumer` (`Throwables.ByteConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `E` — if the consumer throws an exception during execution
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all nine elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ByteTuple.ByteTuple9 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ByteTuple.ByteTuple9 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3, element4, element5, element6, element7, element8, element9)"

### Class CharMatrix (com.landawn.abacus.util.CharMatrix)
A matrix implementation for char primitive values, providing efficient storage and operations for two-dimensional char arrays.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### empty(...) -> CharMatrix
- **Signature:** `public static CharMatrix empty()`
- **Summary:** Creates an empty matrix with zero rows and zero columns.
- **Parameters:**
  - (none)
- **Returns:** an empty char matrix
##### of(...) -> CharMatrix
- **Signature:** `public static CharMatrix of(final char[]... a)`
- **Summary:** Creates a CharMatrix from a two-dimensional char array.
- **Parameters:**
  - `a` (`char[][]`) — the two-dimensional char array to create the matrix from, or null/empty for an empty matrix
- **Returns:** a new CharMatrix containing the provided data, or an empty CharMatrix if input is null or empty
##### random(...) -> CharMatrix
- **Signature:** `public static CharMatrix random(final int size)`
- **Summary:** Creates a new 1xsize matrix filled with random char values.
- **Parameters:**
  - `size` (`int`) — the number of columns in the new matrix
- **Returns:** a new CharMatrix of dimensions 1 x size filled with random values
- **Signature:** `public static CharMatrix random(final int rowCount, final int columnCount)`
- **Summary:** Creates a new matrix of the specified dimensions filled with random char values.
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
- **Returns:** a new CharMatrix of dimensions rowCount x columnCount filled with random values
##### repeat(...) -> CharMatrix
- **Signature:** `public static CharMatrix repeat(final int rowCount, final int columnCount, final char element)`
- **Summary:** Creates a new matrix of the specified dimensions where every element is the provided {@code element} .
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
  - `element` (`char`) — the char value to fill the matrix with
- **Returns:** a new CharMatrix of dimensions rowCount x columnCount filled with the specified element
##### range(...) -> CharMatrix
- **Signature:** `public static CharMatrix range(final char startInclusive, final char endExclusive)`
- **Summary:** Creates a single-row CharMatrix containing a range of char values.
- **Parameters:**
  - `startInclusive` (`char`) — the starting char value (inclusive)
  - `endExclusive` (`char`) — the ending char value (exclusive)
- **Returns:** a CharMatrix with one row containing the range of values
- **Signature:** `public static CharMatrix range(final char startInclusive, final char endExclusive, final int by)`
- **Summary:** Creates a single-row CharMatrix containing a range of char values with a step.
- **Parameters:**
  - `startInclusive` (`char`) — the starting char value (inclusive)
  - `endExclusive` (`char`) — the ending char value (exclusive)
  - `by` (`int`) — the step size (must not be zero; can be positive or negative)
- **Returns:** a new 1×n CharMatrix with values incremented by the step size
##### rangeClosed(...) -> CharMatrix
- **Signature:** `public static CharMatrix rangeClosed(final char startInclusive, final char endInclusive)`
- **Summary:** Creates a single-row CharMatrix containing a closed range of char values.
- **Parameters:**
  - `startInclusive` (`char`) — the starting char value (inclusive)
  - `endInclusive` (`char`) — the ending char value (inclusive)
- **Returns:** a CharMatrix with one row containing the range of values
- **Signature:** `public static CharMatrix rangeClosed(final char startInclusive, final char endInclusive, final int by)`
- **Summary:** Creates a single-row CharMatrix containing a closed range of char values with a step.
- **Parameters:**
  - `startInclusive` (`char`) — the starting char value (inclusive)
  - `endInclusive` (`char`) — the ending char value (inclusive, if reachable by stepping)
  - `by` (`int`) — the step size (must not be zero; can be positive or negative)
- **Returns:** a new 1×n CharMatrix with values incremented by the step size
##### diagonalLU2RD(...) -> CharMatrix
- **Signature:** `public static CharMatrix diagonalLU2RD(final char[] leftUp2RightDownDiagonal)`
- **Summary:** Creates a square matrix from the specified main diagonal elements (left-up to right-down).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`char[]`) — the array of main diagonal elements
- **Returns:** a square matrix with the specified main diagonal (n×n where n = diagonal length)
##### diagonalRU2LD(...) -> CharMatrix
- **Signature:** `public static CharMatrix diagonalRU2LD(final char[] rightUp2LeftDownDiagonal)`
- **Summary:** Creates a square matrix from the specified anti-diagonal elements (right-upper to left-down).
- **Parameters:**
  - `rightUp2LeftDownDiagonal` (`char[]`) — the array of anti-diagonal elements
- **Returns:** a square matrix with the specified anti-diagonal (n×n where n = diagonal length)
##### diagonal(...) -> CharMatrix
- **Signature:** `public static CharMatrix diagonal(final char[] leftUp2RightDownDiagonal, final char[] rightUp2LeftDownDiagonal) throws IllegalArgumentException`
- **Summary:** Creates a square matrix from the specified main diagonal and anti-diagonal elements.
- **Contract:**
  - If both arrays are provided, they must have the same length.
  - The resulting matrix has dimensions n×n where n is the length of the non-null/non-empty array (or the maximum length if both are provided).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`char[]`) — the array of main diagonal elements (can be null or empty)
  - `rightUp2LeftDownDiagonal` (`char[]`) — the array of anti-diagonal elements (can be null or empty)
- **Returns:** a square matrix with the specified diagonals, or an empty matrix if both inputs are null or empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — if both arrays are non-empty and have different lengths
##### unbox(...) -> CharMatrix
- **Signature:** `public static CharMatrix unbox(final Matrix<Character> x)`
- **Summary:** Converts a boxed Character Matrix to a primitive CharMatrix.
- **Contract:**
  - This conversion improves memory efficiency and performance when working with large matrices.
- **Parameters:**
  - `x` (`Matrix<Character>`) — the boxed Character Matrix to convert; must not be null
- **Returns:** a new CharMatrix with primitive char values
- **See also:** #boxed()

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public CharMatrix(final char[][] a)`
- **Summary:** Constructs a new CharMatrix with the specified two-dimensional char array.
- **Contract:**
  - If the input array is null, an empty matrix (0x0) is created.
- **Parameters:**
  - `a` (`char[][]`) — the two-dimensional char array to initialize the matrix with, or null for an empty matrix
##### componentType(...) -> Class
- **Signature:** `@SuppressWarnings("rawtypes") @Override public Class componentType()`
- **Summary:** Returns the component type of the matrix elements, which is always {@code char.class} .
- **Parameters:**
  - (none)
- **Returns:** {@code char.class}
##### get(...) -> char
- **Signature:** `public char get(final int i, final int j)`
- **Summary:** Returns the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** the element at position (rowIndex, columnIndex)
- **Signature:** `public char get(final Point point)`
- **Summary:** Returns the element at the specified point.
- **Parameters:**
  - `point` (`Point`) — the point containing row and column indices (must not be null)
- **Returns:** the char element at the specified point
- **See also:** #get(int, int)
##### set(...) -> void
- **Signature:** `public void set(final int i, final int j, final char val)`
- **Summary:** Sets the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
  - `val` (`char`) — the value to set
- **Signature:** `public void set(final Point point, final char val)`
- **Summary:** Sets the element at the specified point to the given value.
- **Parameters:**
  - `point` (`Point`) — the point containing row and column indices (must not be null)
  - `val` (`char`) — the new char value to set at the specified point
- **See also:** #set(int, int, char)
##### upOf(...) -> OptionalChar
- **Signature:** `public OptionalChar upOf(final int i, final int j)`
- **Summary:** Returns the element above the specified position, if it exists.
- **Contract:**
  - Returns the element above the specified position, if it exists.
  - This method provides safe access to the element directly above the given position without throwing an exception when at the top edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalChar containing the element at position (rowIndex - 1, columnIndex), or empty if rowIndex == 0
##### downOf(...) -> OptionalChar
- **Signature:** `public OptionalChar downOf(final int i, final int j)`
- **Summary:** Returns the element below the specified position, if it exists.
- **Contract:**
  - Returns the element below the specified position, if it exists.
  - This method provides safe access to the element directly below the given position without throwing an exception when at the bottom edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalChar containing the element at position (rowIndex + 1, columnIndex), or empty if rowIndex == rowCount - 1
##### leftOf(...) -> OptionalChar
- **Signature:** `public OptionalChar leftOf(final int i, final int j)`
- **Summary:** Returns the element to the left of the specified position, if it exists.
- **Contract:**
  - Returns the element to the left of the specified position, if it exists.
  - This method provides safe access to the element directly to the left of the given position without throwing an exception when at the leftmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalChar containing the element at position (rowIndex, columnIndex - 1), or empty if columnIndex == 0
##### rightOf(...) -> OptionalChar
- **Signature:** `public OptionalChar rightOf(final int i, final int j)`
- **Summary:** Returns the element to the right of the specified position, if it exists.
- **Contract:**
  - Returns the element to the right of the specified position, if it exists.
  - This method provides safe access to the element directly to the right of the given position without throwing an exception when at the rightmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalChar containing the element at position (rowIndex, columnIndex + 1), or empty if columnIndex == columnCount - 1
##### row(...) -> char\[\]
- **Signature:** `public char[] row(final int rowIndex) throws IllegalArgumentException`
- **Summary:** Returns the specified row as a char array.
- **Contract:**
  - If you need an independent copy, use {@code Arrays.copyOf(matrix.row(i), matrix.columnCount())} .
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to retrieve (0-based)
- **Returns:** the specified row array (direct reference to internal storage)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex &lt; 0 or rowIndex &gt; = rows
##### column(...) -> char\[\]
- **Signature:** `public char[] column(final int columnIndex) throws IllegalArgumentException`
- **Summary:** Returns a copy of the specified column as a new char array.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to retrieve (0-based)
- **Returns:** a new array containing the values from the specified column
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex &lt; 0 or columnIndex &gt; = columnCount
##### setRow(...) -> void
- **Signature:** `public void setRow(final int rowIndex, final char[] row) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified row by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of columns in the matrix.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to set (0-based)
  - `row` (`char[]`) — the array of values to copy into the row; must have length equal to the number of columns
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex is out of bounds or row length does not match column count
##### setColumn(...) -> void
- **Signature:** `public void setColumn(final int columnIndex, final char[] column) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified column by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of rows in the matrix.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to set (0-based)
  - `column` (`char[]`) — the array of values to copy into the column; must have length equal to the number of rows
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex is out of bounds or column length does not match row count
##### updateRow(...) -> void
- **Signature:** `public <E extends Exception> void updateRow(final int rowIndex, final Throwables.CharUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the specified row by applying the given operator to each element.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to update (0-based)
  - `operator` (`Throwables.CharUnaryOperator<E>`) — the operator to apply to each element in the row; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### updateColumn(...) -> void
- **Signature:** `public <E extends Exception> void updateColumn(final int columnIndex, final Throwables.CharUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a column in-place by applying the specified operator.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to update (0-based)
  - `operator` (`Throwables.CharUnaryOperator<E>`) — the operator to apply to each element in the column; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### getLU2RD(...) -> char\[\]
- **Signature:** `public char[] getLU2RD() throws IllegalStateException`
- **Summary:** Returns the elements on the main diagonal from left-upper to right-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new char array containing the main diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setLU2RD(...) -> void
- **Signature:** `public void setLU2RD(final char[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the main diagonal from left-upper to right-down (main diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array must have exactly as many elements as the matrix has rows.
- **Parameters:**
  - `diagonal` (`char[]`) — the new values for the main diagonal; must have length equal to rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal to rows
##### updateLU2RD(...) -> void
- **Signature:** `public <E extends Exception> void updateLU2RD(final Throwables.CharUnaryOperator<E> operator) throws E`
- **Summary:** Updates the values on the main diagonal (left-up to right-down) by applying the specified operator.
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - `operator` (`Throwables.CharUnaryOperator<E>`) — the operator to apply to each diagonal element
- **Throws:**
  - `E` — if the operator throws an exception
##### getRU2LD(...) -> char\[\]
- **Signature:** `public char[] getRU2LD() throws IllegalStateException`
- **Summary:** Returns the elements on the anti-diagonal from right-upper to left-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new char array containing the anti-diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setRU2LD(...) -> void
- **Signature:** `public void setRU2LD(final char[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the anti-diagonal from right-upper to left-down (anti-diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array must have a length equal to the number of rows in the matrix.
- **Parameters:**
  - `diagonal` (`char[]`) — the new values for the anti-diagonal; must have length equal to rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length != rows
##### updateRU2LD(...) -> void
- **Signature:** `public <E extends Exception> void updateRU2LD(final Throwables.CharUnaryOperator<E> operator) throws E`
- **Summary:** Updates the elements on the anti-diagonal (right-upper to left-down) using the specified operator.
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - `operator` (`Throwables.CharUnaryOperator<E>`) — the operator to apply to each anti-diagonal element
- **Throws:**
  - `E` — if the operator throws an exception
##### updateAll(...) -> void
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.CharUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the matrix using the specified operator in-place.
- **Parameters:**
  - `operator` (`Throwables.CharUnaryOperator<E>`) — the operator to apply to each element
- **Throws:**
  - `E` — if the operator throws an exception
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.IntBiFunction<Character, E> operator) throws E`
- **Summary:** Updates all elements in the matrix based on their position using a position-aware operator.
- **Contract:**
  - This is useful when the new value depends on the element's location in the matrix.
- **Parameters:**
  - `operator` (`Throwables.IntBiFunction<Character, E>`) — the operator that takes (rowIndex, columnIndex) and returns the new char value
- **Throws:**
  - `E` — if the operator throws an exception
##### replaceIf(...) -> void
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.CharPredicate<E> predicate, final char newValue) throws E`
- **Summary:** Replaces all elements that match the predicate with the specified value.
- **Parameters:**
  - `predicate` (`Throwables.CharPredicate<E>`) — the predicate to test each element
  - `newValue` (`char`) — the value to replace matching elements with
- **Throws:**
  - `E` — if the predicate throws an exception
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.IntBiPredicate<E> predicate, final char newValue) throws E`
- **Summary:** Replaces all elements at positions that match the position-based predicate with the specified value.
- **Contract:**
  - <p> The predicate receives the row and column indices for each position and determines whether the element at that position should be replaced.
- **Parameters:**
  - `predicate` (`Throwables.IntBiPredicate<E>`) — the predicate that takes (rowIndex, columnIndex) and returns true for positions to replace
  - `newValue` (`char`) — the value to replace at matching positions
- **Throws:**
  - `E` — if the predicate throws an exception
##### map(...) -> CharMatrix
- **Signature:** `public <E extends Exception> CharMatrix map(final Throwables.CharUnaryOperator<E> mapper) throws E`
- **Summary:** Creates a new CharMatrix by applying a transformation function to each element.
- **Parameters:**
  - `mapper` (`Throwables.CharUnaryOperator<E>`) — the function to apply to each element; receives the current element value and returns the transformed value
- **Returns:** a new CharMatrix with transformed values
- **Throws:**
  - `E` — if the function throws an exception
- **See also:** #updateAll(Throwables.CharUnaryOperator)
##### mapToObj(...) -> Matrix<T>
- **Signature:** `public <T, E extends Exception> Matrix<T> mapToObj(final Throwables.CharFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Creates a new object Matrix by applying the specified function to each char element.
- **Parameters:**
  - `mapper` (`Throwables.CharFunction<? extends T, E>`) — the mapping function that converts each char to an object of type T
  - `targetElementType` (`Class<T>`) — the class object representing the target element type (required for array creation)
- **Returns:** a new Matrix &lt; T &gt; with the mapped object values
- **Throws:**
  - `E` — if the function throws an exception
##### fill(...) -> void
- **Signature:** `public void fill(final char val)`
- **Summary:** Fills all elements in the matrix with the specified value.
- **Parameters:**
  - `val` (`char`) — the value to fill the matrix with
- **Signature:** `public void fill(final char[][] b)`
- **Summary:** Fills the matrix with values from the specified two-dimensional array in-place, starting from position (0,0).
- **Contract:**
  - If the source array is smaller than the matrix, only the overlapping region is filled.
  - If the source array is larger, only the portion that fits is copied.
- **Parameters:**
  - `b` (`char[][]`) — the source array to copy values from (maybe smaller or larger than the matrix)
- **Signature:** `public void fill(final int fromRowIndex, final int fromColumnIndex, final char[][] b) throws IllegalArgumentException`
- **Summary:** Fills a portion of the matrix with values from the specified two-dimensional array in-place, starting from a specified position.
- **Contract:**
  - If the source array extends beyond the matrix bounds from the starting position, only the portion that fits is copied.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index in this matrix (0-based)
  - `fromColumnIndex` (`int`) — the starting column index in this matrix (0-based)
  - `b` (`char[][]`) — the source array to copy values from
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the starting indices are negative or exceed matrix dimensions
##### copy(...) -> CharMatrix
- **Signature:** `@Override public CharMatrix copy()`
- **Summary:** Returns a copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is a copy of this matrix
- **Signature:** `@Override public CharMatrix copy(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a row range from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a new CharMatrix containing the specified rows
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rows, or fromRowIndex &gt; toRowIndex
- **Signature:** `@Override public CharMatrix copy(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a rectangular region from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a new CharMatrix containing the specified region
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rows, fromRowIndex &gt; toRowIndex, fromColumnIndex &lt; 0, toColumnIndex &gt; columnCount, or fromColumnIndex &gt; toColumnIndex
##### extend(...) -> CharMatrix
- **Signature:** `public CharMatrix extend(final int newRowCount, final int newColumnCount)`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with ' '.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
- **Returns:** a new CharMatrix with the specified dimensions
- **Signature:** `public CharMatrix extend(final int newRowCount, final int newColumnCount, final char defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated from the top-left corner.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with the specified default value.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
  - `defaultValueForNewCell` (`char`) — the char value to fill new cells with during extension
- **Returns:** a new CharMatrix with the specified dimensions
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code newRowCount} or {@code newColumnCount} is negative, or if the resulting matrix would be too large (dimensions exceeding Integer.MAX_VALUE elements)
- **Signature:** `public CharMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight)`
- **Summary:** Creates a new matrix by extending this matrix in all four directions.
- **Parameters:**
  - `toUp` (`int`) — number of rowCount to add above; must be non-negative
  - `toDown` (`int`) — number of rowCount to add below; must be non-negative
  - `toLeft` (`int`) — number of columnCount to add to the left; must be non-negative
  - `toRight` (`int`) — number of columnCount to add to the right; must be non-negative
- **Returns:** a new extended CharMatrix with dimensions ((toUp+rowCount+toDown) x (toLeft+columnCount+toRight))
- **Signature:** `public CharMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight, final char defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending this matrix in all four directions with padding.
- **Parameters:**
  - `toUp` (`int`) — number of rowCount to add above; must be non-negative
  - `toDown` (`int`) — number of rowCount to add below; must be non-negative
  - `toLeft` (`int`) — number of columnCount to add to the left; must be non-negative
  - `toRight` (`int`) — number of columnCount to add to the right; must be non-negative
  - `defaultValueForNewCell` (`char`) — the char value to fill all new cells with
- **Returns:** a new extended CharMatrix with dimensions ((toUp+rowCount+toDown) x (toLeft+columnCount+toRight))
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any padding parameter is negative, or if the resulting dimensions would exceed Integer.MAX_VALUE
##### reverseH(...) -> void
- **Signature:** `public void reverseH()`
- **Summary:** Reverses the order of elements in each row horizontally (in-place).
- **Parameters:**
  - (none)
- **See also:** #flipH(),for a non-mutating version
##### reverseV(...) -> void
- **Signature:** `public void reverseV()`
- **Summary:** Reverses the order of rows in the matrix (vertical flip in-place).
- **Parameters:**
  - (none)
- **See also:** #flipV(),for a non-mutating version
##### flipH(...) -> CharMatrix
- **Signature:** `public CharMatrix flipH()`
- **Summary:** Creates a new matrix that is horizontally flipped (each row reversed).
- **Parameters:**
  - (none)
- **Returns:** a new CharMatrix with each row reversed
- **See also:** #reverseH(),for an in-place version
##### flipV(...) -> CharMatrix
- **Signature:** `public CharMatrix flipV()`
- **Summary:** Creates a new matrix that is vertically flipped (rows reversed).
- **Parameters:**
  - (none)
- **Returns:** a new CharMatrix with rows in reversed order
- **See also:** #reverseV(),for an in-place version
##### rotate90(...) -> CharMatrix
- **Signature:** `@Override public CharMatrix rotate90()`
- **Summary:** Returns a new matrix rotated 90 degrees clockwise.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 90 degrees clockwise
##### rotate180(...) -> CharMatrix
- **Signature:** `@Override public CharMatrix rotate180()`
- **Summary:** Returns a new matrix rotated 180 degrees.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 180 degrees
##### rotate270(...) -> CharMatrix
- **Signature:** `@Override public CharMatrix rotate270()`
- **Summary:** Returns a new matrix rotated 270 degrees clockwise (or 90 degrees counter-clockwise).
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 270 degrees clockwise
##### transpose(...) -> CharMatrix
- **Signature:** `@Override public CharMatrix transpose()`
- **Summary:** Creates the transpose of this matrix by swapping rows and columns.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is the transpose of this matrix with dimensions columnCount × rows
##### reshape(...) -> CharMatrix
- **Signature:** `@SuppressFBWarnings("ICAST_INTEGER_MULTIPLY_CAST_TO_LONG") @Override public CharMatrix reshape(final int newRowCount, final int newColumnCount)`
- **Summary:** Reshapes the matrix to the specified dimensions.
- **Contract:**
  - If the new shape requires more elements than available in the source matrix, the remaining positions are filled with default char values (' ').
  - If the new shape requires fewer elements, the excess elements are discarded.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the reshaped matrix (must be &gt; = 0)
  - `newColumnCount` (`int`) — the number of columns in the reshaped matrix (must be &gt; = 0)
- **Returns:** a new CharMatrix with the specified dimensions
##### repelem(...) -> CharMatrix
- **Signature:** `@Override public CharMatrix repelem(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats each element in both row and column directions.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat each row
  - `colRepeats` (`int`) — number of times to repeat each column
- **Returns:** a new CharMatrix with repeated elements
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
- **See also:** IntMatrix#repelem(int, int)
##### repmat(...) -> CharMatrix
- **Signature:** `@Override public CharMatrix repmat(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats the entire matrix in both row and column directions.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat the matrix vertically
  - `colRepeats` (`int`) — number of times to repeat the matrix horizontally
- **Returns:** a new CharMatrix with the repeated pattern
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
- **See also:** IntMatrix#repmat(int, int)
##### flatten(...) -> CharList
- **Signature:** `@Override public CharList flatten()`
- **Summary:** Returns a CharList containing all matrix elements in row-major order.
- **Parameters:**
  - (none)
- **Returns:** a new CharList containing all elements in row-major order
##### flatOp(...) -> void
- **Signature:** `@Override public <E extends Exception> void flatOp(final Throwables.Consumer<? super char[], E> op) throws E`
- **Summary:** Applies an operation to each row array of the matrix.
- **Parameters:**
  - `op` (`Throwables.Consumer<? super char[], E>`) — the operation to perform on each row array
- **Throws:**
  - `E` — if the operation throws an exception
- **See also:** Arrays#flatOp(char\[\]\[\], Throwables.Consumer)
##### vstack(...) -> CharMatrix
- **Signature:** `public CharMatrix vstack(final CharMatrix other) throws IllegalArgumentException`
- **Summary:** Vertically stacks this matrix on top of another matrix.
- **Contract:**
  - Both matrices must have the same number of columns.
- **Parameters:**
  - `other` (`CharMatrix`) — the matrix to stack below this matrix
- **Returns:** a new CharMatrix with other appended below this matrix
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different column counts
- **See also:** IntMatrix#vstack(IntMatrix)
##### hstack(...) -> CharMatrix
- **Signature:** `public CharMatrix hstack(final CharMatrix other) throws IllegalArgumentException`
- **Summary:** Horizontally stacks this matrix to the left of another matrix.
- **Contract:**
  - Both matrices must have the same number of rows.
- **Parameters:**
  - `other` (`CharMatrix`) — the matrix to stack to the right of this matrix
- **Returns:** a new CharMatrix with other appended to the right of this matrix
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different row counts
- **See also:** IntMatrix#hstack(IntMatrix)
##### add(...) -> CharMatrix
- **Signature:** `public CharMatrix add(final CharMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise addition with another matrix.
- **Contract:**
  - Both matrices must have the same dimensions.
- **Parameters:**
  - `other` (`CharMatrix`) — the matrix to add to this matrix
- **Returns:** a new CharMatrix containing the element-wise sum
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
##### subtract(...) -> CharMatrix
- **Signature:** `public CharMatrix subtract(final CharMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise subtraction of another matrix from this matrix.
- **Contract:**
  - Both matrices must have the same dimensions.
- **Parameters:**
  - `other` (`CharMatrix`) — the matrix to subtract from this matrix
- **Returns:** a new CharMatrix containing the element-wise difference
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
##### multiply(...) -> CharMatrix
- **Signature:** `public CharMatrix multiply(final CharMatrix other) throws IllegalArgumentException`
- **Summary:** Performs matrix multiplication with another matrix.
- **Contract:**
  - The number of columnCount in this matrix must equal the number of rowCount in the other matrix.
- **Parameters:**
  - `other` (`CharMatrix`) — the matrix to multiply with this matrix
- **Returns:** a new CharMatrix containing the matrix product
- **Throws:**
  - `java.lang.IllegalArgumentException` — if this.columnCount != other.rowCount
##### boxed(...) -> Matrix<Character>
- **Signature:** `public Matrix<Character> boxed()`
- **Summary:** Converts this CharMatrix to a Matrix of Character objects.
- **Contract:**
  - This is useful when you need to work with object-based operations or APIs that require Character objects instead of primitives.
- **Parameters:**
  - (none)
- **Returns:** a new Matrix containing Character objects with the same values and dimensions
##### toIntMatrix(...) -> IntMatrix
- **Signature:** `public IntMatrix toIntMatrix()`
- **Summary:** Converts this CharMatrix to an IntMatrix.
- **Parameters:**
  - (none)
- **Returns:** a new IntMatrix with the same dimensions containing the int values of the characters
##### toLongMatrix(...) -> LongMatrix
- **Signature:** `public LongMatrix toLongMatrix()`
- **Summary:** Converts this CharMatrix to a LongMatrix.
- **Parameters:**
  - (none)
- **Returns:** a new LongMatrix with the same dimensions containing the long values of the characters
##### toFloatMatrix(...) -> FloatMatrix
- **Signature:** `public FloatMatrix toFloatMatrix()`
- **Summary:** Converts this CharMatrix to a FloatMatrix.
- **Parameters:**
  - (none)
- **Returns:** a new FloatMatrix with the same dimensions containing the float values of the characters
##### toDoubleMatrix(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix toDoubleMatrix()`
- **Summary:** Converts this CharMatrix to a DoubleMatrix.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleMatrix with the same dimensions containing the double values of the characters
##### zipWith(...) -> CharMatrix
- **Signature:** `public <E extends Exception> CharMatrix zipWith(final CharMatrix matrixB, final Throwables.CharBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Applies a binary operation element-wise to this matrix and another matrix.
- **Contract:**
  - Both matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`CharMatrix`) — the second matrix to zip with this matrix
  - `zipFunction` (`Throwables.CharBinaryOperator<E>`) — the binary operation to apply to corresponding elements
- **Returns:** a new CharMatrix containing the results of the zip operation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
  - `E` — if the zip function throws an exception
- **Signature:** `public <E extends Exception> CharMatrix zipWith(final CharMatrix matrixB, final CharMatrix matrixC, final Throwables.CharTernaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Applies a ternary operation element-wise to this matrix and two other matrices.
- **Contract:**
  - All three matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`CharMatrix`) — the second matrix to zip with
  - `matrixC` (`CharMatrix`) — the third matrix to zip with
  - `zipFunction` (`Throwables.CharTernaryOperator<E>`) — the ternary operation to apply to corresponding elements
- **Returns:** a new CharMatrix containing the results of the zip operation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any of the matrices have different dimensions
  - `E` — if the zip function throws an exception
##### streamLU2RD(...) -> CharStream
- **Signature:** `@Override public CharStream streamLU2RD()`
- **Summary:** Returns a stream of elements on the diagonal from left-up to right-down.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a CharStream containing the diagonal elements from top-left to bottom-right
##### streamRU2LD(...) -> CharStream
- **Signature:** `@Override public CharStream streamRU2LD()`
- **Summary:** Returns a stream of elements on the diagonal from right-up to left-down.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a CharStream containing the diagonal elements from top-right to bottom-left
##### streamH(...) -> CharStream
- **Signature:** `@Override public CharStream streamH()`
- **Summary:** Returns a stream of all elements in the matrix, traversed horizontally (row by row).
- **Parameters:**
  - (none)
- **Returns:** a CharStream containing all matrix elements in row-major order
- **Signature:** `@Override public CharStream streamH(final int rowIndex)`
- **Summary:** Returns a stream of elements from a specific row.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to stream (0-based)
- **Returns:** a CharStream containing all elements from the specified row
- **Signature:** `@Override public CharStream streamH(final int fromRowIndex, final int toRowIndex)`
- **Summary:** Returns a CharStream of elements from a range of rowCount, traversed horizontally.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a CharStream of elements from the specified rows
##### streamV(...) -> CharStream
- **Signature:** `@Override @Beta public CharStream streamV()`
- **Summary:** Returns a stream of all elements in the matrix, traversed vertically (column by column).
- **Parameters:**
  - (none)
- **Returns:** a CharStream containing all matrix elements in column-major order
- **Signature:** `@Override public CharStream streamV(final int columnIndex)`
- **Summary:** Returns a stream of elements from a specific column.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to stream (0-based)
- **Returns:** a CharStream containing all elements from the specified column
- **Signature:** `@Override @Beta public CharStream streamV(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of elements from a range of columns, traversed vertically.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a CharStream containing elements from the specified column range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds or fromColumnIndex &gt; toColumnIndex
##### streamR(...) -> Stream<CharStream>
- **Signature:** `@Override public Stream<CharStream> streamR()`
- **Summary:** Returns a stream of CharStreams, where each CharStream represents a row in the matrix.
- **Parameters:**
  - (none)
- **Returns:** a Stream of CharStreams, one for each row in the matrix
- **Signature:** `@Override public Stream<CharStream> streamR(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of CharStreams for a range of rows.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a Stream of CharStreams for the specified row range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds or fromRowIndex &gt; toRowIndex
##### streamC(...) -> Stream<CharStream>
- **Signature:** `@Override @Beta public Stream<CharStream> streamC()`
- **Summary:** Returns a stream of CharStreams, where each CharStream represents a column in the matrix.
- **Parameters:**
  - (none)
- **Returns:** a Stream of CharStreams, one for each column in the matrix
- **Signature:** `@Override @Beta public Stream<CharStream> streamC(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of CharStreams for a range of columns.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a Stream of CharStreams for the specified column range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds or fromColumnIndex &gt; toColumnIndex
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.CharConsumer<E> action) throws E`
- **Summary:** Applies the specified action to each element in the matrix.
- **Parameters:**
  - `action` (`Throwables.CharConsumer<E>`) — the action to be performed on each element
- **Throws:**
  - `E` — if the action throws an exception
- **Signature:** `public <E extends Exception> void forEach(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.CharConsumer<E> action) throws IndexOutOfBoundsException, E`
- **Summary:** Applies the specified action to each element in a sub-region of the matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
  - `action` (`Throwables.CharConsumer<E>`) — the action to be performed on each element in the sub-region
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is out of bounds or fromIndex &gt; toIndex
  - `E` — if the action throws an exception
##### println(...) -> String
- **Signature:** `@Override public String println()`
- **Summary:** Prints the matrix to standard output in a formatted, human-readable manner.
- **Parameters:**
  - (none)
- **Returns:** the formatted string representation of the matrix
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this matrix.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this matrix
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this matrix to the specified object for equality.
- **Contract:**
  - Returns {@code true} if the given object is also a CharMatrix with the same dimensions and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the objects are equal, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this matrix

### Class CharTuple (com.landawn.abacus.util.CharTuple)
Abstract base class for immutable tuple implementations that hold primitive char values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> CharTuple1
- **Signature:** `public static CharTuple1 of(final char _1)`
- **Summary:** Creates a CharTuple.CharTuple1 containing a single char value.
- **Parameters:**
  - `_1` (`char`) — the char value to store in the tuple
- **Returns:** a new CharTuple.CharTuple1 containing the specified value
- **Signature:** `public static CharTuple2 of(final char _1, final char _2)`
- **Summary:** Creates a CharTuple.CharTuple2 containing two char values.
- **Parameters:**
  - `_1` (`char`) — the first char value
  - `_2` (`char`) — the second char value
- **Returns:** a new CharTuple.CharTuple2 containing the specified values
- **Signature:** `public static CharTuple3 of(final char _1, final char _2, final char _3)`
- **Summary:** Creates a CharTuple.CharTuple3 containing three char values.
- **Parameters:**
  - `_1` (`char`) — the first char value
  - `_2` (`char`) — the second char value
  - `_3` (`char`) — the third char value
- **Returns:** a new CharTuple.CharTuple3 containing the specified values
- **Signature:** `public static CharTuple4 of(final char _1, final char _2, final char _3, final char _4)`
- **Summary:** Creates a CharTuple.CharTuple4 containing four char values.
- **Parameters:**
  - `_1` (`char`) — the first char value
  - `_2` (`char`) — the second char value
  - `_3` (`char`) — the third char value
  - `_4` (`char`) — the fourth char value
- **Returns:** a new CharTuple.CharTuple4 containing the specified values
- **Signature:** `public static CharTuple5 of(final char _1, final char _2, final char _3, final char _4, final char _5)`
- **Summary:** Creates a CharTuple.CharTuple5 containing five char values.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code CharTuple.CharTuple5 tuple = CharTuple.of('A', 'B', 'C', 'D', 'E'); char median = tuple.median(); // 'C' (middle value when sorted) } </pre>
- **Parameters:**
  - `_1` (`char`) — the first char value
  - `_2` (`char`) — the second char value
  - `_3` (`char`) — the third char value
  - `_4` (`char`) — the fourth char value
  - `_5` (`char`) — the fifth char value
- **Returns:** a new CharTuple.CharTuple5 containing the specified values
- **Signature:** `public static CharTuple6 of(final char _1, final char _2, final char _3, final char _4, final char _5, final char _6)`
- **Summary:** Creates a CharTuple.CharTuple6 containing six char values.
- **Parameters:**
  - `_1` (`char`) — the first char value
  - `_2` (`char`) — the second char value
  - `_3` (`char`) — the third char value
  - `_4` (`char`) — the fourth char value
  - `_5` (`char`) — the fifth char value
  - `_6` (`char`) — the sixth char value
- **Returns:** a new CharTuple.CharTuple6 containing the specified values
- **Signature:** `public static CharTuple7 of(final char _1, final char _2, final char _3, final char _4, final char _5, final char _6, final char _7)`
- **Summary:** Creates a CharTuple.CharTuple7 containing seven char values.
- **Parameters:**
  - `_1` (`char`) — the first char value
  - `_2` (`char`) — the second char value
  - `_3` (`char`) — the third char value
  - `_4` (`char`) — the fourth char value
  - `_5` (`char`) — the fifth char value
  - `_6` (`char`) — the sixth char value
  - `_7` (`char`) — the seventh char value
- **Returns:** a new CharTuple.CharTuple7 containing the specified values
- **Signature:** `@Deprecated public static CharTuple8 of(final char _1, final char _2, final char _3, final char _4, final char _5, final char _6, final char _7, final char _8)`
- **Summary:** Creates a CharTuple.CharTuple8 containing eight char values.
- **Parameters:**
  - `_1` (`char`) — the first char value
  - `_2` (`char`) — the second char value
  - `_3` (`char`) — the third char value
  - `_4` (`char`) — the fourth char value
  - `_5` (`char`) — the fifth char value
  - `_6` (`char`) — the sixth char value
  - `_7` (`char`) — the seventh char value
  - `_8` (`char`) — the eighth char value
- **Returns:** a new CharTuple.CharTuple8 containing the specified values
- **Signature:** `@Deprecated public static CharTuple9 of(final char _1, final char _2, final char _3, final char _4, final char _5, final char _6, final char _7, final char _8, final char _9)`
- **Summary:** Creates a CharTuple.CharTuple9 containing nine char values.
- **Parameters:**
  - `_1` (`char`) — the first char value
  - `_2` (`char`) — the second char value
  - `_3` (`char`) — the third char value
  - `_4` (`char`) — the fourth char value
  - `_5` (`char`) — the fifth char value
  - `_6` (`char`) — the sixth char value
  - `_7` (`char`) — the seventh char value
  - `_8` (`char`) — the eighth char value
  - `_9` (`char`) — the ninth char value
- **Returns:** a new CharTuple.CharTuple9 containing the specified values
##### create(...) -> TP
- **Signature:** `@SuppressWarnings("deprecation") public static <TP extends CharTuple<TP>> TP create(final char[] values)`
- **Summary:** Creates a CharTuple from an array of char values.
- **Parameters:**
  - `values` (`char[]`) — the array of char values (must have length 0-9), may be {@code null}
- **Returns:** a CharTuple of appropriate size containing the array values, or an empty CharTuple if the array is null or empty

#### Public Instance Methods
##### min(...) -> char
- **Signature:** `public char min()`
- **Summary:** Returns the minimum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the minimum char value in this tuple
##### max(...) -> char
- **Signature:** `public char max()`
- **Summary:** Returns the maximum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the maximum char value in this tuple
##### median(...) -> char
- **Signature:** `public char median()`
- **Summary:** Returns the median char value in this tuple.
- **Contract:**
  - <p> The median is the middle value when all elements are sorted.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Odd number of elements CharTuple.CharTuple3 tuple3 = CharTuple.of('Z', 'A', 'M'); char median = tuple3.median(); // 'M' (middle value when sorted: A, M, Z) // Even number of elements CharTuple.CharTuple4 tuple4 = CharTuple.of('A', 'B', 'C', 'D'); char median2 = tuple4.median(); // 'B' (lower middle value) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median char value in this tuple
##### sum(...) -> int
- **Signature:** `public int sum()`
- **Summary:** Returns the sum of all char values in this tuple as an integer.
- **Contract:**
  - The result is returned as an int to prevent overflow issues that could occur if the sum exceeds the char range (0 to 65535).
- **Parameters:**
  - (none)
- **Returns:** the sum of all char values in this tuple as an integer
##### average(...) -> double
- **Signature:** `public double average()`
- **Summary:** Returns the average of all char values in this tuple as a double.
- **Parameters:**
  - (none)
- **Returns:** the average of all char values in this tuple as a double
##### reverse(...) -> TP
- **Signature:** `public abstract TP reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Contract:**
  - For example, a tuple ('A', 'B', 'C') becomes ('C', 'B', 'A') when reversed.
- **Parameters:**
  - (none)
- **Returns:** a new tuple with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `public abstract boolean contains(char valueToFind)`
- **Summary:** Checks if this tuple contains the specified char value.
- **Contract:**
  - Checks if this tuple contains the specified char value.
  - <p> This method performs a linear search through all elements in the tuple to determine if any element matches the specified value.
  - Returns {@code true} if at least one element equals the search value, {@code false} otherwise.
- **Parameters:**
  - `valueToFind` (`char`) — the char value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### toArray(...) -> char\[\]
- **Signature:** `public char[] toArray()`
- **Summary:** Returns a new array containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new char array containing all tuple elements
##### toList(...) -> CharList
- **Signature:** `public CharList toList()`
- **Summary:** Returns a new CharList containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new CharList containing all tuple elements
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.CharConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.CharConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `E` — if the consumer throws an exception during execution
##### stream(...) -> CharStream
- **Signature:** `public CharStream stream()`
- **Summary:** Returns a CharStream of all elements in this tuple.
- **Parameters:**
  - (none)
- **Returns:** a CharStream containing all tuple elements
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this tuple
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Contract:**
  - <p> Two tuples are considered equal if and only if: </p> <ul> <li> They are of the exact same class (e.g., both CharTuple.CharTuple2) </li> <li> They contain the same elements in the same order </li> </ul> <p> This method adheres to the general contract of {@link Object#equals(Object)} .
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is equal to this tuple, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this tuple

### Class CharTuple1 (com.landawn.abacus.util.CharTuple.CharTuple1)
A CharTuple containing exactly one char element.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 1.
- **Parameters:**
  - (none)
- **Returns:** 1
##### min(...) -> char
- **Signature:** `@Override public char min()`
- **Summary:** Returns the minimum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single char value in this tuple
##### max(...) -> char
- **Signature:** `@Override public char max()`
- **Summary:** Returns the maximum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single char value in this tuple
##### median(...) -> char
- **Signature:** `@Override public char median()`
- **Summary:** Returns the median char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single char value in this tuple
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the numeric value of the single char in this tuple
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the numeric value of the single char in this tuple as a double
##### reverse(...) -> CharTuple1
- **Signature:** `@Override public CharTuple1 reverse()`
- **Summary:** Returns a new CharTuple.CharTuple1 with the same element.
- **Parameters:**
  - (none)
- **Returns:** a new CharTuple.CharTuple1 with the same element
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final char valueToFind)`
- **Summary:** Checks if this tuple contains the specified char value.
- **Contract:**
  - Checks if this tuple contains the specified char value.
- **Parameters:**
  - `valueToFind` (`char`) — the char value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** the numeric value of the char element
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a CharTuple.CharTuple1 with the same element
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element)"

### Class CharTuple2 (com.landawn.abacus.util.CharTuple.CharTuple2)
A CharTuple containing exactly two char elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 2.
- **Parameters:**
  - (none)
- **Returns:** 2
##### min(...) -> char
- **Signature:** `@Override public char min()`
- **Summary:** Returns the minimum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smaller of the two char values
##### max(...) -> char
- **Signature:** `@Override public char max()`
- **Summary:** Returns the maximum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the larger of the two char values
##### median(...) -> char
- **Signature:** `@Override public char median()`
- **Summary:** Returns the median char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the median char value in this tuple
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of the numeric values of both chars
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of the numeric values of both chars
##### reverse(...) -> CharTuple2
- **Signature:** `@Override public CharTuple2 reverse()`
- **Summary:** Returns a new CharTuple.CharTuple2 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new CharTuple.CharTuple2 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final char valueToFind)`
- **Summary:** Checks if this tuple contains the specified char value.
- **Contract:**
  - Checks if this tuple contains the specified char value.
- **Parameters:**
  - `valueToFind` (`char`) — the char value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.CharConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.CharConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.CharBiConsumer<E> action) throws E`
- **Summary:** Applies the given action to both elements of this tuple.
- **Parameters:**
  - `action` (`Throwables.CharBiConsumer<E>`) — the action to be performed on both elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `public <U, E extends Exception> U map(final Throwables.CharBiFunction<U, E> mapper) throws E`
- **Summary:** Applies the given function to both elements of this tuple and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.CharBiFunction<U, E>`) — the mapping function to apply to both elements
- **Returns:** the result of applying the mapping function
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<CharTuple2>
- **Signature:** `public <E extends Exception> Optional<CharTuple2> filter(final Throwables.CharBiPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if it matches the given predicate, otherwise returns an empty Optional.
- **Contract:**
  - Returns an Optional containing this tuple if it matches the given predicate, otherwise returns an empty Optional.
- **Parameters:**
  - `predicate` (`Throwables.CharBiPredicate<E>`) — the predicate to test both elements
- **Returns:** an Optional containing this tuple if the predicate returns true, empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from both elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a CharTuple.CharTuple2 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2)"

### Class CharTuple3 (com.landawn.abacus.util.CharTuple.CharTuple3)
A CharTuple containing exactly three char elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 3.
- **Parameters:**
  - (none)
- **Returns:** 3
##### min(...) -> char
- **Signature:** `@Override public char min()`
- **Summary:** Returns the minimum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the three char values
##### max(...) -> char
- **Signature:** `@Override public char max()`
- **Summary:** Returns the maximum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the three char values
##### median(...) -> char
- **Signature:** `@Override public char median()`
- **Summary:** Returns the median char value in this tuple.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code CharTuple.CharTuple3 tuple = CharTuple.of('Z', 'A', 'M'); char median = tuple.median(); // 'M' (middle value when sorted) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the middle char value when sorted
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of the numeric values of all three chars
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of the numeric values of all three chars
##### reverse(...) -> CharTuple3
- **Signature:** `@Override public CharTuple3 reverse()`
- **Summary:** Returns a new CharTuple.CharTuple3 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new CharTuple.CharTuple3 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final char valueToFind)`
- **Summary:** Checks if this tuple contains the specified char value.
- **Contract:**
  - Checks if this tuple contains the specified char value.
- **Parameters:**
  - `valueToFind` (`char`) — the char value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.CharConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.CharConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.CharTriConsumer<E> action) throws E`
- **Summary:** Applies the given action to all three elements of this tuple.
- **Parameters:**
  - `action` (`Throwables.CharTriConsumer<E>`) — the action to be performed on all three elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `public <U, E extends Exception> U map(final Throwables.CharTriFunction<U, E> mapper) throws E`
- **Summary:** Applies the given function to all three elements of this tuple and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.CharTriFunction<U, E>`) — the mapping function to apply to all three elements
- **Returns:** the result of applying the mapping function
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<CharTuple3>
- **Signature:** `public <E extends Exception> Optional<CharTuple3> filter(final Throwables.CharTriPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if it matches the given predicate, otherwise returns an empty Optional.
- **Contract:**
  - Returns an Optional containing this tuple if it matches the given predicate, otherwise returns an empty Optional.
- **Parameters:**
  - `predicate` (`Throwables.CharTriPredicate<E>`) — the predicate to test all three elements
- **Returns:** an Optional containing this tuple if the predicate returns true, empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value calculated from all three elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is a CharTuple.CharTuple3 with the same elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(element1, element2, element3)"

### Class CharTuple4 (com.landawn.abacus.util.CharTuple.CharTuple4)
A CharTuple containing exactly four char elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 4.
- **Parameters:**
  - (none)
- **Returns:** 4
##### min(...) -> char
- **Signature:** `@Override public char min()`
- **Summary:** Returns the minimum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the four char values
##### max(...) -> char
- **Signature:** `@Override public char max()`
- **Summary:** Returns the maximum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the four char values
##### median(...) -> char
- **Signature:** `@Override public char median()`
- **Summary:** Returns the median char value in this tuple.
- **Contract:**
  - For a tuple of four elements, returns the lower of the two middle values when sorted.
- **Parameters:**
  - (none)
- **Returns:** the median char value in this tuple
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of the numeric values of all four chars
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of the numeric values of all four chars
##### reverse(...) -> CharTuple4
- **Signature:** `@Override public CharTuple4 reverse()`
- **Summary:** Returns a new CharTuple.CharTuple4 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new CharTuple.CharTuple4 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final char valueToFind)`
- **Summary:** Checks if this tuple contains the specified char value.
- **Contract:**
  - Checks if this tuple contains the specified char value.
- **Parameters:**
  - `valueToFind` (`char`) — the char value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.CharConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.CharConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception

### Class CharTuple5 (com.landawn.abacus.util.CharTuple.CharTuple5)
A CharTuple containing exactly five char elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 5.
- **Parameters:**
  - (none)
- **Returns:** 5
##### min(...) -> char
- **Signature:** `@Override public char min()`
- **Summary:** Returns the minimum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the five char values
##### max(...) -> char
- **Signature:** `@Override public char max()`
- **Summary:** Returns the maximum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the five char values
##### median(...) -> char
- **Signature:** `@Override public char median()`
- **Summary:** Returns the median char value in this tuple.
- **Contract:**
  - For a tuple of five elements, returns the exact middle value when sorted.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code CharTuple.CharTuple5 tuple = CharTuple.of('E', 'A', 'C', 'B', 'D'); char median = tuple.median(); // 'C' (middle value when sorted: A, B, C, D, E) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median char value in this tuple
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of the numeric values of all five chars
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of the numeric values of all five chars
##### reverse(...) -> CharTuple5
- **Signature:** `@Override public CharTuple5 reverse()`
- **Summary:** Returns a new CharTuple.CharTuple5 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new CharTuple.CharTuple5 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final char valueToFind)`
- **Summary:** Checks if this tuple contains the specified char value.
- **Contract:**
  - Checks if this tuple contains the specified char value.
- **Parameters:**
  - `valueToFind` (`char`) — the char value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.CharConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.CharConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception

### Class CharTuple6 (com.landawn.abacus.util.CharTuple.CharTuple6)
A CharTuple containing exactly six char elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 6.
- **Parameters:**
  - (none)
- **Returns:** 6
##### min(...) -> char
- **Signature:** `@Override public char min()`
- **Summary:** Returns the minimum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the six char values
##### max(...) -> char
- **Signature:** `@Override public char max()`
- **Summary:** Returns the maximum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the six char values
##### median(...) -> char
- **Signature:** `@Override public char median()`
- **Summary:** Returns the median char value in this tuple.
- **Contract:**
  - For a tuple of six elements, returns the lower of the two middle values when sorted.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code CharTuple.CharTuple6 tuple = CharTuple.of('A', 'B', 'C', 'D', 'E', 'F'); char median = tuple.median(); // 'C' (lower middle value when sorted) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median char value in this tuple
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of the numeric values of all six chars
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of the numeric values of all six chars
##### reverse(...) -> CharTuple6
- **Signature:** `@Override public CharTuple6 reverse()`
- **Summary:** Returns a new CharTuple.CharTuple6 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new CharTuple.CharTuple6 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final char valueToFind)`
- **Summary:** Checks if this tuple contains the specified char value.
- **Contract:**
  - Checks if this tuple contains the specified char value.
- **Parameters:**
  - `valueToFind` (`char`) — the char value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.CharConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.CharConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception

### Class CharTuple7 (com.landawn.abacus.util.CharTuple.CharTuple7)
A CharTuple containing exactly seven char elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 7.
- **Parameters:**
  - (none)
- **Returns:** 7
##### min(...) -> char
- **Signature:** `@Override public char min()`
- **Summary:** Returns the minimum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the seven char values
##### max(...) -> char
- **Signature:** `@Override public char max()`
- **Summary:** Returns the maximum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the seven char values
##### median(...) -> char
- **Signature:** `@Override public char median()`
- **Summary:** Returns the median char value in this tuple.
- **Contract:**
  - For a tuple of seven elements, returns the exact middle value when sorted.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code CharTuple.CharTuple7 tuple = CharTuple.of('G', 'A', 'C', 'E', 'B', 'D', 'F'); char median = tuple.median(); // 'D' (middle value when sorted: A, B, C, D, E, F, G) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median char value in this tuple
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of the numeric values of all seven chars
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of the numeric values of all seven chars
##### reverse(...) -> CharTuple7
- **Signature:** `@Override public CharTuple7 reverse()`
- **Summary:** Returns a new CharTuple.CharTuple7 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new CharTuple.CharTuple7 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final char valueToFind)`
- **Summary:** Checks if this tuple contains the specified char value.
- **Contract:**
  - Checks if this tuple contains the specified char value.
- **Parameters:**
  - `valueToFind` (`char`) — the char value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.CharConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.CharConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception

### Class CharTuple8 (com.landawn.abacus.util.CharTuple.CharTuple8)
A CharTuple containing exactly eight char elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 8.
- **Parameters:**
  - (none)
- **Returns:** 8
##### min(...) -> char
- **Signature:** `@Override public char min()`
- **Summary:** Returns the minimum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the eight char values
##### max(...) -> char
- **Signature:** `@Override public char max()`
- **Summary:** Returns the maximum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the eight char values
##### median(...) -> char
- **Signature:** `@Override public char median()`
- **Summary:** Returns the median char value in this tuple.
- **Contract:**
  - For a tuple of eight elements, returns the lower of the two middle values when sorted.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code CharTuple.CharTuple8 tuple = CharTuple.of('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'); char median = tuple.median(); // 'D' (lower middle value when sorted) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median char value in this tuple
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of the numeric values of all eight chars
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of the numeric values of all eight chars
##### reverse(...) -> CharTuple8
- **Signature:** `@Override public CharTuple8 reverse()`
- **Summary:** Returns a new CharTuple.CharTuple8 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new CharTuple.CharTuple8 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final char valueToFind)`
- **Summary:** Checks if this tuple contains the specified char value.
- **Contract:**
  - Checks if this tuple contains the specified char value.
- **Parameters:**
  - `valueToFind` (`char`) — the char value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.CharConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.CharConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception

### Class CharTuple9 (com.landawn.abacus.util.CharTuple.CharTuple9)
A CharTuple containing exactly nine char elements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 9.
- **Parameters:**
  - (none)
- **Returns:** 9
##### min(...) -> char
- **Signature:** `@Override public char min()`
- **Summary:** Returns the minimum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the smallest of the nine char values
##### max(...) -> char
- **Signature:** `@Override public char max()`
- **Summary:** Returns the maximum char value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the largest of the nine char values
##### median(...) -> char
- **Signature:** `@Override public char median()`
- **Summary:** Returns the median char value in this tuple.
- **Contract:**
  - For a tuple of nine elements, returns the exact middle value when sorted.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code CharTuple.CharTuple9 tuple = CharTuple.of('I', 'A', 'C', 'E', 'B', 'D', 'F', 'G', 'H'); char median = tuple.median(); // 'E' (middle value when sorted: A, B, C, D, E, F, G, H, I) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median char value in this tuple
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of the numeric values of all nine chars
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all char values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the average of the numeric values of all nine chars
##### reverse(...) -> CharTuple9
- **Signature:** `@Override public CharTuple9 reverse()`
- **Summary:** Returns a new CharTuple.CharTuple9 with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new CharTuple.CharTuple9 with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final char valueToFind)`
- **Summary:** Checks if this tuple contains the specified char value.
- **Contract:**
  - Checks if this tuple contains the specified char value.
- **Parameters:**
  - `valueToFind` (`char`) — the char value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.CharConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.CharConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception

### Class DoubleMatrix (com.landawn.abacus.util.DoubleMatrix)
A matrix implementation for double primitive values, providing efficient storage and operations for two-dimensional double arrays.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### empty(...) -> DoubleMatrix
- **Signature:** `public static DoubleMatrix empty()`
- **Summary:** Creates an empty matrix with zero rows and zero columns.
- **Parameters:**
  - (none)
- **Returns:** an empty double matrix
##### of(...) -> DoubleMatrix
- **Signature:** `public static DoubleMatrix of(final double[]... a)`
- **Summary:** Creates a DoubleMatrix from a two-dimensional double array.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional double array to create the matrix from, or null/empty for an empty matrix
- **Returns:** a new DoubleMatrix containing the provided data, or an empty DoubleMatrix if input is null or empty
##### from(...) -> DoubleMatrix
- **Signature:** `public static DoubleMatrix from(final int[]... a)`
- **Summary:** Creates a DoubleMatrix from a two-dimensional int array by converting int values to double.
- **Contract:**
  - <p> All rows must have the same length as the first row (rectangular array required).
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional int array to convert to a double matrix, or null/empty for an empty matrix
- **Returns:** a new DoubleMatrix with converted values, or an empty DoubleMatrix if input is null or empty
- **Signature:** `public static DoubleMatrix from(final long[]... a)`
- **Summary:** Creates a DoubleMatrix from a two-dimensional long array by converting long values to double.
- **Contract:**
  - <p> All rows must have the same length as the first row (rectangular array required).
- **Parameters:**
  - `a` (`long[][]`) — the two-dimensional long array to convert to a double matrix, or null/empty for an empty matrix
- **Returns:** a new DoubleMatrix with converted values, or an empty DoubleMatrix if input is null or empty
- **Signature:** `public static DoubleMatrix from(final float[]... a)`
- **Summary:** Creates a DoubleMatrix from a two-dimensional float array by converting float values to double.
- **Contract:**
  - <p> All rows must have the same length as the first row (rectangular array required).
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional float array to convert to a double matrix, or null/empty for an empty matrix
- **Returns:** a new DoubleMatrix with converted values, or an empty DoubleMatrix if input is null or empty
##### random(...) -> DoubleMatrix
- **Signature:** `public static DoubleMatrix random(final int size)`
- **Summary:** Creates a new 1xsize matrix filled with random double values.
- **Parameters:**
  - `size` (`int`) — the number of columns in the new matrix
- **Returns:** a new DoubleMatrix of dimensions 1 x size filled with random values
- **Signature:** `public static DoubleMatrix random(final int rowCount, final int columnCount)`
- **Summary:** Creates a new matrix of the specified dimensions filled with random double values.
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
- **Returns:** a new DoubleMatrix of dimensions rowCount x columnCount filled with random values
##### repeat(...) -> DoubleMatrix
- **Signature:** `public static DoubleMatrix repeat(final int rowCount, final int columnCount, final double element)`
- **Summary:** Creates a new matrix of the specified dimensions where every element is the provided {@code element} .
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
  - `element` (`double`) — the double value to fill the matrix with
- **Returns:** a new DoubleMatrix of dimensions rowCount x columnCount filled with the specified element
##### diagonalLU2RD(...) -> DoubleMatrix
- **Signature:** `public static DoubleMatrix diagonalLU2RD(final double[] leftUp2RightDownDiagonal)`
- **Summary:** Creates a square matrix from the specified main diagonal elements (left-upper to right-down).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`double[]`) — the array of main diagonal elements, or null/empty for an empty matrix
- **Returns:** a square matrix with the specified main diagonal, or an empty matrix if input is null or empty
##### diagonalRU2LD(...) -> DoubleMatrix
- **Signature:** `public static DoubleMatrix diagonalRU2LD(final double[] rightUp2LeftDownDiagonal)`
- **Summary:** Creates a square matrix from the specified anti-diagonal elements (right-upper to left-down).
- **Parameters:**
  - `rightUp2LeftDownDiagonal` (`double[]`) — the array of anti-diagonal elements, or null/empty for an empty matrix
- **Returns:** a square matrix with the specified anti-diagonal, or an empty matrix if input is null or empty
##### diagonal(...) -> DoubleMatrix
- **Signature:** `public static DoubleMatrix diagonal(final double[] leftUp2RightDownDiagonal, final double[] rightUp2LeftDownDiagonal) throws IllegalArgumentException`
- **Summary:** Creates a square matrix from the specified main diagonal and anti-diagonal elements.
- **Contract:**
  - If both arrays are provided, they must have the same length.
  - The resulting matrix has dimensions n×n where n is the length of the non-null/non-empty array (or the maximum length if both are provided).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`double[]`) — the array of main diagonal elements (can be null or empty)
  - `rightUp2LeftDownDiagonal` (`double[]`) — the array of anti-diagonal elements (can be null or empty)
- **Returns:** a square matrix with the specified diagonals, or an empty matrix if both inputs are null or empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — if both arrays are non-empty and have different lengths
##### unbox(...) -> DoubleMatrix
- **Signature:** `public static DoubleMatrix unbox(final Matrix<Double> x)`
- **Summary:** Converts a boxed Double matrix to a primitive DoubleMatrix.
- **Parameters:**
  - `x` (`Matrix<Double>`) — the boxed Double matrix to convert
- **Returns:** a new DoubleMatrix with unboxed values (nulls become 0.0)

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public DoubleMatrix(final double[][] a)`
- **Summary:** Constructs a DoubleMatrix from a two-dimensional double array.
- **Contract:**
  - If the input array is null, an empty matrix (0x0) is created instead.
- **Parameters:**
  - `a` (`double[][]`) — the two-dimensional double array to wrap, or null for an empty matrix
##### componentType(...) -> Class
- **Signature:** `@SuppressWarnings("rawtypes") @Override public Class componentType()`
- **Summary:** Returns the component type of the matrix elements, which is always {@code double.class} .
- **Parameters:**
  - (none)
- **Returns:** {@code double.class}
##### get(...) -> double
- **Signature:** `public double get(final int i, final int j)`
- **Summary:** Returns the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** the element at position (rowIndex, columnIndex)
- **Signature:** `public double get(final Point point)`
- **Summary:** Returns the element at the specified Sheet.Point.
- **Parameters:**
  - `point` (`Point`)
- **Returns:** the double element at the specified Sheet.Point
- **See also:** #get(int, int)
##### set(...) -> void
- **Signature:** `public void set(final int i, final int j, final double val)`
- **Summary:** Sets the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
  - `val` (`double`) — the value to set
- **Signature:** `public void set(final Point point, final double val)`
- **Summary:** Sets the element at the specified Sheet.Point to the given value.
- **Parameters:**
  - `point` (`Point`)
  - `val` (`double`) — the new double value to set at the specified Sheet.Point
- **See also:** #set(int, int, double)
##### upOf(...) -> OptionalDouble
- **Signature:** `public OptionalDouble upOf(final int i, final int j)`
- **Summary:** Returns the element directly above the specified position, if it exists.
- **Contract:**
  - Returns the element directly above the specified position, if it exists.
  - This method provides safe access to the element directly above the given position without throwing an exception when at the top edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalDouble containing the element at position (rowIndex - 1, columnIndex), or empty if rowIndex == 0
##### downOf(...) -> OptionalDouble
- **Signature:** `public OptionalDouble downOf(final int i, final int j)`
- **Summary:** Returns the element directly below the specified position, if it exists.
- **Contract:**
  - Returns the element directly below the specified position, if it exists.
  - This method provides safe access to the element directly below the given position without throwing an exception when at the bottom edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalDouble containing the element at position (rowIndex + 1, columnIndex), or empty if rowIndex == rowCount - 1
##### leftOf(...) -> OptionalDouble
- **Signature:** `public OptionalDouble leftOf(final int i, final int j)`
- **Summary:** Returns the element directly to the left of the specified position, if it exists.
- **Contract:**
  - Returns the element directly to the left of the specified position, if it exists.
  - This method provides safe access to the element directly to the left of the given position without throwing an exception when at the leftmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalDouble containing the element at position (rowIndex, columnIndex - 1), or empty if columnIndex == 0
##### rightOf(...) -> OptionalDouble
- **Signature:** `public OptionalDouble rightOf(final int i, final int j)`
- **Summary:** Returns the element directly to the right of the specified position, if it exists.
- **Contract:**
  - Returns the element directly to the right of the specified position, if it exists.
  - This method provides safe access to the element directly to the right of the given position without throwing an exception when at the rightmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalDouble containing the element at position (rowIndex, columnIndex + 1), or empty if columnIndex == columnCount - 1
##### row(...) -> double\[\]
- **Signature:** `public double[] row(final int rowIndex) throws IllegalArgumentException`
- **Summary:** Returns the specified row as a double array.
- **Contract:**
  - If you need an independent copy, use {@code Arrays.copyOf(matrix.row(i), matrix.columnCount())} .
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to retrieve (0-based)
- **Returns:** the specified row array (direct reference to internal storage)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex &lt; 0 or rowIndex &gt; = rows
##### column(...) -> double\[\]
- **Signature:** `public double[] column(final int columnIndex) throws IllegalArgumentException`
- **Summary:** Returns a copy of the specified column as a new double array.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to retrieve (0-based)
- **Returns:** a new array containing the values from the specified column
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex &lt; 0 or columnIndex &gt; = columnCount
##### setRow(...) -> void
- **Signature:** `public void setRow(final int rowIndex, final double[] row) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified row by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of columns in the matrix.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to set (0-based)
  - `row` (`double[]`) — the array of values to copy into the row; must have length equal to the number of columns
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex is out of bounds or row length does not match column count
##### setColumn(...) -> void
- **Signature:** `public void setColumn(final int columnIndex, final double[] column) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified column by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of rows in the matrix.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to set (0-based)
  - `column` (`double[]`) — the array of values to copy into the column; must have length equal to the number of rows
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex is out of bounds or column length does not match row count
##### updateRow(...) -> void
- **Signature:** `public <E extends Exception> void updateRow(final int rowIndex, final Throwables.DoubleUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the specified row by applying the given operator to each element.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to update (0-based)
  - `operator` (`Throwables.DoubleUnaryOperator<E>`) — the operator to apply to each element in the row; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### updateColumn(...) -> void
- **Signature:** `public <E extends Exception> void updateColumn(final int columnIndex, final Throwables.DoubleUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a column in-place by applying the specified operator.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to update (0-based)
  - `operator` (`Throwables.DoubleUnaryOperator<E>`) — the operator to apply to each element in the column; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### getLU2RD(...) -> double\[\]
- **Signature:** `public double[] getLU2RD() throws IllegalStateException`
- **Summary:** Returns a copy of the elements on the main diagonal from left-upper to right-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new double array containing a copy of the main diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setLU2RD(...) -> void
- **Signature:** `public void setLU2RD(final double[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the main diagonal from left-upper to right-down (main diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array must have exactly as many elements as the matrix has rows.
  - The diagonal array length must exactly match the number of rows.
- **Parameters:**
  - `diagonal` (`double[]`) — the new values for the main diagonal; must have length == rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal to rows
##### updateLU2RD(...) -> void
- **Signature:** `public <E extends Exception> void updateLU2RD(final Throwables.DoubleUnaryOperator<E> operator) throws E`
- **Summary:** Updates the values on the main diagonal (left-up to right-down) by applying the specified operator.
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - `operator` (`Throwables.DoubleUnaryOperator<E>`) — the operator to apply to each diagonal element; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### getRU2LD(...) -> double\[\]
- **Signature:** `public double[] getRU2LD() throws IllegalStateException`
- **Summary:** Returns a copy of the elements on the anti-diagonal from right-upper to left-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new double array containing a copy of the anti-diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setRU2LD(...) -> void
- **Signature:** `public void setRU2LD(final double[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the anti-diagonal from right-upper to left-down (anti-diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array must have exactly as many elements as the matrix has rows.
- **Parameters:**
  - `diagonal` (`double[]`) — the new values for the anti-diagonal; must have length equal to rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal rows
##### updateRU2LD(...) -> void
- **Signature:** `public <E extends Exception> void updateRU2LD(final Throwables.DoubleUnaryOperator<E> operator) throws E`
- **Summary:** Updates the values on the anti-diagonal (right-up to left-down) by applying the specified operator.
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - `operator` (`Throwables.DoubleUnaryOperator<E>`) — the operator to apply to each anti-diagonal element; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### updateAll(...) -> void
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.DoubleUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the matrix in-place by applying the specified operator.
- **Contract:**
  - Elements are processed in row-major order when executed sequentially.
- **Parameters:**
  - `operator` (`Throwables.DoubleUnaryOperator<E>`) — the operator to apply to each element; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.IntBiFunction<Double, E> operator) throws E`
- **Summary:** Updates all elements in the matrix in-place based on their position (row and column indices).
- **Parameters:**
  - `operator` (`Throwables.IntBiFunction<Double, E>`) — the operator that receives row index and column index (0-based) and returns the new value for that position
- **Throws:**
  - `E` — if the operator throws an exception
##### replaceIf(...) -> void
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.DoublePredicate<E> predicate, final double newValue) throws E`
- **Summary:** Conditionally replaces elements in-place based on a predicate.
- **Parameters:**
  - `predicate` (`Throwables.DoublePredicate<E>`) — the condition to test each element; elements for which this returns {@code true} will be replaced
  - `newValue` (`double`) — the value to use for replacing matching elements
- **Throws:**
  - `E` — if the predicate throws an exception
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.IntBiPredicate<E> predicate, final double newValue) throws E`
- **Summary:** Conditionally replaces elements in-place based on their position (row and column indices).
- **Parameters:**
  - `predicate` (`Throwables.IntBiPredicate<E>`) — the condition that tests row index and column index (0-based); elements at positions for which this returns {@code true} will be replaced
  - `newValue` (`double`) — the value to use for replacing matching elements
- **Throws:**
  - `E` — if the predicate throws an exception
##### map(...) -> DoubleMatrix
- **Signature:** `public <E extends Exception> DoubleMatrix map(final Throwables.DoubleUnaryOperator<E> mapper) throws E`
- **Summary:** Creates a new DoubleMatrix by applying a transformation function to each element.
- **Parameters:**
  - `mapper` (`Throwables.DoubleUnaryOperator<E>`) — the function to apply to each element; receives the current element value and returns the transformed value
- **Returns:** a new DoubleMatrix with transformed values
- **Throws:**
  - `E` — if the function throws an exception
- **See also:** #updateAll(Throwables.DoubleUnaryOperator)
##### mapToInt(...) -> IntMatrix
- **Signature:** `public <E extends Exception> IntMatrix mapToInt(final Throwables.DoubleToIntFunction<E> mapper) throws E`
- **Summary:** Creates a new IntMatrix by applying the specified function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.DoubleToIntFunction<E>`) — the mapping function that converts each double element to an int; must not be null
- **Returns:** a new IntMatrix with the mapped values (same dimensions as the original)
- **Throws:**
  - `E` — if the function throws an exception
##### mapToLong(...) -> LongMatrix
- **Signature:** `public <E extends Exception> LongMatrix mapToLong(final Throwables.DoubleToLongFunction<E> mapper) throws E`
- **Summary:** Creates a new LongMatrix by applying the specified function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.DoubleToLongFunction<E>`) — the mapping function that converts each double element to a long; must not be null
- **Returns:** a new LongMatrix with the mapped values (same dimensions as the original)
- **Throws:**
  - `E` — if the function throws an exception
##### mapToObj(...) -> Matrix<T>
- **Signature:** `public <T, E extends Exception> Matrix<T> mapToObj(final Throwables.DoubleFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Creates a new object Matrix by applying the specified function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.DoubleFunction<? extends T, E>`) — the mapping function that converts each double element to type T; must not be null
  - `targetElementType` (`Class<T>`) — the class object representing the target element type (used for array creation); must not be null
- **Returns:** a new Matrix &lt; T &gt; with the mapped values (same dimensions as the original)
- **Throws:**
  - `E` — if the function throws an exception
##### fill(...) -> void
- **Signature:** `public void fill(final double val)`
- **Summary:** Fills the entire matrix with the specified value in-place.
- **Parameters:**
  - `val` (`double`) — the value to fill the matrix with
- **Signature:** `public void fill(final double[][] b)`
- **Summary:** Fills the matrix with values from the specified two-dimensional array in-place, starting from position (0,0).
- **Contract:**
  - If the source array is smaller than the matrix, only the overlapping region is filled.
  - If the source array is larger, only the portion that fits is copied.
- **Parameters:**
  - `b` (`double[][]`) — the source array to copy values from (maybe smaller or larger than the matrix)
- **Signature:** `public void fill(final int fromRowIndex, final int fromColumnIndex, final double[][] b) throws IllegalArgumentException`
- **Summary:** Fills a portion of the matrix with values from the specified two-dimensional array in-place, starting from a specified position.
- **Contract:**
  - If the source array extends beyond the matrix bounds from the starting position, only the portion that fits is copied.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index in this matrix (0-based)
  - `fromColumnIndex` (`int`) — the starting column index in this matrix (0-based)
  - `b` (`double[][]`) — the source array to copy values from
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the starting indices are negative or exceed matrix dimensions
##### copy(...) -> DoubleMatrix
- **Signature:** `@Override public DoubleMatrix copy()`
- **Summary:** Returns a deep copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is a deep copy of this matrix with full independence guarantee
- **Signature:** `@Override public DoubleMatrix copy(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a copy of a row range from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a new DoubleMatrix containing a copy of the specified rows
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds
- **Signature:** `@Override public DoubleMatrix copy(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a copy of a rectangular region from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a new DoubleMatrix containing the specified region with dimensions (toRowIndex - fromRowIndex) × (toColumnIndex - fromColumnIndex)
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is out of bounds, fromRowIndex &gt; toRowIndex, or fromColumnIndex &gt; toColumnIndex
##### extend(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix extend(final int newRowCount, final int newColumnCount)`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with 0.0.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
- **Returns:** a new DoubleMatrix with the specified dimensions
- **Signature:** `public DoubleMatrix extend(final int newRowCount, final int newColumnCount, final double defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated from the top-left corner.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with the specified default value.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
  - `defaultValueForNewCell` (`double`) — the double value to fill new cells with during extension
- **Returns:** a new DoubleMatrix with the specified dimensions
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code newRowCount} or {@code newColumnCount} is negative, or if the resulting matrix would be too large (dimensions exceeding Integer.MAX_VALUE elements)
- **Signature:** `public DoubleMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight)`
- **Summary:** Creates a new matrix by extending this matrix in all four directions.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
- **Returns:** a new extended DoubleMatrix with dimensions ((toUp+rows+toDown) x (toLeft+columnCount+toRight))
- **Signature:** `public DoubleMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight, final double defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending this matrix in all four directions with padding.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
  - `defaultValueForNewCell` (`double`) — the double value to fill all new cells with
- **Returns:** a new extended DoubleMatrix with dimensions ((toUp+rows+toDown) x (toLeft+columnCount+toRight))
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any padding parameter is negative, or if the resulting dimensions would exceed Integer.MAX_VALUE
##### reverseH(...) -> void
- **Signature:** `public void reverseH()`
- **Summary:** Reverses the order of elements in each row (horizontal flip in-place).
- **Parameters:**
  - (none)
- **See also:** #flipH()
##### reverseV(...) -> void
- **Signature:** `public void reverseV()`
- **Summary:** Reverses the order of rows (vertical flip in-place).
- **Parameters:**
  - (none)
- **See also:** #flipV()
##### flipH(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix flipH()`
- **Summary:** Creates a new matrix that is horizontally flipped (each row reversed).
- **Parameters:**
  - (none)
- **Returns:** a new DoubleMatrix with each row reversed
- **See also:** #reverseH()
##### flipV(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix flipV()`
- **Summary:** Creates a new matrix that is vertically flipped (rows reversed).
- **Parameters:**
  - (none)
- **Returns:** a new DoubleMatrix with rows reversed
- **See also:** #reverseV()
##### rotate90(...) -> DoubleMatrix
- **Signature:** `@Override public DoubleMatrix rotate90()`
- **Summary:** Rotates this matrix 90 degrees clockwise.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 90 degrees clockwise
##### rotate180(...) -> DoubleMatrix
- **Signature:** `@Override public DoubleMatrix rotate180()`
- **Summary:** Rotates this matrix 180 degrees.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 180 degrees
##### rotate270(...) -> DoubleMatrix
- **Signature:** `@Override public DoubleMatrix rotate270()`
- **Summary:** Rotates this matrix 270 degrees clockwise (or 90 degrees counter-clockwise).
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 270 degrees clockwise
##### transpose(...) -> DoubleMatrix
- **Signature:** `@Override public DoubleMatrix transpose()`
- **Summary:** Creates the transpose of this matrix by swapping rows and columns.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is the transpose of this matrix with dimensions columnCount × rows
##### reshape(...) -> DoubleMatrix
- **Signature:** `@SuppressFBWarnings("ICAST_INTEGER_MULTIPLY_CAST_TO_LONG") @Override public DoubleMatrix reshape(final int newRowCount, final int newColumnCount)`
- **Summary:** Reshapes the matrix to new dimensions while preserving element order.
- **Contract:**
  - <p> If the new shape has fewer total elements than the original, excess elements are truncated.
  - If the new shape has more total elements, the additional positions are filled with zeros.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the reshaped matrix
  - `newColumnCount` (`int`) — the number of columns in the reshaped matrix
- **Returns:** a new DoubleMatrix with the specified shape containing this matrix's elements
##### repelem(...) -> DoubleMatrix
- **Signature:** `@Override public DoubleMatrix repelem(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats elements of the matrix in both row and column directions.
- **Parameters:**
  - `rowRepeats` (`int`) — the number of times to repeat each element in the row direction
  - `colRepeats` (`int`) — the number of times to repeat each element in the column direction
- **Returns:** a new matrix with repeated elements
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
- **See also:** IntMatrix#repelem(int, int)
##### repmat(...) -> DoubleMatrix
- **Signature:** `@Override public DoubleMatrix repmat(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats the entire matrix in both row and column directions.
- **Parameters:**
  - `rowRepeats` (`int`) — the number of times to repeat the matrix in the row direction
  - `colRepeats` (`int`) — the number of times to repeat the matrix in the column direction
- **Returns:** a new matrix with the tiled pattern
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
- **See also:** IntMatrix#repmat(int, int)
##### flatten(...) -> DoubleList
- **Signature:** `@Override public DoubleList flatten()`
- **Summary:** Returns a DoubleList containing all matrix elements in row-major order (left-to-right, top-to-bottom).
- **Parameters:**
  - (none)
- **Returns:** a DoubleList containing all elements in row-major order
##### flatOp(...) -> void
- **Signature:** `@Override public <E extends Exception> void flatOp(final Throwables.Consumer<? super double[], E> op) throws E`
- **Summary:** Applies an operation to each row array of the underlying two-dimensional array in-place.
- **Parameters:**
  - `op` (`Throwables.Consumer<? super double[], E>`) — the operation to apply to each row array
- **Throws:**
  - `E` — if the operation throws an exception
- **See also:** Arrays#flatOp(double\[\]\[\], Throwables.Consumer)
##### vstack(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix vstack(final DoubleMatrix other) throws IllegalArgumentException`
- **Summary:** Vertically stacks this matrix with another matrix.
- **Contract:**
  - The matrices must have the same number of columns.
- **Parameters:**
  - `other` (`DoubleMatrix`) — the matrix to stack below this matrix
- **Returns:** a new matrix with combined rows
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different number of columns
- **See also:** IntMatrix#vstack(IntMatrix)
##### hstack(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix hstack(final DoubleMatrix other) throws IllegalArgumentException`
- **Summary:** Horizontally stacks this matrix with another matrix.
- **Contract:**
  - The matrices must have the same number of rows.
- **Parameters:**
  - `other` (`DoubleMatrix`) — the matrix to stack to the right of this matrix
- **Returns:** a new matrix with combined columns
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different number of rows
- **See also:** IntMatrix#hstack(IntMatrix)
##### add(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix add(final DoubleMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise addition of this matrix with another matrix.
- **Contract:**
  - The matrices must have the same dimensions.
- **Parameters:**
  - `other` (`DoubleMatrix`) — the matrix to add to this matrix
- **Returns:** a new matrix containing the element-wise sum
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
##### subtract(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix subtract(final DoubleMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise subtraction of another matrix from this matrix.
- **Contract:**
  - The matrices must have the same dimensions.
- **Parameters:**
  - `other` (`DoubleMatrix`) — the matrix to subtract from this matrix
- **Returns:** a new matrix containing the element-wise difference
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
##### multiply(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix multiply(final DoubleMatrix other) throws IllegalArgumentException`
- **Summary:** Performs matrix multiplication with another matrix.
- **Contract:**
  - The number of columns in this matrix must equal the number of rows in the other matrix.
- **Parameters:**
  - `other` (`DoubleMatrix`) — the matrix to multiply with this matrix
- **Returns:** a new matrix containing the matrix product
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrix dimensions are incompatible for multiplication
##### boxed(...) -> Matrix<Double>
- **Signature:** `public Matrix<Double> boxed()`
- **Summary:** Converts this primitive double matrix to a boxed Double matrix.
- **Parameters:**
  - (none)
- **Returns:** a new Matrix &lt; Double &gt; containing boxed Double values (same dimensions as the original)
##### zipWith(...) -> DoubleMatrix
- **Signature:** `public <E extends Exception> DoubleMatrix zipWith(final DoubleMatrix matrixB, final Throwables.DoubleBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Applies a binary operation element-wise to this matrix and another matrix.
- **Contract:**
  - The matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`DoubleMatrix`) — the matrix to combine with this matrix; must have the same dimensions and must not be null
  - `zipFunction` (`Throwables.DoubleBinaryOperator<E>`) — the binary operation to apply to corresponding elements; must not be null
- **Returns:** a new matrix with the operation applied element-wise (same dimensions as the input matrices)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
  - `E` — if the zip function throws an exception
- **Signature:** `public <E extends Exception> DoubleMatrix zipWith(final DoubleMatrix matrixB, final DoubleMatrix matrixC, final Throwables.DoubleTernaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Applies a ternary operation element-wise to this matrix and two other matrices.
- **Contract:**
  - All three matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`DoubleMatrix`) — the second matrix to combine; must have the same dimensions and must not be null
  - `matrixC` (`DoubleMatrix`) — the third matrix to combine; must have the same dimensions and must not be null
  - `zipFunction` (`Throwables.DoubleTernaryOperator<E>`) — the ternary operation to apply to corresponding elements; must not be null
- **Returns:** a new matrix with the operation applied element-wise (same dimensions as the input matrices)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
  - `E` — if the zip function throws an exception
##### streamH(...) -> DoubleStream
- **Signature:** `@Override public DoubleStream streamH()`
- **Summary:** Returns a stream of all matrix elements in row-major order (left to right, then top to bottom).
- **Parameters:**
  - (none)
- **Returns:** a DoubleStream of all matrix elements in row-major order, or an empty stream if the matrix is empty
- **Signature:** `@Override public DoubleStream streamH(final int rowIndex)`
- **Summary:** Returns a stream of elements from a single row.
- **Contract:**
  - <p> This method is particularly useful when you need to process or analyze a specific row of the matrix independently.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to stream (0-based)
- **Returns:** a DoubleStream of elements in the specified row, from left to right
- **Signature:** `@Override public DoubleStream streamH(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of elements from a range of rows in row-major order.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a DoubleStream of elements in the specified row range, or an empty stream if the matrix is empty
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rows, or fromRowIndex &gt; toRowIndex
##### streamLU2RD(...) -> DoubleStream
- **Signature:** `@Override public DoubleStream streamLU2RD()`
- **Summary:** Creates a stream of elements from the main diagonal (left-upper to right-down).
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a DoubleStream of diagonal elements from top-left to bottom-right
##### streamRU2LD(...) -> DoubleStream
- **Signature:** `@Override public DoubleStream streamRU2LD()`
- **Summary:** Creates a stream of elements from the anti-diagonal (right-upper to left-down).
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a DoubleStream of diagonal elements from top-right to bottom-left
##### streamV(...) -> DoubleStream
- **Signature:** `@Override @Beta public DoubleStream streamV()`
- **Summary:** Creates a stream of all elements in the matrix in column-major order.
- **Parameters:**
  - (none)
- **Returns:** a DoubleStream of all matrix elements in column-major order
- **Signature:** `@Override public DoubleStream streamV(final int columnIndex)`
- **Summary:** Creates a stream of elements from a single column in the matrix.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to stream (0-based)
- **Returns:** a DoubleStream of elements in the specified column, from top to bottom
- **Signature:** `@Override @Beta public DoubleStream streamV(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of elements from a range of columns in column-major order.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a DoubleStream of elements in the specified column range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the column indices are out of bounds
##### streamR(...) -> Stream<DoubleStream>
- **Signature:** `@Override public Stream<DoubleStream> streamR()`
- **Summary:** Creates a stream of streams, where each inner stream represents a complete row of the matrix.
- **Parameters:**
  - (none)
- **Returns:** a Stream of DoubleStreams, one for each row in the matrix
- **Signature:** `@Override public Stream<DoubleStream> streamR(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of streams for a range of rows.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a Stream of DoubleStreams for the specified row range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the row indices are out of bounds
##### streamC(...) -> Stream<DoubleStream>
- **Signature:** `@Override @Beta public Stream<DoubleStream> streamC()`
- **Summary:** Creates a stream of streams, where each inner stream represents a complete column of the matrix.
- **Parameters:**
  - (none)
- **Returns:** a Stream of DoubleStreams, one for each column in the matrix
- **Signature:** `@Override @Beta public Stream<DoubleStream> streamC(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of streams for a range of columns.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a Stream of DoubleStreams for the specified column range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the column indices are out of bounds
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.DoubleConsumer<E> action) throws E`
- **Summary:** Applies the specified action to each element of the matrix.
- **Parameters:**
  - `action` (`Throwables.DoubleConsumer<E>`) — the action to perform on each element; must not be null
- **Throws:**
  - `E` — if the action throws an exception
- **Signature:** `public <E extends Exception> void forEach(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.DoubleConsumer<E> action) throws IndexOutOfBoundsException, E`
- **Summary:** Applies the specified action to each element in a sub-region of the matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based, must be &gt; = 0 and &lt; rows)
  - `toRowIndex` (`int`) — the ending row index (exclusive, must be &gt; fromRowIndex and &lt; = rows)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based, must be &gt; = 0 and &lt; columnCount)
  - `toColumnIndex` (`int`) — the ending column index (exclusive, must be &gt; fromColumnIndex and &lt; = columnCount)
  - `action` (`Throwables.DoubleConsumer<E>`) — the action to perform on each element in the sub-region; must not be null
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds or invalid
  - `E` — if the action throws an exception
##### println(...) -> String
- **Signature:** `@Override public String println()`
- **Summary:** Prints the matrix to standard output in a formatted manner.
- **Parameters:**
  - (none)
- **Returns:** the formatted string representation of the matrix
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this matrix.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this matrix
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this matrix to the specified object for equality.
- **Contract:**
  - Returns {@code true} if the given object is also a DoubleMatrix with the same dimensions and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the objects are equal, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this matrix

### Class DoubleTuple (com.landawn.abacus.util.DoubleTuple)
Abstract base class for immutable tuple implementations that hold primitive double values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> DoubleTuple1
- **Signature:** `public static DoubleTuple1 of(final double _1)`
- **Summary:** Creates a DoubleTuple.DoubleTuple1 containing a single double value.
- **Parameters:**
  - `_1` (`double`) — the double value to wrap in a tuple
- **Returns:** a new DoubleTuple.DoubleTuple1 containing the provided value
- **Signature:** `public static DoubleTuple2 of(final double _1, final double _2)`
- **Summary:** Creates a DoubleTuple.DoubleTuple2 containing two double values.
- **Parameters:**
  - `_1` (`double`) — the first double value
  - `_2` (`double`) — the second double value
- **Returns:** a new DoubleTuple.DoubleTuple2 containing the provided values
- **Signature:** `public static DoubleTuple3 of(final double _1, final double _2, final double _3)`
- **Summary:** Creates a DoubleTuple.DoubleTuple3 containing three double values.
- **Parameters:**
  - `_1` (`double`) — the first double value
  - `_2` (`double`) — the second double value
  - `_3` (`double`) — the third double value
- **Returns:** a new DoubleTuple.DoubleTuple3 containing the provided values
- **Signature:** `public static DoubleTuple4 of(final double _1, final double _2, final double _3, final double _4)`
- **Summary:** Creates a DoubleTuple.DoubleTuple4 containing four double values.
- **Parameters:**
  - `_1` (`double`) — the first double value
  - `_2` (`double`) — the second double value
  - `_3` (`double`) — the third double value
  - `_4` (`double`) — the fourth double value
- **Returns:** a new DoubleTuple.DoubleTuple4 containing the provided values
- **Signature:** `public static DoubleTuple5 of(final double _1, final double _2, final double _3, final double _4, final double _5)`
- **Summary:** Creates a DoubleTuple.DoubleTuple5 containing five double values.
- **Parameters:**
  - `_1` (`double`) — the first double value
  - `_2` (`double`) — the second double value
  - `_3` (`double`) — the third double value
  - `_4` (`double`) — the fourth double value
  - `_5` (`double`) — the fifth double value
- **Returns:** a new DoubleTuple.DoubleTuple5 containing the provided values
- **Signature:** `public static DoubleTuple6 of(final double _1, final double _2, final double _3, final double _4, final double _5, final double _6)`
- **Summary:** Creates a DoubleTuple.DoubleTuple6 containing six double values.
- **Parameters:**
  - `_1` (`double`) — the first double value
  - `_2` (`double`) — the second double value
  - `_3` (`double`) — the third double value
  - `_4` (`double`) — the fourth double value
  - `_5` (`double`) — the fifth double value
  - `_6` (`double`) — the sixth double value
- **Returns:** a new DoubleTuple.DoubleTuple6 containing the provided values
- **Signature:** `public static DoubleTuple7 of(final double _1, final double _2, final double _3, final double _4, final double _5, final double _6, final double _7)`
- **Summary:** Creates a DoubleTuple.DoubleTuple7 containing seven double values.
- **Parameters:**
  - `_1` (`double`) — the first double value
  - `_2` (`double`) — the second double value
  - `_3` (`double`) — the third double value
  - `_4` (`double`) — the fourth double value
  - `_5` (`double`) — the fifth double value
  - `_6` (`double`) — the sixth double value
  - `_7` (`double`) — the seventh double value
- **Returns:** a new DoubleTuple.DoubleTuple7 containing the provided values
- **Signature:** `@Deprecated public static DoubleTuple8 of(final double _1, final double _2, final double _3, final double _4, final double _5, final double _6, final double _7, final double _8)`
- **Summary:** Creates a DoubleTuple.DoubleTuple8 containing eight double values.
- **Parameters:**
  - `_1` (`double`) — the first double value
  - `_2` (`double`) — the second double value
  - `_3` (`double`) — the third double value
  - `_4` (`double`) — the fourth double value
  - `_5` (`double`) — the fifth double value
  - `_6` (`double`) — the sixth double value
  - `_7` (`double`) — the seventh double value
  - `_8` (`double`) — the eighth double value
- **Returns:** a new DoubleTuple.DoubleTuple8 containing the provided values
- **Signature:** `@Deprecated public static DoubleTuple9 of(final double _1, final double _2, final double _3, final double _4, final double _5, final double _6, final double _7, final double _8, final double _9)`
- **Summary:** Creates a DoubleTuple.DoubleTuple9 containing nine double values.
- **Parameters:**
  - `_1` (`double`) — the first double value
  - `_2` (`double`) — the second double value
  - `_3` (`double`) — the third double value
  - `_4` (`double`) — the fourth double value
  - `_5` (`double`) — the fifth double value
  - `_6` (`double`) — the sixth double value
  - `_7` (`double`) — the seventh double value
  - `_8` (`double`) — the eighth double value
  - `_9` (`double`) — the ninth double value
- **Returns:** a new DoubleTuple.DoubleTuple9 containing the provided values
##### create(...) -> TP
- **Signature:** `@SuppressWarnings("deprecation") public static <TP extends DoubleTuple<TP>> TP create(final double[] values)`
- **Summary:** Creates a DoubleTuple from an array of double values.
- **Parameters:**
  - `values` (`double[]`) — the array of double values (must have length 0-9), may be {@code null}
- **Returns:** a DoubleTuple of appropriate size containing the array values, or an empty DoubleTuple if the array is null or empty

#### Public Instance Methods
##### min(...) -> double
- **Signature:** `public double min()`
- **Summary:** Returns the minimum double value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the minimum double value in this tuple
##### max(...) -> double
- **Signature:** `public double max()`
- **Summary:** Returns the maximum double value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the maximum double value in this tuple
##### median(...) -> double
- **Signature:** `public double median()`
- **Summary:** Returns the median value of the elements in this tuple.
- **Contract:**
  - <p> For tuples with an odd number of elements, returns the middle value when sorted.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Odd number of elements DoubleTuple.DoubleTuple3 tuple3 = DoubleTuple.of(30.0, 10.0, 20.0); double median = tuple3.median(); // 20.0 (middle value when sorted: 10.0, 20.0, 30.0) // Even number of elements DoubleTuple.DoubleTuple4 tuple4 = DoubleTuple.of(1.0, 2.0, 3.0, 4.0); double median2 = tuple4.median(); // 2.0 (lower middle value when sorted) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median double element in this tuple
##### sum(...) -> double
- **Signature:** `public double sum()`
- **Summary:** Returns the sum of all elements in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of all double values in this tuple
##### average(...) -> double
- **Signature:** `public double average()`
- **Summary:** Returns the average of all double values in this tuple.
- **Contract:**
  - The result is always returned as a double to preserve precision, even when the average is a whole number.
- **Parameters:**
  - (none)
- **Returns:** the average of all double values in this tuple
##### reverse(...) -> TP
- **Signature:** `public abstract TP reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Contract:**
  - For example, a tuple (1.0, 2.0, 3.0) becomes (3.0, 2.0, 1.0) when reversed.
- **Parameters:**
  - (none)
- **Returns:** a new tuple with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `public abstract boolean contains(double valueToFind)`
- **Summary:** Checks if this tuple contains the specified double value.
- **Contract:**
  - Checks if this tuple contains the specified double value.
  - <p> This method performs a linear search through all elements in the tuple to determine if any element matches the specified value.
  - Returns {@code true} if at least one element equals the search value, {@code false} otherwise.
- **Parameters:**
  - `valueToFind` (`double`) — the double value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### toArray(...) -> double\[\]
- **Signature:** `public double[] toArray()`
- **Summary:** Returns a new array containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new double array containing all tuple elements
##### toList(...) -> DoubleList
- **Signature:** `public DoubleList toList()`
- **Summary:** Returns a new DoubleList containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleList containing all tuple elements
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.DoubleConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.DoubleConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### stream(...) -> DoubleStream
- **Signature:** `public DoubleStream stream()`
- **Summary:** Returns a DoubleStream of all elements in this tuple.
- **Parameters:**
  - (none)
- **Returns:** a DoubleStream containing all tuple elements
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this tuple
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Contract:**
  - <p> Two tuples are considered equal if and only if: </p> <ul> <li> They are of the exact same class (e.g., both DoubleTuple.DoubleTuple2) </li> <li> They contain the same elements in the same order </li> </ul> <p> This method adheres to the general contract of {@link Object#equals(Object)} .
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is equal to this tuple, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this tuple

### Class DoubleTuple1 (com.landawn.abacus.util.DoubleTuple.DoubleTuple1)
A DoubleTuple containing exactly one double value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 1.
- **Parameters:**
  - (none)
- **Returns:** 1
##### min(...) -> double
- **Signature:** `@Override public double min()`
- **Summary:** Returns the minimum value in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### max(...) -> double
- **Signature:** `@Override public double max()`
- **Summary:** Returns the maximum value in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### median(...) -> double
- **Signature:** `@Override public double median()`
- **Summary:** Returns the median value in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### sum(...) -> double
- **Signature:** `@Override public double sum()`
- **Summary:** Returns the sum of elements in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of elements in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### reverse(...) -> DoubleTuple1
- **Signature:** `@Override public DoubleTuple1 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleTuple.DoubleTuple1 with the same value
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final double valueToFind)`
- **Summary:** Checks if this tuple contains the specified double value.
- **Contract:**
  - Checks if this tuple contains the specified double value.
- **Parameters:**
  - `valueToFind` (`double`) — the double value to search for
- **Returns:** {@code true} if _1 equals valueToFind, {@code false} otherwise
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on its single element.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a DoubleTuple.DoubleTuple1 with equal value
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(value)" where value is _1

### Class DoubleTuple2 (com.landawn.abacus.util.DoubleTuple.DoubleTuple2)
A DoubleTuple containing exactly two double values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 2.
- **Parameters:**
  - (none)
- **Returns:** 2
##### min(...) -> double
- **Signature:** `@Override public double min()`
- **Summary:** Returns the minimum value among the two elements.
- **Parameters:**
  - (none)
- **Returns:** the smaller of _1 and _2
##### max(...) -> double
- **Signature:** `@Override public double max()`
- **Summary:** Returns the maximum value among the two elements.
- **Parameters:**
  - (none)
- **Returns:** the larger of _1 and _2
##### median(...) -> double
- **Signature:** `@Override public double median()`
- **Summary:** Returns the median value of the two elements.
- **Parameters:**
  - (none)
- **Returns:** the median (lower) double value
##### sum(...) -> double
- **Signature:** `@Override public double sum()`
- **Summary:** Returns the sum of the two elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the two elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2) / 2.0
##### reverse(...) -> DoubleTuple2
- **Signature:** `@Override public DoubleTuple2 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleTuple.DoubleTuple2 with (_2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final double valueToFind)`
- **Summary:** Checks if this tuple contains the specified double value.
- **Contract:**
  - Checks if this tuple contains the specified double value.
- **Parameters:**
  - `valueToFind` (`double`) — the double value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.DoubleConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.DoubleConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.DoubleBiConsumer<E> action) throws E`
- **Summary:** Performs the given bi-consumer action on the two elements of this tuple.
- **Parameters:**
  - `action` (`Throwables.DoubleBiConsumer<E>`) — the bi-consumer to perform on the two elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `@MayReturnNull public <U, E extends Exception> U map(final Throwables.DoubleBiFunction<U, E> mapper) throws E`
- **Summary:** Applies the given bi-function to the two elements and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.DoubleBiFunction<U, E>`) — the bi-function to apply to the two elements
- **Returns:** the result of applying the mapper to _1 and _2
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<DoubleTuple2>
- **Signature:** `public <E extends Exception> Optional<DoubleTuple2> filter(final Throwables.DoubleBiPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Contract:**
  - Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
  - If the predicate returns {@code true} , returns an Optional containing this tuple.
  - If it returns {@code false} , returns an empty Optional.
- **Parameters:**
  - `predicate` (`Throwables.DoubleBiPredicate<E>`) — the bi-predicate to test the two elements
- **Returns:** Optional containing this tuple if predicate returns true, empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on both elements.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a DoubleTuple.DoubleTuple2 with equal elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(_1, _2)"

### Class DoubleTuple3 (com.landawn.abacus.util.DoubleTuple.DoubleTuple3)
A DoubleTuple containing exactly three double values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 3.
- **Parameters:**
  - (none)
- **Returns:** 3
##### min(...) -> double
- **Signature:** `@Override public double min()`
- **Summary:** Returns the minimum value among the three elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, and _3
##### max(...) -> double
- **Signature:** `@Override public double max()`
- **Summary:** Returns the maximum value among the three elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, and _3
##### median(...) -> double
- **Signature:** `@Override public double median()`
- **Summary:** Returns the median value of the three elements.
- **Contract:**
  - For three elements (odd number), returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> double
- **Signature:** `@Override public double sum()`
- **Summary:** Returns the sum of the three elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the three elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3) / 3.0
##### reverse(...) -> DoubleTuple3
- **Signature:** `@Override public DoubleTuple3 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleTuple.DoubleTuple3 with (_3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final double valueToFind)`
- **Summary:** Checks if this tuple contains the specified double value.
- **Contract:**
  - Checks if this tuple contains the specified double value.
- **Parameters:**
  - `valueToFind` (`double`) — the double value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.DoubleConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.DoubleConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.DoubleTriConsumer<E> action) throws E`
- **Summary:** Performs the given tri-consumer action on the three elements of this tuple.
- **Parameters:**
  - `action` (`Throwables.DoubleTriConsumer<E>`) — the tri-consumer to perform on the three elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `@MayReturnNull public <U, E extends Exception> U map(final Throwables.DoubleTriFunction<U, E> mapper) throws E`
- **Summary:** Applies the given tri-function to the three elements and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.DoubleTriFunction<U, E>`) — the tri-function to apply to the three elements
- **Returns:** the result of applying the mapper to _1, _2, and _3
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<DoubleTuple3>
- **Signature:** `public <E extends Exception> Optional<DoubleTuple3> filter(final Throwables.DoubleTriPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Contract:**
  - Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
  - If the predicate returns {@code true} , returns an Optional containing this tuple.
  - If it returns {@code false} , returns an empty Optional.
- **Parameters:**
  - `predicate` (`Throwables.DoubleTriPredicate<E>`) — the tri-predicate to test the three elements
- **Returns:** Optional containing this tuple if predicate returns true, empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on all three elements.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a DoubleTuple.DoubleTuple3 with equal elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(_1, _2, _3)"

### Class DoubleTuple4 (com.landawn.abacus.util.DoubleTuple.DoubleTuple4)
A DoubleTuple containing exactly four double values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 4.
- **Parameters:**
  - (none)
- **Returns:** 4
##### min(...) -> double
- **Signature:** `@Override public double min()`
- **Summary:** Returns the minimum value among the four elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, and _4
##### max(...) -> double
- **Signature:** `@Override public double max()`
- **Summary:** Returns the maximum value among the four elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, and _4
##### median(...) -> double
- **Signature:** `@Override public double median()`
- **Summary:** Returns the median value of the four elements.
- **Parameters:**
  - (none)
- **Returns:** the median double value
##### sum(...) -> double
- **Signature:** `@Override public double sum()`
- **Summary:** Returns the sum of the four elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the four elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4) / 4.0
##### reverse(...) -> DoubleTuple4
- **Signature:** `@Override public DoubleTuple4 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleTuple.DoubleTuple4 with (_4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final double valueToFind)`
- **Summary:** Checks if this tuple contains the specified double value.
- **Contract:**
  - Checks if this tuple contains the specified double value.
- **Parameters:**
  - `valueToFind` (`double`) — the double value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.DoubleConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.DoubleConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on all four elements.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a DoubleTuple.DoubleTuple4 with equal elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(_1, _2, _3, _4)"

### Class DoubleTuple5 (com.landawn.abacus.util.DoubleTuple.DoubleTuple5)
A DoubleTuple containing exactly five double values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 5.
- **Parameters:**
  - (none)
- **Returns:** 5
##### min(...) -> double
- **Signature:** `@Override public double min()`
- **Summary:** Returns the minimum value among the five elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, and _5
##### max(...) -> double
- **Signature:** `@Override public double max()`
- **Summary:** Returns the maximum value among the five elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, and _5
##### median(...) -> double
- **Signature:** `@Override public double median()`
- **Summary:** Returns the median value of the five elements.
- **Contract:**
  - For five elements (odd number), returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> double
- **Signature:** `@Override public double sum()`
- **Summary:** Returns the sum of the five elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the five elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5) / 5.0
##### reverse(...) -> DoubleTuple5
- **Signature:** `@Override public DoubleTuple5 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleTuple.DoubleTuple5 with (_5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final double valueToFind)`
- **Summary:** Checks if this tuple contains the specified double value.
- **Contract:**
  - Checks if this tuple contains the specified double value.
- **Parameters:**
  - `valueToFind` (`double`) — the double value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.DoubleConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.DoubleConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on all five elements.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a DoubleTuple.DoubleTuple5 with equal elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(_1, _2, _3, _4, _5)"

### Class DoubleTuple6 (com.landawn.abacus.util.DoubleTuple.DoubleTuple6)
A DoubleTuple containing exactly six double values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 6.
- **Parameters:**
  - (none)
- **Returns:** 6
##### min(...) -> double
- **Signature:** `@Override public double min()`
- **Summary:** Returns the minimum value among the six elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, and _6
##### max(...) -> double
- **Signature:** `@Override public double max()`
- **Summary:** Returns the maximum value among the six elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, and _6
##### median(...) -> double
- **Signature:** `@Override public double median()`
- **Summary:** Returns the median value of the six elements.
- **Parameters:**
  - (none)
- **Returns:** the median double value
##### sum(...) -> double
- **Signature:** `@Override public double sum()`
- **Summary:** Returns the sum of the six elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the six elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6) / 6.0
##### reverse(...) -> DoubleTuple6
- **Signature:** `@Override public DoubleTuple6 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleTuple.DoubleTuple6 with (_6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final double valueToFind)`
- **Summary:** Checks if this tuple contains the specified double value.
- **Contract:**
  - Checks if this tuple contains the specified double value.
- **Parameters:**
  - `valueToFind` (`double`) — the double value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.DoubleConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.DoubleConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on all six elements.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a DoubleTuple.DoubleTuple6 with equal elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(_1, _2, _3, _4, _5, _6)"

### Class DoubleTuple7 (com.landawn.abacus.util.DoubleTuple.DoubleTuple7)
A DoubleTuple containing exactly seven double values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 7.
- **Parameters:**
  - (none)
- **Returns:** 7
##### min(...) -> double
- **Signature:** `@Override public double min()`
- **Summary:** Returns the minimum value among the seven elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, _6, and _7
##### max(...) -> double
- **Signature:** `@Override public double max()`
- **Summary:** Returns the maximum value among the seven elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, _6, and _7
##### median(...) -> double
- **Signature:** `@Override public double median()`
- **Summary:** Returns the median value of the seven elements.
- **Contract:**
  - For seven elements (odd number), returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> double
- **Signature:** `@Override public double sum()`
- **Summary:** Returns the sum of the seven elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the seven elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7) / 7.0
##### reverse(...) -> DoubleTuple7
- **Signature:** `@Override public DoubleTuple7 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleTuple.DoubleTuple7 with (_7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final double valueToFind)`
- **Summary:** Checks if this tuple contains the specified double value.
- **Contract:**
  - Checks if this tuple contains the specified double value.
- **Parameters:**
  - `valueToFind` (`double`) — the double value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.DoubleConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.DoubleConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on all seven elements.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a DoubleTuple.DoubleTuple7 with equal elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(_1, _2, _3, _4, _5, _6, _7)"

### Class DoubleTuple8 (com.landawn.abacus.util.DoubleTuple.DoubleTuple8)
A DoubleTuple containing exactly eight double values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 8.
- **Parameters:**
  - (none)
- **Returns:** 8
##### min(...) -> double
- **Signature:** `@Override public double min()`
- **Summary:** Returns the minimum value among the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, _6, _7, and _8
##### max(...) -> double
- **Signature:** `@Override public double max()`
- **Summary:** Returns the maximum value among the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, _6, _7, and _8
##### median(...) -> double
- **Signature:** `@Override public double median()`
- **Summary:** Returns the median value of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the median double value
##### sum(...) -> double
- **Signature:** `@Override public double sum()`
- **Summary:** Returns the sum of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7 + _8) / 8.0
##### reverse(...) -> DoubleTuple8
- **Signature:** `@Override public DoubleTuple8 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleTuple.DoubleTuple8 with (_8, _7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final double valueToFind)`
- **Summary:** Checks if this tuple contains the specified double value.
- **Contract:**
  - Checks if this tuple contains the specified double value.
- **Parameters:**
  - `valueToFind` (`double`) — the double value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.DoubleConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.DoubleConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on all eight elements.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a DoubleTuple.DoubleTuple8 with equal elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(_1, _2, _3, _4, _5, _6, _7, _8)"

### Class DoubleTuple9 (com.landawn.abacus.util.DoubleTuple.DoubleTuple9)
A DoubleTuple containing exactly nine double values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 9.
- **Parameters:**
  - (none)
- **Returns:** 9
##### min(...) -> double
- **Signature:** `@Override public double min()`
- **Summary:** Returns the minimum value among the nine elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, _6, _7, _8, and _9
##### max(...) -> double
- **Signature:** `@Override public double max()`
- **Summary:** Returns the maximum value among the nine elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, _6, _7, _8, and _9
##### median(...) -> double
- **Signature:** `@Override public double median()`
- **Summary:** Returns the median value of the nine elements.
- **Contract:**
  - For nine elements (odd number), returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> double
- **Signature:** `@Override public double sum()`
- **Summary:** Returns the sum of the nine elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 + _9
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the nine elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 + _9) / 9.0
##### reverse(...) -> DoubleTuple9
- **Signature:** `@Override public DoubleTuple9 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleTuple.DoubleTuple9 with (_9, _8, _7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final double valueToFind)`
- **Summary:** Checks if this tuple contains the specified double value.
- **Contract:**
  - Checks if this tuple contains the specified double value.
- **Parameters:**
  - `valueToFind` (`double`) — the double value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.DoubleConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.DoubleConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on all nine elements.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a DoubleTuple.DoubleTuple9 with equal elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(_1, _2, _3, _4, _5, _6, _7, _8, _9)"

### Class FloatMatrix (com.landawn.abacus.util.FloatMatrix)
A matrix implementation for float primitive values, providing efficient storage and operations for two-dimensional float arrays.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### empty(...) -> FloatMatrix
- **Signature:** `public static FloatMatrix empty()`
- **Summary:** Creates an empty matrix with zero rows and zero columns.
- **Parameters:**
  - (none)
- **Returns:** an empty float matrix
##### of(...) -> FloatMatrix
- **Signature:** `public static FloatMatrix of(final float[]... a)`
- **Summary:** Creates a FloatMatrix from a two-dimensional float array.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional float array to create the matrix from, or null/empty for an empty matrix
- **Returns:** a new FloatMatrix containing the provided data, or an empty FloatMatrix if input is null or empty
##### from(...) -> FloatMatrix
- **Signature:** `public static FloatMatrix from(final int[]... a)`
- **Summary:** Creates a FloatMatrix from a two-dimensional int array by converting int values to float.
- **Contract:**
  - <p> <b> Requirements: </b> </p> <ul> <li> All rows must have the same length as the first row (rectangular array required) </li> <li> The first row cannot be null if the array is non-empty </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code FloatMatrix matrix = FloatMatrix.from(new int\[\]\[\] {{1, 2}, {3, 4}}); // Creates a matrix with values {{1.0f, 2.0f}, {3.0f, 4.0f}} assert matrix.get(1, 0) == 3.0f; assert matrix.rowCount() == 2 && matrix.columnCount() == 2; } </pre>
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional int array to convert to a float matrix, or null/empty for an empty matrix
- **Returns:** a new FloatMatrix with converted values, or an empty FloatMatrix if input is null or empty
##### random(...) -> FloatMatrix
- **Signature:** `public static FloatMatrix random(final int size)`
- **Summary:** Creates a new 1xsize matrix filled with random float values.
- **Parameters:**
  - `size` (`int`) — the number of columns in the new matrix
- **Returns:** a new FloatMatrix of dimensions 1 x size filled with random values
- **Signature:** `public static FloatMatrix random(final int rowCount, final int columnCount)`
- **Summary:** Creates a new matrix of the specified dimensions filled with random float values.
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
- **Returns:** a new FloatMatrix of dimensions rowCount x columnCount filled with random values
##### repeat(...) -> FloatMatrix
- **Signature:** `public static FloatMatrix repeat(final int rowCount, final int columnCount, final float element)`
- **Summary:** Creates a new matrix of the specified dimensions where every element is the provided {@code element} .
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
  - `element` (`float`) — the float value to fill the matrix with
- **Returns:** a new FloatMatrix of dimensions rowCount x columnCount filled with the specified element
##### diagonalLU2RD(...) -> FloatMatrix
- **Signature:** `public static FloatMatrix diagonalLU2RD(final float[] leftUp2RightDownDiagonal)`
- **Summary:** Creates a square matrix from the specified main diagonal elements (left-upper to right-down).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`float[]`) — the array of main diagonal elements, or null/empty for an empty matrix
- **Returns:** a square matrix with the specified main diagonal, or an empty matrix if input is null or empty
##### diagonalRU2LD(...) -> FloatMatrix
- **Signature:** `public static FloatMatrix diagonalRU2LD(final float[] rightUp2LeftDownDiagonal)`
- **Summary:** Creates a square matrix from the specified anti-diagonal elements (right-upper to left-down).
- **Parameters:**
  - `rightUp2LeftDownDiagonal` (`float[]`) — the array of anti-diagonal elements, or null/empty for an empty matrix
- **Returns:** a square matrix with the specified anti-diagonal, or an empty matrix if input is null or empty
##### diagonal(...) -> FloatMatrix
- **Signature:** `public static FloatMatrix diagonal(final float[] leftUp2RightDownDiagonal, final float[] rightUp2LeftDownDiagonal) throws IllegalArgumentException`
- **Summary:** Creates a square matrix from the specified main diagonal and anti-diagonal elements.
- **Contract:**
  - If both arrays are provided, they must have the same length.
  - The resulting matrix has dimensions n×n where n is the length of the non-null/non-empty array (or the maximum length if both are provided).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`float[]`) — the array of main diagonal elements (can be null or empty)
  - `rightUp2LeftDownDiagonal` (`float[]`) — the array of anti-diagonal elements (can be null or empty)
- **Returns:** a square matrix with the specified diagonals, or an empty matrix if both inputs are null or empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — if both arrays are non-empty and have different lengths
##### unbox(...) -> FloatMatrix
- **Signature:** `public static FloatMatrix unbox(final Matrix<Float> x)`
- **Summary:** Converts a boxed Float Matrix to a primitive FloatMatrix.
- **Parameters:**
  - `x` (`Matrix<Float>`) — the boxed Float matrix to convert
- **Returns:** a new FloatMatrix with primitive float values

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public FloatMatrix(final float[][] a)`
- **Summary:** Constructs a FloatMatrix from a two-dimensional float array.
- **Contract:**
  - If the input array is null, an empty matrix (0x0) is created.
  - If you need an independent copy, use {@link #copy()} after construction.
- **Parameters:**
  - `a` (`float[][]`) — the two-dimensional float array to wrap as a matrix. Can be null, which creates an empty matrix.
##### componentType(...) -> Class
- **Signature:** `@SuppressWarnings("rawtypes") @Override public Class componentType()`
- **Summary:** Returns the component type of the matrix elements, which is always {@code float.class} .
- **Parameters:**
  - (none)
- **Returns:** {@code float.class}
##### get(...) -> float
- **Signature:** `public float get(final int i, final int j)`
- **Summary:** Returns the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** the element at position (rowIndex, columnIndex)
- **Signature:** `public float get(final Point point)`
- **Summary:** Returns the element at the specified Sheet.Point.
- **Parameters:**
  - `point` (`Point`)
- **Returns:** the float element at the specified Sheet.Point
- **See also:** #get(int, int)
##### set(...) -> void
- **Signature:** `public void set(final int i, final int j, final float val)`
- **Summary:** Sets the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
  - `val` (`float`) — the value to set
- **Signature:** `public void set(final Point point, final float val)`
- **Summary:** Sets the element at the specified Sheet.Point to the given value.
- **Parameters:**
  - `point` (`Point`)
  - `val` (`float`) — the new float value to set at the specified Sheet.Point
- **See also:** #set(int, int, float)
##### upOf(...) -> OptionalFloat
- **Signature:** `public OptionalFloat upOf(final int i, final int j)`
- **Summary:** Returns the element directly above the specified position, if it exists.
- **Contract:**
  - Returns the element directly above the specified position, if it exists.
  - If the specified position is in the first row (i == 0), returns an empty Optional.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalFloat containing the element at position (rowIndex - 1, columnIndex), or empty if rowIndex == 0
##### downOf(...) -> OptionalFloat
- **Signature:** `public OptionalFloat downOf(final int i, final int j)`
- **Summary:** Returns the element directly below the specified position, if it exists.
- **Contract:**
  - Returns the element directly below the specified position, if it exists.
  - If the specified position is in the last row, returns an empty Optional.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalFloat containing the element at position (rowIndex + 1, columnIndex), or empty if rowIndex == rowCount - 1
##### leftOf(...) -> OptionalFloat
- **Signature:** `public OptionalFloat leftOf(final int i, final int j)`
- **Summary:** Returns the element directly to the left of the specified position, if it exists.
- **Contract:**
  - Returns the element directly to the left of the specified position, if it exists.
  - If the specified position is in the first column (j == 0), returns an empty Optional.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalFloat containing the element at position (rowIndex, columnIndex - 1), or empty if columnIndex == 0
##### rightOf(...) -> OptionalFloat
- **Signature:** `public OptionalFloat rightOf(final int i, final int j)`
- **Summary:** Returns the element directly to the right of the specified position, if it exists.
- **Contract:**
  - Returns the element directly to the right of the specified position, if it exists.
  - If the specified position is in the last column, returns an empty Optional.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalFloat containing the element at position (rowIndex, columnIndex + 1), or empty if columnIndex == columnCount - 1
##### row(...) -> float\[\]
- **Signature:** `public float[] row(final int rowIndex) throws IllegalArgumentException`
- **Summary:** Returns the specified row as a float array.
- **Contract:**
  - If you need an independent copy, use {@code Arrays.copyOf(matrix.row(rowIndex), matrix.columnCount())} .
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to retrieve (0-based)
- **Returns:** the specified row array (direct reference to internal storage)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex &lt; 0 or rowIndex &gt; = rows
##### column(...) -> float\[\]
- **Signature:** `public float[] column(final int columnIndex) throws IllegalArgumentException`
- **Summary:** Returns a copy of the specified column as a new array.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to retrieve (0-based)
- **Returns:** a new array containing a copy of the specified column
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex &lt; 0 or columnIndex &gt; = columnCount
##### setRow(...) -> void
- **Signature:** `public void setRow(final int rowIndex, final float[] row) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified row by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of columns in the matrix.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to set (0-based)
  - `row` (`float[]`) — the array of values to copy into the row; must have length equal to the number of columns
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex is out of bounds or row length does not match column count
##### setColumn(...) -> void
- **Signature:** `public void setColumn(final int columnIndex, final float[] column) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified column by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of rows in the matrix.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to set (0-based)
  - `column` (`float[]`) — the array of values to copy into the column; must have length equal to the number of rows
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex is out of bounds or column length does not match row count
##### updateRow(...) -> void
- **Signature:** `public <E extends Exception> void updateRow(final int rowIndex, final Throwables.FloatUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a row in-place by applying the specified operator to each element.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to update (0-based)
  - `operator` (`Throwables.FloatUnaryOperator<E>`) — the operator to apply to each element in the row; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### updateColumn(...) -> void
- **Signature:** `public <E extends Exception> void updateColumn(final int columnIndex, final Throwables.FloatUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a column in-place by applying the specified operator.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to update (0-based)
  - `operator` (`Throwables.FloatUnaryOperator<E>`) — the operator to apply to each element in the column; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### getLU2RD(...) -> float\[\]
- **Signature:** `public float[] getLU2RD() throws IllegalStateException`
- **Summary:** Returns a copy of the elements on the main diagonal from left-upper to right-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new float array containing a copy of the main diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setLU2RD(...) -> void
- **Signature:** `public void setLU2RD(final float[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the main diagonal from left-upper to right-down (main diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array must have exactly as many elements as the matrix has rows.
- **Parameters:**
  - `diagonal` (`float[]`) — the new values for the main diagonal; must have length == rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal to rows
##### updateLU2RD(...) -> void
- **Signature:** `public <E extends Exception> void updateLU2RD(final Throwables.FloatUnaryOperator<E> operator) throws E`
- **Summary:** Updates the values on the main diagonal (left-up to right-down) by applying the specified operator.
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - `operator` (`Throwables.FloatUnaryOperator<E>`) — the operator to apply to each diagonal element; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### getRU2LD(...) -> float\[\]
- **Signature:** `public float[] getRU2LD() throws IllegalStateException`
- **Summary:** Returns a copy of the elements on the anti-diagonal from right-upper to left-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new float array containing a copy of the anti-diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setRU2LD(...) -> void
- **Signature:** `public void setRU2LD(final float[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the anti-diagonal from right-upper to left-down (anti-diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array length must be equal to the number of rows.
- **Parameters:**
  - `diagonal` (`float[]`) — the new values for the anti-diagonal; must have length equal to rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length != rows
##### updateRU2LD(...) -> void
- **Signature:** `public <E extends Exception> void updateRU2LD(final Throwables.FloatUnaryOperator<E> operator) throws E`
- **Summary:** Updates the values on the anti-diagonal (right-up to left-down) by applying the specified operator.
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - `operator` (`Throwables.FloatUnaryOperator<E>`) — the operator to apply to each anti-diagonal element; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### updateAll(...) -> void
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.FloatUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the matrix in-place by applying the specified operator.
- **Contract:**
  - Elements are processed in row-major order when executed sequentially.
- **Parameters:**
  - `operator` (`Throwables.FloatUnaryOperator<E>`) — the operator to apply to each element; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.IntBiFunction<Float, E> operator) throws E`
- **Summary:** Updates all elements in the matrix in-place based on their position (row and column indices).
- **Parameters:**
  - `operator` (`Throwables.IntBiFunction<Float, E>`) — the operator that receives row index and column index (0-based) and returns the new value for that position
- **Throws:**
  - `E` — if the operator throws an exception
##### replaceIf(...) -> void
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.FloatPredicate<E> predicate, final float newValue) throws E`
- **Summary:** Conditionally replaces elements in-place based on a predicate.
- **Parameters:**
  - `predicate` (`Throwables.FloatPredicate<E>`) — the condition to test each element; elements for which this returns {@code true} will be replaced
  - `newValue` (`float`) — the value to use for replacing matching elements
- **Throws:**
  - `E` — if the predicate throws an exception
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.IntBiPredicate<E> predicate, final float newValue) throws E`
- **Summary:** Conditionally replaces elements in-place based on their position (row and column indices).
- **Parameters:**
  - `predicate` (`Throwables.IntBiPredicate<E>`) — the condition to test each position; receives row index and column index (0-based) and returns {@code true} if the element at that position should be replaced
  - `newValue` (`float`) — the value to use for replacing at matching positions
- **Throws:**
  - `E` — if the predicate throws an exception
##### map(...) -> FloatMatrix
- **Signature:** `public <E extends Exception> FloatMatrix map(final Throwables.FloatUnaryOperator<E> mapper) throws E`
- **Summary:** Creates a new FloatMatrix by applying the specified function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.FloatUnaryOperator<E>`) — the mapping function to apply to each element; must not be null
- **Returns:** a new FloatMatrix with the mapped values (same dimensions as the original)
- **Throws:**
  - `E` — if the function throws an exception
##### mapToObj(...) -> Matrix<T>
- **Signature:** `public <T, E extends Exception> Matrix<T> mapToObj(final Throwables.FloatFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Creates a new object Matrix by applying the specified function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.FloatFunction<? extends T, E>`) — the mapping function that converts each float element to type T; must not be null
  - `targetElementType` (`Class<T>`) — the class object representing the target element type (used for array creation); must not be null
- **Returns:** a new Matrix &lt; T &gt; with the mapped values (same dimensions as the original)
- **Throws:**
  - `E` — if the function throws an exception
##### fill(...) -> void
- **Signature:** `public void fill(final float val)`
- **Summary:** Fills the entire matrix with the specified value in-place.
- **Parameters:**
  - `val` (`float`) — the value to fill the matrix with
- **Signature:** `public void fill(final float[][] b)`
- **Summary:** Fills the matrix with values from the specified two-dimensional array in-place, starting from position (0,0).
- **Contract:**
  - If the source array is smaller than the matrix, only the overlapping region is filled.
  - If the source array is larger, only the portion that fits is copied.
- **Parameters:**
  - `b` (`float[][]`) — the source array to copy values from (maybe smaller or larger than the matrix)
- **Signature:** `public void fill(final int fromRowIndex, final int fromColumnIndex, final float[][] b) throws IllegalArgumentException`
- **Summary:** Fills a portion of the matrix with values from the specified two-dimensional array in-place, starting from a specified position.
- **Contract:**
  - If the source array extends beyond the matrix bounds from the starting position, only the portion that fits is copied.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index in this matrix (0-based)
  - `fromColumnIndex` (`int`) — the starting column index in this matrix (0-based)
  - `b` (`float[][]`) — the source array to copy values from
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the starting indices are negative or exceed matrix dimensions
##### copy(...) -> FloatMatrix
- **Signature:** `@Override public FloatMatrix copy()`
- **Summary:** Returns a deep copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is a deep copy of this matrix with full independence guarantee
- **Signature:** `@Override public FloatMatrix copy(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a copy of a row range from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a new FloatMatrix containing a copy of the specified rows
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds
- **Signature:** `@Override public FloatMatrix copy(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a copy of a rectangular region from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a new FloatMatrix containing the specified region with dimensions (toRowIndex - fromRowIndex) × (toColumnIndex - fromColumnIndex)
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is out of bounds, fromRowIndex &gt; toRowIndex, or fromColumnIndex &gt; toColumnIndex
##### extend(...) -> FloatMatrix
- **Signature:** `public FloatMatrix extend(final int newRowCount, final int newColumnCount)`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with 0.0f.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
- **Returns:** a new FloatMatrix with the specified dimensions
- **Signature:** `public FloatMatrix extend(final int newRowCount, final int newColumnCount, final float defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated from the top-left corner.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with the specified default value.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
  - `defaultValueForNewCell` (`float`) — the float value to fill new cells with during extension
- **Returns:** a new FloatMatrix with the specified dimensions
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code newRowCount} or {@code newColumnCount} is negative, or if the resulting matrix would be too large (dimensions exceeding Integer.MAX_VALUE elements)
- **Signature:** `public FloatMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight)`
- **Summary:** Creates a new matrix by extending this matrix in all four directions.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
- **Returns:** a new extended FloatMatrix with dimensions ((toUp+rows+toDown) x (toLeft+columnCount+toRight))
- **Signature:** `public FloatMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight, final float defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending this matrix in all four directions with padding.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
  - `defaultValueForNewCell` (`float`) — the float value to fill all new cells with
- **Returns:** a new extended FloatMatrix with dimensions ((toUp+rows+toDown) x (toLeft+columnCount+toRight))
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any padding parameter is negative, or if the resulting dimensions would exceed Integer.MAX_VALUE
##### reverseH(...) -> void
- **Signature:** `public void reverseH()`
- **Summary:** Reverses the order of elements in each row (horizontal flip in-place).
- **Parameters:**
  - (none)
- **See also:** #flipH()
##### reverseV(...) -> void
- **Signature:** `public void reverseV()`
- **Summary:** Reverses the order of rows in the matrix (vertical flip in-place).
- **Parameters:**
  - (none)
- **See also:** #flipV()
##### flipH(...) -> FloatMatrix
- **Signature:** `public FloatMatrix flipH()`
- **Summary:** Creates a new matrix that is horizontally flipped (each row reversed).
- **Parameters:**
  - (none)
- **Returns:** a new FloatMatrix with each row reversed horizontally
- **See also:** #flipV()
##### flipV(...) -> FloatMatrix
- **Signature:** `public FloatMatrix flipV()`
- **Summary:** Creates a new matrix that is vertically flipped (each column reversed).
- **Parameters:**
  - (none)
- **Returns:** a new FloatMatrix with rows reversed vertically (top to bottom flip)
- **See also:** #flipH()
##### rotate90(...) -> FloatMatrix
- **Signature:** `@Override public FloatMatrix rotate90()`
- **Summary:** Returns a new matrix rotated 90 degrees clockwise.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 90 degrees clockwise
##### rotate180(...) -> FloatMatrix
- **Signature:** `@Override public FloatMatrix rotate180()`
- **Summary:** Returns a new matrix rotated 180 degrees.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 180 degrees
##### rotate270(...) -> FloatMatrix
- **Signature:** `@Override public FloatMatrix rotate270()`
- **Summary:** Returns a new matrix rotated 270 degrees clockwise (or 90 degrees counter-clockwise).
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 270 degrees clockwise
##### transpose(...) -> FloatMatrix
- **Signature:** `@Override public FloatMatrix transpose()`
- **Summary:** Creates the transpose of this matrix by swapping rows and columns.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is the transpose of this matrix with dimensions columnCount × rows
##### reshape(...) -> FloatMatrix
- **Signature:** `@SuppressFBWarnings("ICAST_INTEGER_MULTIPLY_CAST_TO_LONG") @Override public FloatMatrix reshape(final int newRowCount, final int newColumnCount)`
- **Summary:** Reshapes the matrix to new dimensions while preserving element order.
- **Contract:**
  - <p> If the new shape has fewer total elements than the original, excess elements are truncated.
  - If the new shape has more total elements, the additional positions are filled with zeros.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the reshaped matrix
  - `newColumnCount` (`int`) — the number of columns in the reshaped matrix
- **Returns:** a new FloatMatrix with the specified shape containing this matrix's elements
##### repelem(...) -> FloatMatrix
- **Signature:** `@Override public FloatMatrix repelem(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats elements in both row and column directions.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat each element in row direction
  - `colRepeats` (`int`) — number of times to repeat each element in column direction
- **Returns:** a new FloatMatrix with repeated elements
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
- **See also:** IntMatrix#repelem(int, int)
##### repmat(...) -> FloatMatrix
- **Signature:** `@Override public FloatMatrix repmat(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats the entire matrix in a tiled pattern.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat the matrix vertically
  - `colRepeats` (`int`) — number of times to repeat the matrix horizontally
- **Returns:** a new FloatMatrix with the tiled pattern
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
- **See also:** IntMatrix#repmat(int, int)
##### flatten(...) -> FloatList
- **Signature:** `@Override public FloatList flatten()`
- **Summary:** Returns a list containing all matrix elements in row-major order.
- **Parameters:**
  - (none)
- **Returns:** a list of all elements in row-major order
##### flatOp(...) -> void
- **Signature:** `@Override public <E extends Exception> void flatOp(final Throwables.Consumer<? super float[], E> op) throws E`
- **Summary:** Applies an operation to each row array of the matrix.
- **Parameters:**
  - `op` (`Throwables.Consumer<? super float[], E>`) — the operation to apply to each row array
- **Throws:**
  - `E` — if the operation throws an exception
- **See also:** Arrays#flatOp(float\[\]\[\], Throwables.Consumer)
##### vstack(...) -> FloatMatrix
- **Signature:** `public FloatMatrix vstack(final FloatMatrix other) throws IllegalArgumentException`
- **Summary:** Stacks this matrix vertically with another matrix.
- **Contract:**
  - The matrices must have the same number of columns.
- **Parameters:**
  - `other` (`FloatMatrix`) — the matrix to stack below this matrix
- **Returns:** a new FloatMatrix with other stacked vertically below this matrix
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same number of columns
- **See also:** IntMatrix#vstack(IntMatrix)
##### hstack(...) -> FloatMatrix
- **Signature:** `public FloatMatrix hstack(final FloatMatrix other) throws IllegalArgumentException`
- **Summary:** Stacks this matrix horizontally with another matrix.
- **Contract:**
  - The matrices must have the same number of rows.
- **Parameters:**
  - `other` (`FloatMatrix`) — the matrix to stack to the right of this matrix
- **Returns:** a new FloatMatrix with other stacked horizontally to the right
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same number of rows
- **See also:** IntMatrix#hstack(IntMatrix)
##### add(...) -> FloatMatrix
- **Signature:** `public FloatMatrix add(final FloatMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise addition of this matrix with another matrix.
- **Contract:**
  - The matrices must have the same dimensions (same number of rows and columns).
- **Parameters:**
  - `other` (`FloatMatrix`) — the matrix to add to this matrix
- **Returns:** a new FloatMatrix containing the element-wise sum (same dimensions as inputs)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
##### subtract(...) -> FloatMatrix
- **Signature:** `public FloatMatrix subtract(final FloatMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise subtraction of another matrix from this matrix.
- **Contract:**
  - The matrices must have the same dimensions (same number of rows and columns).
- **Parameters:**
  - `other` (`FloatMatrix`) — the matrix to subtract from this matrix
- **Returns:** a new FloatMatrix containing the element-wise difference (same dimensions as inputs)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
##### multiply(...) -> FloatMatrix
- **Signature:** `public FloatMatrix multiply(final FloatMatrix other) throws IllegalArgumentException`
- **Summary:** Performs matrix multiplication of this matrix with another matrix.
- **Contract:**
  - The number of columns in this matrix must equal the number of rows in the other matrix.
- **Parameters:**
  - `other` (`FloatMatrix`) — the matrix to multiply with this matrix
- **Returns:** a new FloatMatrix containing the matrix product with dimensions (this.rowCount × other.columnCount)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrix dimensions are incompatible for multiplication (i.e., this.columnCount != other.rowCount)
##### boxed(...) -> Matrix<Float>
- **Signature:** `public Matrix<Float> boxed()`
- **Summary:** Converts this primitive float matrix to a boxed Float matrix.
- **Parameters:**
  - (none)
- **Returns:** a new Matrix containing boxed Float values
##### toDoubleMatrix(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix toDoubleMatrix()`
- **Summary:** Converts this float matrix to a double matrix.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleMatrix with converted values
##### zipWith(...) -> FloatMatrix
- **Signature:** `public <E extends Exception> FloatMatrix zipWith(final FloatMatrix matrixB, final Throwables.FloatBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Performs element-wise operation on two matrices using the provided binary operator.
- **Contract:**
  - The matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`FloatMatrix`) — the second matrix
  - `zipFunction` (`Throwables.FloatBinaryOperator<E>`) — the binary operator to apply element-wise
- **Returns:** a new FloatMatrix with the results of the element-wise operation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
  - `E` — if the zip function throws an exception
- **Signature:** `public <E extends Exception> FloatMatrix zipWith(final FloatMatrix matrixB, final FloatMatrix matrixC, final Throwables.FloatTernaryOperator<E> zipFunction) throws E`
- **Summary:** Performs element-wise operation on three matrices using the provided ternary operator.
- **Contract:**
  - All matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`FloatMatrix`) — the second matrix
  - `matrixC` (`FloatMatrix`) — the third matrix
  - `zipFunction` (`Throwables.FloatTernaryOperator<E>`) — the ternary operator to apply element-wise
- **Returns:** a new FloatMatrix with the results of the element-wise operation
- **Throws:**
  - `E` — if the zip function throws an exception
##### streamLU2RD(...) -> FloatStream
- **Signature:** `@Override public FloatStream streamLU2RD()`
- **Summary:** Returns a stream of elements on the main diagonal (left-up to right-down).
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - (none)
- **Returns:** a FloatStream of diagonal elements
##### streamRU2LD(...) -> FloatStream
- **Signature:** `@Override public FloatStream streamRU2LD()`
- **Summary:** Returns a stream of elements on the anti-diagonal (right-up to left-down).
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - (none)
- **Returns:** a FloatStream of anti-diagonal elements
##### streamH(...) -> FloatStream
- **Signature:** `@Override public FloatStream streamH()`
- **Summary:** Returns a stream of all elements in row-major order (horizontal).
- **Parameters:**
  - (none)
- **Returns:** a FloatStream of all elements in row-major order
- **Signature:** `@Override public FloatStream streamH(final int rowIndex)`
- **Summary:** Returns a stream of elements from a single row.
- **Parameters:**
  - `rowIndex` (`int`) — the row index (0-based)
- **Returns:** a FloatStream of elements from the specified row
- **Signature:** `@Override public FloatStream streamH(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of elements from a range of rows in row-major order.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a FloatStream of elements from the specified row range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
##### streamV(...) -> FloatStream
- **Signature:** `@Override @Beta public FloatStream streamV()`
- **Summary:** Returns a stream of all elements in column-major order (vertical).
- **Parameters:**
  - (none)
- **Returns:** a FloatStream of all elements in column-major order
- **Signature:** `@Override public FloatStream streamV(final int columnIndex)`
- **Summary:** Returns a stream of elements from a single column.
- **Parameters:**
  - `columnIndex` (`int`) — the column index (0-based)
- **Returns:** a FloatStream of elements from the specified column
- **Signature:** `@Override @Beta public FloatStream streamV(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of elements from a range of columns in column-major order.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a FloatStream of elements from the specified column range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
##### streamR(...) -> Stream<FloatStream>
- **Signature:** `@Override public Stream<FloatStream> streamR()`
- **Summary:** Returns a stream where each element is a FloatStream representing a row.
- **Parameters:**
  - (none)
- **Returns:** a Stream of FloatStream, one for each row
- **Signature:** `@Override public Stream<FloatStream> streamR(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of FloatStream for a range of rows.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a Stream of FloatStream for the specified row range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
##### streamC(...) -> Stream<FloatStream>
- **Signature:** `@Override @Beta public Stream<FloatStream> streamC()`
- **Summary:** Returns a stream where each element is a FloatStream representing a column.
- **Parameters:**
  - (none)
- **Returns:** a Stream of FloatStream, one for each column
- **Signature:** `@Override @Beta public Stream<FloatStream> streamC(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of FloatStream for a range of columns.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a Stream of FloatStream for the specified column range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.FloatConsumer<E> action) throws E`
- **Summary:** Applies a consumer function to each element in the matrix.
- **Parameters:**
  - `action` (`Throwables.FloatConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the action throws an exception
- **Signature:** `public <E extends Exception> void forEach(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.FloatConsumer<E> action) throws IndexOutOfBoundsException, E`
- **Summary:** Applies a consumer function to elements in a specified submatrix region.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
  - `action` (`Throwables.FloatConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
  - `E` — if the action throws an exception
##### println(...) -> String
- **Signature:** `@Override public String println()`
- **Summary:** Prints the matrix to standard output in a formatted manner.
- **Parameters:**
  - (none)
- **Returns:** the formatted string representation of the matrix
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this matrix.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this matrix
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this matrix to the specified object for equality.
- **Contract:**
  - Returns {@code true} if the given object is also a FloatMatrix with the same dimensions and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the objects are equal, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this matrix

### Class FloatTuple (com.landawn.abacus.util.FloatTuple)
Abstract base class for immutable tuple implementations that hold primitive float values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> FloatTuple1
- **Signature:** `public static FloatTuple1 of(final float _1)`
- **Summary:** Creates a FloatTuple.FloatTuple1 containing a single float value.
- **Parameters:**
  - `_1` (`float`) — the float value to wrap in a tuple
- **Returns:** a new FloatTuple.FloatTuple1 containing the provided value
- **Signature:** `public static FloatTuple2 of(final float _1, final float _2)`
- **Summary:** Creates a FloatTuple.FloatTuple2 containing two float values.
- **Parameters:**
  - `_1` (`float`) — the first float value
  - `_2` (`float`) — the second float value
- **Returns:** a new FloatTuple.FloatTuple2 containing the provided values
- **Signature:** `public static FloatTuple3 of(final float _1, final float _2, final float _3)`
- **Summary:** Creates a FloatTuple.FloatTuple3 containing three float values.
- **Parameters:**
  - `_1` (`float`) — the first float value
  - `_2` (`float`) — the second float value
  - `_3` (`float`) — the third float value
- **Returns:** a new FloatTuple.FloatTuple3 containing the provided values
- **Signature:** `public static FloatTuple4 of(final float _1, final float _2, final float _3, final float _4)`
- **Summary:** Creates a FloatTuple.FloatTuple4 containing four float values.
- **Parameters:**
  - `_1` (`float`) — the first float value
  - `_2` (`float`) — the second float value
  - `_3` (`float`) — the third float value
  - `_4` (`float`) — the fourth float value
- **Returns:** a new FloatTuple.FloatTuple4 containing the provided values
- **Signature:** `public static FloatTuple5 of(final float _1, final float _2, final float _3, final float _4, final float _5)`
- **Summary:** Creates a FloatTuple.FloatTuple5 containing five float values.
- **Parameters:**
  - `_1` (`float`) — the first float value
  - `_2` (`float`) — the second float value
  - `_3` (`float`) — the third float value
  - `_4` (`float`) — the fourth float value
  - `_5` (`float`) — the fifth float value
- **Returns:** a new FloatTuple.FloatTuple5 containing the provided values
- **Signature:** `public static FloatTuple6 of(final float _1, final float _2, final float _3, final float _4, final float _5, final float _6)`
- **Summary:** Creates a FloatTuple.FloatTuple6 containing six float values.
- **Parameters:**
  - `_1` (`float`) — the first float value
  - `_2` (`float`) — the second float value
  - `_3` (`float`) — the third float value
  - `_4` (`float`) — the fourth float value
  - `_5` (`float`) — the fifth float value
  - `_6` (`float`) — the sixth float value
- **Returns:** a new FloatTuple.FloatTuple6 containing the provided values
- **Signature:** `public static FloatTuple7 of(final float _1, final float _2, final float _3, final float _4, final float _5, final float _6, final float _7)`
- **Summary:** Creates a FloatTuple.FloatTuple7 containing seven float values.
- **Parameters:**
  - `_1` (`float`) — the first float value
  - `_2` (`float`) — the second float value
  - `_3` (`float`) — the third float value
  - `_4` (`float`) — the fourth float value
  - `_5` (`float`) — the fifth float value
  - `_6` (`float`) — the sixth float value
  - `_7` (`float`) — the seventh float value
- **Returns:** a new FloatTuple.FloatTuple7 containing the provided values
- **Signature:** `@Deprecated public static FloatTuple8 of(final float _1, final float _2, final float _3, final float _4, final float _5, final float _6, final float _7, final float _8)`
- **Summary:** Creates a FloatTuple.FloatTuple8 containing eight float values.
- **Parameters:**
  - `_1` (`float`) — the first float value
  - `_2` (`float`) — the second float value
  - `_3` (`float`) — the third float value
  - `_4` (`float`) — the fourth float value
  - `_5` (`float`) — the fifth float value
  - `_6` (`float`) — the sixth float value
  - `_7` (`float`) — the seventh float value
  - `_8` (`float`) — the eighth float value
- **Returns:** a new FloatTuple.FloatTuple8 containing the provided values
- **Signature:** `@Deprecated public static FloatTuple9 of(final float _1, final float _2, final float _3, final float _4, final float _5, final float _6, final float _7, final float _8, final float _9)`
- **Summary:** Creates a FloatTuple.FloatTuple9 containing nine float values.
- **Parameters:**
  - `_1` (`float`) — the first float value
  - `_2` (`float`) — the second float value
  - `_3` (`float`) — the third float value
  - `_4` (`float`) — the fourth float value
  - `_5` (`float`) — the fifth float value
  - `_6` (`float`) — the sixth float value
  - `_7` (`float`) — the seventh float value
  - `_8` (`float`) — the eighth float value
  - `_9` (`float`) — the ninth float value
- **Returns:** a new FloatTuple.FloatTuple9 containing the provided values
##### create(...) -> TP
- **Signature:** `@SuppressWarnings("deprecation") public static <TP extends FloatTuple<TP>> TP create(final float[] values)`
- **Summary:** Creates a FloatTuple from an array of float values.
- **Parameters:**
  - `values` (`float[]`) — the array of float values (must have length 0-9), may be {@code null}
- **Returns:** a FloatTuple of appropriate size containing the array values, or an empty FloatTuple if the array is null or empty

#### Public Instance Methods
##### min(...) -> float
- **Signature:** `public float min()`
- **Summary:** Returns the minimum float value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the minimum float value in this tuple
##### max(...) -> float
- **Signature:** `public float max()`
- **Summary:** Returns the maximum float value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the maximum float value in this tuple
##### median(...) -> float
- **Signature:** `public float median()`
- **Summary:** Returns the median value.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Odd number of elements FloatTuple.FloatTuple3 tuple3 = FloatTuple.of(30.0f, 10.0f, 20.0f); float median = tuple3.median(); // 20.0f (middle value when sorted: 10.0f, 20.0f, 30.0f) // Even number of elements FloatTuple.FloatTuple4 tuple4 = FloatTuple.of(1.0f, 2.0f, 3.0f, 4.0f); float median2 = tuple4.median(); // 2.0f (lower middle value) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median float element in this tuple
##### sum(...) -> float
- **Signature:** `public float sum()`
- **Summary:** Returns the sum of all elements in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the sum of all float values in this tuple
##### average(...) -> double
- **Signature:** `public double average()`
- **Summary:** Returns the average of all float values in this tuple.
- **Contract:**
  - The result is always returned as a double to preserve precision, even when the average is a whole number.
- **Parameters:**
  - (none)
- **Returns:** the average of all float values in this tuple
##### reverse(...) -> TP
- **Signature:** `public abstract TP reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Contract:**
  - For example, a tuple (1.0f, 2.0f, 3.0f) becomes (3.0f, 2.0f, 1.0f) when reversed.
- **Parameters:**
  - (none)
- **Returns:** a new tuple with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `public abstract boolean contains(float valueToFind)`
- **Summary:** Checks if this tuple contains the specified float value.
- **Contract:**
  - Checks if this tuple contains the specified float value.
  - <p> This method performs a linear search through all elements in the tuple to determine if any element matches the specified value.
  - Returns {@code true} if at least one element equals the search value, {@code false} otherwise.
- **Parameters:**
  - `valueToFind` (`float`) — the float value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### toArray(...) -> float\[\]
- **Signature:** `public float[] toArray()`
- **Summary:** Returns a new array containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new float array containing all tuple elements
##### toList(...) -> FloatList
- **Signature:** `public FloatList toList()`
- **Summary:** Returns a new FloatList containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new FloatList containing all tuple elements
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.FloatConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.FloatConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### stream(...) -> FloatStream
- **Signature:** `public FloatStream stream()`
- **Summary:** Returns a FloatStream of all elements in this tuple.
- **Parameters:**
  - (none)
- **Returns:** a FloatStream containing all tuple elements
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this tuple
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Contract:**
  - <p> Two tuples are considered equal if and only if: </p> <ul> <li> They are of the exact same class (e.g., both FloatTuple.FloatTuple2) </li> <li> They contain the same elements in the same order </li> </ul> <p> This method adheres to the general contract of {@link Object#equals(Object)} .
- **Parameters:**
  - `obj` (`Object`) — the object to be compared for equality with this tuple
- **Returns:** {@code true} if the specified object is equal to this tuple, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this tuple

### Class FloatTuple1 (com.landawn.abacus.util.FloatTuple.FloatTuple1)
A FloatTuple containing exactly one float value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 1.
- **Parameters:**
  - (none)
- **Returns:** 1
##### min(...) -> float
- **Signature:** `@Override public float min()`
- **Summary:** Returns the minimum value in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### max(...) -> float
- **Signature:** `@Override public float max()`
- **Summary:** Returns the maximum value in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### median(...) -> float
- **Signature:** `@Override public float median()`
- **Summary:** Returns the median value in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### sum(...) -> float
- **Signature:** `@Override public float sum()`
- **Summary:** Returns the sum of elements in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of elements in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1 as a double
##### reverse(...) -> FloatTuple1
- **Signature:** `@Override public FloatTuple1 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new FloatTuple.FloatTuple1 with the same value
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final float valueToFind)`
- **Summary:** Checks if this tuple contains the specified float value.
- **Contract:**
  - Checks if this tuple contains the specified float value.
- **Parameters:**
  - `valueToFind` (`float`) — the float value to search for
- **Returns:** {@code true} if _1 equals valueToFind, {@code false} otherwise
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on the single element
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both FloatTuple.FloatTuple1 instances and the element is equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a FloatTuple.FloatTuple1 with equal value, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1)"

### Class FloatTuple2 (com.landawn.abacus.util.FloatTuple.FloatTuple2)
A FloatTuple containing exactly two float values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 2.
- **Parameters:**
  - (none)
- **Returns:** 2
##### min(...) -> float
- **Signature:** `@Override public float min()`
- **Summary:** Returns the minimum value among the two elements.
- **Parameters:**
  - (none)
- **Returns:** the smaller of _1 and _2
##### max(...) -> float
- **Signature:** `@Override public float max()`
- **Summary:** Returns the maximum value among the two elements.
- **Parameters:**
  - (none)
- **Returns:** the larger of _1 and _2
##### median(...) -> float
- **Signature:** `@Override public float median()`
- **Summary:** Returns the median float value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the median (lower) float value
##### sum(...) -> float
- **Signature:** `@Override public float sum()`
- **Summary:** Returns the sum of the two elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the two elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2) / 2.0
##### reverse(...) -> FloatTuple2
- **Signature:** `@Override public FloatTuple2 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new FloatTuple.FloatTuple2 with (_2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final float valueToFind)`
- **Summary:** Checks if this tuple contains the specified float value.
- **Contract:**
  - Checks if this tuple contains the specified float value.
- **Parameters:**
  - `valueToFind` (`float`) — the float value to search for
- **Returns:** {@code true} if either element equals valueToFind
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.FloatConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.FloatConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.FloatBiConsumer<E> action) throws E`
- **Summary:** Performs the given bi-consumer action on the two elements of this tuple.
- **Parameters:**
  - `action` (`Throwables.FloatBiConsumer<E>`) — the bi-consumer to perform on the two elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `@MayReturnNull public <U, E extends Exception> U map(final Throwables.FloatBiFunction<U, E> mapper) throws E`
- **Summary:** Applies the given bi-function to the two elements and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.FloatBiFunction<U, E>`) — the bi-function to apply to the two elements
- **Returns:** the result of applying the mapper to _1 and _2
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<FloatTuple2>
- **Signature:** `public <E extends Exception> Optional<FloatTuple2> filter(final Throwables.FloatBiPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Contract:**
  - Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
  - If the predicate returns {@code true} , an Optional containing this tuple is returned.
- **Parameters:**
  - `predicate` (`Throwables.FloatBiPredicate<E>`) — the bi-predicate to test the two elements
- **Returns:** Optional containing this tuple if predicate returns true, empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on both elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both FloatTuple.FloatTuple2 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a FloatTuple.FloatTuple2 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2)"

### Class FloatTuple3 (com.landawn.abacus.util.FloatTuple.FloatTuple3)
A FloatTuple containing exactly three float values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 3.
- **Parameters:**
  - (none)
- **Returns:** 3
##### min(...) -> float
- **Signature:** `@Override public float min()`
- **Summary:** Returns the minimum value among the three elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, and _3
##### max(...) -> float
- **Signature:** `@Override public float max()`
- **Summary:** Returns the maximum value among the three elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, and _3
##### median(...) -> float
- **Signature:** `@Override public float median()`
- **Summary:** Returns the median value of the three elements.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> float
- **Signature:** `@Override public float sum()`
- **Summary:** Returns the sum of the three elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the three elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3) / 3.0
##### reverse(...) -> FloatTuple3
- **Signature:** `@Override public FloatTuple3 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new FloatTuple.FloatTuple3 with (_3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final float valueToFind)`
- **Summary:** Checks if this tuple contains the specified float value.
- **Contract:**
  - Checks if this tuple contains the specified float value.
- **Parameters:**
  - `valueToFind` (`float`) — the float value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.FloatConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.FloatConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.FloatTriConsumer<E> action) throws E`
- **Summary:** Performs the given tri-consumer action on the three elements of this tuple.
- **Parameters:**
  - `action` (`Throwables.FloatTriConsumer<E>`) — the tri-consumer to perform on the three elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `@MayReturnNull public <U, E extends Exception> U map(final Throwables.FloatTriFunction<U, E> mapper) throws E`
- **Summary:** Applies the given tri-function to the three elements and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.FloatTriFunction<U, E>`) — the tri-function to apply to the three elements
- **Returns:** the result of applying the mapper to _1, _2, and _3
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<FloatTuple3>
- **Signature:** `public <E extends Exception> Optional<FloatTuple3> filter(final Throwables.FloatTriPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Contract:**
  - Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
  - If the predicate returns {@code true} , an Optional containing this tuple is returned.
- **Parameters:**
  - `predicate` (`Throwables.FloatTriPredicate<E>`) — the tri-predicate to test the three elements
- **Returns:** Optional containing this tuple if predicate returns true, empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all three elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both FloatTuple.FloatTuple3 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a FloatTuple.FloatTuple3 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3)"

### Class FloatTuple4 (com.landawn.abacus.util.FloatTuple.FloatTuple4)
A FloatTuple containing exactly four float values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 4.
- **Parameters:**
  - (none)
- **Returns:** 4
##### min(...) -> float
- **Signature:** `@Override public float min()`
- **Summary:** Returns the minimum value among the four elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, and _4
##### max(...) -> float
- **Signature:** `@Override public float max()`
- **Summary:** Returns the maximum value among the four elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, and _4
##### median(...) -> float
- **Signature:** `@Override public float median()`
- **Summary:** Returns the median value of the four elements.
- **Parameters:**
  - (none)
- **Returns:** the median float value
##### sum(...) -> float
- **Signature:** `@Override public float sum()`
- **Summary:** Returns the sum of the four elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the four elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4) / 4.0
##### reverse(...) -> FloatTuple4
- **Signature:** `@Override public FloatTuple4 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new FloatTuple.FloatTuple4 with (_4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final float valueToFind)`
- **Summary:** Checks if this tuple contains the specified float value.
- **Contract:**
  - Checks if this tuple contains the specified float value.
- **Parameters:**
  - `valueToFind` (`float`) — the float value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.FloatConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.FloatConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all four elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both FloatTuple.FloatTuple4 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a FloatTuple.FloatTuple4 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4)"

### Class FloatTuple5 (com.landawn.abacus.util.FloatTuple.FloatTuple5)
A FloatTuple containing exactly five float values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 5.
- **Parameters:**
  - (none)
- **Returns:** 5
##### min(...) -> float
- **Signature:** `@Override public float min()`
- **Summary:** Returns the minimum value among the five elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, and _5
##### max(...) -> float
- **Signature:** `@Override public float max()`
- **Summary:** Returns the maximum value among the five elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, and _5
##### median(...) -> float
- **Signature:** `@Override public float median()`
- **Summary:** Returns the median value of the five elements.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> float
- **Signature:** `@Override public float sum()`
- **Summary:** Returns the sum of the five elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the five elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5) / 5.0
##### reverse(...) -> FloatTuple5
- **Signature:** `@Override public FloatTuple5 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new FloatTuple.FloatTuple5 with (_5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final float valueToFind)`
- **Summary:** Checks if this tuple contains the specified float value.
- **Contract:**
  - Checks if this tuple contains the specified float value.
- **Parameters:**
  - `valueToFind` (`float`) — the float value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.FloatConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.FloatConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all five elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both FloatTuple.FloatTuple5 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a FloatTuple.FloatTuple5 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5)"

### Class FloatTuple6 (com.landawn.abacus.util.FloatTuple.FloatTuple6)
A FloatTuple containing exactly six float values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 6.
- **Parameters:**
  - (none)
- **Returns:** 6
##### min(...) -> float
- **Signature:** `@Override public float min()`
- **Summary:** Returns the minimum value among the six elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, and _6
##### max(...) -> float
- **Signature:** `@Override public float max()`
- **Summary:** Returns the maximum value among the six elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, and _6
##### median(...) -> float
- **Signature:** `@Override public float median()`
- **Summary:** Returns the median value of the six elements.
- **Parameters:**
  - (none)
- **Returns:** the median float value
##### sum(...) -> float
- **Signature:** `@Override public float sum()`
- **Summary:** Returns the sum of the six elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the six elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6) / 6.0
##### reverse(...) -> FloatTuple6
- **Signature:** `@Override public FloatTuple6 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new FloatTuple.FloatTuple6 with (_6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final float valueToFind)`
- **Summary:** Checks if this tuple contains the specified float value.
- **Contract:**
  - Checks if this tuple contains the specified float value.
- **Parameters:**
  - `valueToFind` (`float`) — the float value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.FloatConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.FloatConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all six elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both FloatTuple.FloatTuple6 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a FloatTuple.FloatTuple6 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6)"

### Class FloatTuple7 (com.landawn.abacus.util.FloatTuple.FloatTuple7)
A FloatTuple containing exactly seven float values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 7.
- **Parameters:**
  - (none)
- **Returns:** 7
##### min(...) -> float
- **Signature:** `@Override public float min()`
- **Summary:** Returns the minimum value among the seven elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, _6, and _7
##### max(...) -> float
- **Signature:** `@Override public float max()`
- **Summary:** Returns the maximum value among the seven elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, _6, and _7
##### median(...) -> float
- **Signature:** `@Override public float median()`
- **Summary:** Returns the median value of the seven elements.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> float
- **Signature:** `@Override public float sum()`
- **Summary:** Returns the sum of the seven elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the seven elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7) / 7.0
##### reverse(...) -> FloatTuple7
- **Signature:** `@Override public FloatTuple7 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new FloatTuple.FloatTuple7 with (_7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final float valueToFind)`
- **Summary:** Checks if this tuple contains the specified float value.
- **Contract:**
  - Checks if this tuple contains the specified float value.
- **Parameters:**
  - `valueToFind` (`float`) — the float value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.FloatConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.FloatConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all seven elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both FloatTuple.FloatTuple7 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a FloatTuple.FloatTuple7 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7)"

### Class FloatTuple8 (com.landawn.abacus.util.FloatTuple.FloatTuple8)
A FloatTuple containing exactly eight float values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 8.
- **Parameters:**
  - (none)
- **Returns:** 8
##### min(...) -> float
- **Signature:** `@Override public float min()`
- **Summary:** Returns the minimum value among the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, _6, _7, and _8
##### max(...) -> float
- **Signature:** `@Override public float max()`
- **Summary:** Returns the maximum value among the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, _6, _7, and _8
##### median(...) -> float
- **Signature:** `@Override public float median()`
- **Summary:** Returns the median value of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the median float value
##### sum(...) -> float
- **Signature:** `@Override public float sum()`
- **Summary:** Returns the sum of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7 + _8) / 8.0
##### reverse(...) -> FloatTuple8
- **Signature:** `@Override public FloatTuple8 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new FloatTuple.FloatTuple8 with (_8, _7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final float valueToFind)`
- **Summary:** Checks if this tuple contains the specified float value.
- **Contract:**
  - Checks if this tuple contains the specified float value.
- **Parameters:**
  - `valueToFind` (`float`) — the float value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.FloatConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.FloatConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all eight elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both FloatTuple.FloatTuple8 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a FloatTuple.FloatTuple8 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7, _8)"

### Class FloatTuple9 (com.landawn.abacus.util.FloatTuple.FloatTuple9)
A FloatTuple containing exactly nine float values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 9.
- **Parameters:**
  - (none)
- **Returns:** 9
##### min(...) -> float
- **Signature:** `@Override public float min()`
- **Summary:** Returns the minimum value among the nine elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, _6, _7, _8, and _9
##### max(...) -> float
- **Signature:** `@Override public float max()`
- **Summary:** Returns the maximum value among the nine elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, _6, _7, _8, and _9
##### median(...) -> float
- **Signature:** `@Override public float median()`
- **Summary:** Returns the median value of the nine elements.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> float
- **Signature:** `@Override public float sum()`
- **Summary:** Returns the sum of the nine elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 + _9
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the nine elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 + _9) / 9.0
##### reverse(...) -> FloatTuple9
- **Signature:** `@Override public FloatTuple9 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new FloatTuple.FloatTuple9 with (_9, _8, _7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final float valueToFind)`
- **Summary:** Checks if this tuple contains the specified float value.
- **Contract:**
  - Checks if this tuple contains the specified float value.
- **Parameters:**
  - `valueToFind` (`float`) — the float value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.FloatConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.FloatConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all nine elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both FloatTuple.FloatTuple9 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a FloatTuple.FloatTuple9 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7, _8, _9)"

### Class ImmutableIntArray (com.landawn.abacus.util.ImmutableIntArray)
An immutable wrapper for primitive int arrays that provides a read-only view of the underlying array.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ImmutableIntArray
- **Signature:** `public static ImmutableIntArray of(final int[] array)`
- **Summary:** Creates an ImmutableIntArray that wraps the provided int array without copying.
- **Contract:**
  - For true immutability, the caller must not modify the original array after passing it to this method.
  - If the source array might be modified externally, use {@link #copyOf(int\[\])} instead.
  - </p> <p> This method is more efficient than {@link #copyOf(int\[\])} when you know the array will not be modified, as it avoids the overhead of array copying.
- **Parameters:**
  - `array` (`int[]`) — the int array to wrap, or {@code null} to create an empty ImmutableIntArray
- **Returns:** an ImmutableIntArray wrapping the provided array, or an empty ImmutableIntArray if the input is {@code null}
- **See also:** #copyOf(int\[\])
##### copyOf(...) -> ImmutableIntArray
- **Signature:** `public static ImmutableIntArray copyOf(final int[] array)`
- **Summary:** Creates an ImmutableIntArray containing a defensive copy of the provided array.
- **Contract:**
  - This is the recommended factory method when the source array might be modified after creating the ImmutableIntArray, or when you need guaranteed immutability.
- **Parameters:**
  - `array` (`int[]`) — the int array to copy, or {@code null} to create an empty ImmutableIntArray
- **Returns:** a new ImmutableIntArray containing a defensive copy of the provided array, or an empty ImmutableIntArray if the input is {@code null}
- **See also:** #of(int\[\])

#### Public Instance Methods
##### get(...) -> int
- **Signature:** `public int get(final int index)`
- **Summary:** Returns the int element at the specified index in this ImmutableIntArray.
- **Parameters:**
  - `index` (`int`) — the zero-based index of the element to retrieve (must be {@code >= 0 and < length} )
- **Returns:** the int element at the specified index
- **Performance:** <p> This method provides constant-time O(1) access to elements by index.
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.IntConsumer<E> action) throws IllegalArgumentException, E`
- **Summary:** Performs the given action for each element in this ImmutableIntArray.
- **Parameters:**
  - `action` (`Throwables.IntConsumer<E>`) — the action to be performed for each element, must not be {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code action} is {@code null}
  - `E` — if the action throws an exception during execution
##### forEachIndexed(...) -> void
- **Signature:** `public <E extends Exception> void forEachIndexed(final Throwables.IntIntConsumer<E> action) throws IllegalArgumentException, E`
- **Summary:** Performs the given action for each element in this ImmutableIntArray, providing both the index and value.
- **Contract:**
  - </p> <p> This method is useful when you need to know the position of each element during iteration, such as for creating index-based mappings or when the index is needed for computation.
- **Parameters:**
  - `action` (`Throwables.IntIntConsumer<E>`) — the action to be performed for each element, receiving the index (first parameter) and value (second parameter) as primitive ints, must not be {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code action} is {@code null}
  - `E` — if the action throws an exception during execution
##### stream(...) -> IntStream
- **Signature:** `public IntStream stream()`
- **Summary:** Returns an IntStream containing all elements of this ImmutableIntArray.
- **Parameters:**
  - (none)
- **Returns:** an IntStream containing all elements of this ImmutableIntArray in order
##### copy(...) -> ImmutableIntArray
- **Signature:** `public ImmutableIntArray copy(final int fromIndex, final int toIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a new ImmutableIntArray containing a copy of the elements in the specified range.
- **Parameters:**
  - `fromIndex` (`int`) — the starting index (inclusive) of the range to copy (must be {@code >= 0} )
  - `toIndex` (`int`) — the ending index (exclusive) of the range to copy (must be {@code <= length} )
- **Returns:** a new ImmutableIntArray containing a copy of the elements in the specified range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if {@code fromIndex < 0} , {@code toIndex > length} , or {@code fromIndex > toIndex}
- **See also:** #copyToArray(int, int)
##### copyToArray(...) -> int\[\]
- **Signature:** `public int[] copyToArray(final int fromIndex, final int toIndex) throws IndexOutOfBoundsException`
- **Summary:** Copies the elements in the specified range to a new mutable primitive int array.
- **Contract:**
  - This is useful when you need to perform mutations on the copied data or when interfacing with APIs that require primitive arrays.
- **Parameters:**
  - `fromIndex` (`int`) — the starting index (inclusive) of the range to copy (must be {@code >= 0} )
  - `toIndex` (`int`) — the ending index (exclusive) of the range to copy (must be {@code <= length} )
- **Returns:** a new mutable int array containing the specified range of elements
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if {@code fromIndex < 0} , {@code toIndex > length} , or {@code fromIndex > toIndex}
- **See also:** #copy(int, int)
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this ImmutableIntArray.
- **Contract:**
  - </p> <p> This method satisfies the general contract of {@link Object#hashCode()} : if two ImmutableIntArray instances are equal according to {@link #equals(Object)} , then calling this method on each will produce the same integer result.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this ImmutableIntArray based on its contents
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this ImmutableIntArray with the specified object for equality.
- **Contract:**
  - <p> Returns {@code true} if and only if the specified object is also an ImmutableIntArray and both arrays contain the same elements in the same order.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with this ImmutableIntArray
- **Returns:** {@code true} if the specified object is an ImmutableIntArray with the same elements in the same order; {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this ImmutableIntArray.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this ImmutableIntArray in the format {@code "\[element1, element2, ...\]"}

### Class IntMatrix (com.landawn.abacus.util.IntMatrix)
A matrix implementation for int primitive values, providing efficient storage and operations for two-dimensional int arrays.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### empty(...) -> IntMatrix
- **Signature:** `public static IntMatrix empty()`
- **Summary:** Creates an empty matrix with zero rows and zero columns.
- **Parameters:**
  - (none)
- **Returns:** an empty int matrix
##### of(...) -> IntMatrix
- **Signature:** `public static IntMatrix of(final int[]... a)`
- **Summary:** Creates an IntMatrix from a two-dimensional int array.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional int array to create the matrix from, or null/empty for an empty matrix
- **Returns:** a new IntMatrix containing the provided data, or an empty IntMatrix if input is null or empty
##### from(...) -> IntMatrix
- **Signature:** `public static IntMatrix from(final char[]... a)`
- **Summary:** Creates an IntMatrix from a two-dimensional char array by converting char values to int (using their ASCII/Unicode values).
- **Contract:**
  - <p> All rows must have the same length as the first row (rectangular array required).
- **Parameters:**
  - `a` (`char[][]`) — the two-dimensional char array to convert to an int matrix, or null/empty for an empty matrix
- **Returns:** a new IntMatrix with converted values, or an empty IntMatrix if input is null or empty
- **Signature:** `public static IntMatrix from(final byte[]... a)`
- **Summary:** Creates an IntMatrix from a two-dimensional byte array by converting byte values to int.
- **Contract:**
  - <p> All rows must have the same length as the first row (rectangular array required).
- **Parameters:**
  - `a` (`byte[][]`) — the two-dimensional byte array to convert to an int matrix, or null/empty for an empty matrix
- **Returns:** a new IntMatrix with converted values, or an empty IntMatrix if input is null or empty
- **Signature:** `public static IntMatrix from(final short[]... a)`
- **Summary:** Creates an IntMatrix from a two-dimensional short array by converting short values to int.
- **Contract:**
  - <p> All rows must have the same length as the first row (rectangular array required).
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional short array to convert to an int matrix, or null/empty for an empty matrix
- **Returns:** a new IntMatrix with converted values, or an empty IntMatrix if input is null or empty
##### random(...) -> IntMatrix
- **Signature:** `public static IntMatrix random(final int size)`
- **Summary:** Creates a new 1xsize matrix filled with random int values.
- **Parameters:**
  - `size` (`int`) — the number of columns in the new matrix
- **Returns:** a new IntMatrix of dimensions 1 x size filled with random values
- **Signature:** `public static IntMatrix random(final int rowCount, final int columnCount)`
- **Summary:** Creates a new matrix of the specified dimensions filled with random int values.
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
- **Returns:** a new IntMatrix of dimensions rowCount x columnCount filled with random values
##### repeat(...) -> IntMatrix
- **Signature:** `public static IntMatrix repeat(final int rowCount, final int columnCount, final int element)`
- **Summary:** Creates a new matrix of the specified dimensions where every element is the provided {@code element} .
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
  - `element` (`int`) — the int value to fill the matrix with
- **Returns:** a new IntMatrix of dimensions rowCount x columnCount filled with the specified element
##### range(...) -> IntMatrix
- **Signature:** `public static IntMatrix range(final int startInclusive, final int endExclusive)`
- **Summary:** Creates a 1-row IntMatrix with values from startInclusive to endExclusive.
- **Contract:**
  - If {@code startInclusive >= endExclusive} , an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`int`) — the starting value (inclusive)
  - `endExclusive` (`int`) — the ending value (exclusive)
- **Returns:** a new 1×n IntMatrix where n = max(0, endExclusive - startInclusive)
- **Signature:** `public static IntMatrix range(final int startInclusive, final int endExclusive, final int by)`
- **Summary:** Creates a 1-row IntMatrix with values from startInclusive to endExclusive with the specified step.
- **Contract:**
  - If the step would not reach endExclusive from startInclusive, an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`int`) — the starting value (inclusive)
  - `endExclusive` (`int`) — the ending value (exclusive)
  - `by` (`int`) — the step size (must not be zero; can be positive or negative)
- **Returns:** a new 1×n IntMatrix with values incremented by the step size
##### rangeClosed(...) -> IntMatrix
- **Signature:** `public static IntMatrix rangeClosed(final int startInclusive, final int endInclusive)`
- **Summary:** Creates a 1-row IntMatrix with values from startInclusive to endInclusive.
- **Contract:**
  - If {@code startInclusive > endInclusive} , an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`int`) — the starting value (inclusive)
  - `endInclusive` (`int`) — the ending value (inclusive)
- **Returns:** a new 1×n IntMatrix where n = max(0, endInclusive - startInclusive + 1)
- **Signature:** `public static IntMatrix rangeClosed(final int startInclusive, final int endInclusive, final int by)`
- **Summary:** Creates a 1-row IntMatrix with values from startInclusive to endInclusive with the specified step.
- **Contract:**
  - The end value is included only if it is reachable by stepping from start.
  - If the step would not reach endInclusive from startInclusive, an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`int`) — the starting value (inclusive)
  - `endInclusive` (`int`) — the ending value (inclusive, if reachable by stepping)
  - `by` (`int`) — the step size (must not be zero; can be positive or negative)
- **Returns:** a new 1×n IntMatrix with values incremented by the step size
##### diagonalLU2RD(...) -> IntMatrix
- **Signature:** `public static IntMatrix diagonalLU2RD(final int[] leftUp2RightDownDiagonal)`
- **Summary:** Creates a square matrix from the specified main diagonal elements.
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`int[]`) — the array of diagonal elements
- **Returns:** a square matrix with the specified main diagonal
##### diagonalRU2LD(...) -> IntMatrix
- **Signature:** `public static IntMatrix diagonalRU2LD(final int[] rightUp2LeftDownDiagonal)`
- **Summary:** Creates a square matrix from the specified anti-diagonal elements.
- **Parameters:**
  - `rightUp2LeftDownDiagonal` (`int[]`) — the array of anti-diagonal elements
- **Returns:** a square matrix with the specified anti-diagonal
##### diagonal(...) -> IntMatrix
- **Signature:** `public static IntMatrix diagonal(final int[] leftUp2RightDownDiagonal, final int[] rightUp2LeftDownDiagonal) throws IllegalArgumentException`
- **Summary:** Creates a square matrix from the specified main diagonal and anti-diagonal elements.
- **Contract:**
  - If both arrays are provided, they must have the same length.
  - The resulting matrix has dimensions n×n where n is the length of the non-null/non-empty array (or the maximum length if both are provided).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`int[]`) — the array of main diagonal elements (can be null or empty)
  - `rightUp2LeftDownDiagonal` (`int[]`) — the array of anti-diagonal elements (can be null or empty)
- **Returns:** a square matrix with the specified diagonals, or an empty matrix if both inputs are null or empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — if both arrays are non-empty and have different lengths
##### unbox(...) -> IntMatrix
- **Signature:** `public static IntMatrix unbox(final Matrix<Integer> x)`
- **Summary:** Converts a boxed Integer Matrix to a primitive IntMatrix.
- **Parameters:**
  - `x` (`Matrix<Integer>`) — the boxed Integer matrix to convert
- **Returns:** a new IntMatrix with primitive int values

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public IntMatrix(final int[][] a)`
- **Summary:** Constructs a IntMatrix from a two-dimensional int array.
- **Contract:**
  - If the input array is null, an empty matrix (0x0) is created.
  - If you need an independent copy, use {@link #copy()} after construction.
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional int array to wrap as a matrix. Can be null, which creates an empty matrix.
##### componentType(...) -> Class
- **Signature:** `@SuppressWarnings("rawtypes") @Override public Class componentType()`
- **Summary:** Returns the component type of the matrix elements, which is always {@code int.class} .
- **Parameters:**
  - (none)
- **Returns:** {@code int.class}
##### get(...) -> int
- **Signature:** `public int get(final int i, final int j)`
- **Summary:** Returns the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** the element at position (rowIndex, columnIndex)
- **Signature:** `public int get(final Point point)`
- **Summary:** Returns the element at the specified Sheet.Point.
- **Parameters:**
  - `point` (`Point`)
- **Returns:** the int element at the specified Sheet.Point
- **See also:** #get(int, int)
##### set(...) -> void
- **Signature:** `public void set(final int i, final int j, final int val)`
- **Summary:** Sets the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
  - `val` (`int`) — the value to set
- **Signature:** `public void set(final Point point, final int val)`
- **Summary:** Sets the element at the specified Sheet.Point to the given value.
- **Parameters:**
  - `point` (`Point`)
  - `val` (`int`) — the new int value to set at the specified Sheet.Point
- **See also:** #set(int, int, int)
##### upOf(...) -> OptionalInt
- **Signature:** `public OptionalInt upOf(final int i, final int j)`
- **Summary:** Returns the element above the specified position, if it exists.
- **Contract:**
  - Returns the element above the specified position, if it exists.
  - This method provides safe access to the element directly above the given position without throwing an exception when at the top edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalInt containing the element at position (rowIndex - 1, columnIndex), or empty if rowIndex == 0
##### downOf(...) -> OptionalInt
- **Signature:** `public OptionalInt downOf(final int i, final int j)`
- **Summary:** Returns the element below the specified position, if it exists.
- **Contract:**
  - Returns the element below the specified position, if it exists.
  - This method provides safe access to the element directly below the given position without throwing an exception when at the bottom edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalInt containing the element at position (rowIndex + 1, columnIndex), or empty if rowIndex == rowCount - 1
##### leftOf(...) -> OptionalInt
- **Signature:** `public OptionalInt leftOf(final int i, final int j)`
- **Summary:** Returns the element to the left of the specified position, if it exists.
- **Contract:**
  - Returns the element to the left of the specified position, if it exists.
  - This method provides safe access to the element directly to the left of the given position without throwing an exception when at the leftmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalInt containing the element at position (rowIndex, columnIndex - 1), or empty if columnIndex == 0
##### rightOf(...) -> OptionalInt
- **Signature:** `public OptionalInt rightOf(final int i, final int j)`
- **Summary:** Returns the element to the right of the specified position, if it exists.
- **Contract:**
  - Returns the element to the right of the specified position, if it exists.
  - This method provides safe access to the element directly to the right of the given position without throwing an exception when at the rightmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalInt containing the element at position (rowIndex, columnIndex + 1), or empty if columnIndex == columnCount - 1
##### row(...) -> int\[\]
- **Signature:** `public int[] row(final int rowIndex) throws IllegalArgumentException`
- **Summary:** Returns the specified row as an int array.
- **Contract:**
  - If you need an independent copy, use {@code Arrays.copyOf(matrix.row(i), matrix.columnCount())} .
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to retrieve (0-based)
- **Returns:** the specified row array (direct reference to internal storage)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex &lt; 0 or rowIndex &gt; = rowCount
##### column(...) -> int\[\]
- **Signature:** `public int[] column(final int columnIndex) throws IllegalArgumentException`
- **Summary:** Returns a copy of the specified column as a new int array.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to retrieve (0-based)
- **Returns:** a new array containing the values from the specified column
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex &lt; 0 or columnIndex &gt; = columnCount
##### setRow(...) -> void
- **Signature:** `public void setRow(final int rowIndex, final int[] row) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified row by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of columns in the matrix.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to set (0-based)
  - `row` (`int[]`) — the array of values to copy into the row; must have length equal to the number of columns
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex is out of bounds or row length does not match column count
##### setColumn(...) -> void
- **Signature:** `public void setColumn(final int columnIndex, final int[] column) throws IllegalArgumentException, ArrayIndexOutOfBoundsException`
- **Summary:** Sets the values of the specified column by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of rows in the matrix.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to set (0-based)
  - `column` (`int[]`) — the array of values to copy into the column; must have length equal to the number of rows
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex is out of bounds or column length does not match row count
  - `java.lang.ArrayIndexOutOfBoundsException` — if the underlying wrapped array has been externally modified into a non-rectangular shape
##### updateRow(...) -> void
- **Signature:** `public <E extends Exception> void updateRow(final int rowIndex, final Throwables.IntUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a row in-place by applying the specified operator to each element.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to update (0-based)
  - `operator` (`Throwables.IntUnaryOperator<E>`) — the operator to apply to each element in the row; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### updateColumn(...) -> void
- **Signature:** `public <E extends Exception> void updateColumn(final int columnIndex, final Throwables.IntUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a column in-place by applying the specified operator to each element.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to update (0-based)
  - `operator` (`Throwables.IntUnaryOperator<E>`) — the operator to apply to each element in the column; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### getLU2RD(...) -> int\[\]
- **Signature:** `public int[] getLU2RD() throws IllegalStateException`
- **Summary:** Returns a copy of the elements on the main diagonal from left-upper to right-down.
- **Contract:**
  - The matrix must be square (rowCount == columnCount) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new int array containing a copy of the main diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rowCount != columnCount)
##### setLU2RD(...) -> void
- **Signature:** `public void setLU2RD(final int[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the main diagonal from left-upper to right-down (main diagonal).
- **Contract:**
  - The matrix must be square (rowCount == columnCount), and the diagonal array must have exactly as many elements as the matrix has rows.
- **Parameters:**
  - `diagonal` (`int[]`) — the new values for the main diagonal; must have length equal to rowCount
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rowCount != columnCount)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal to rowCount
##### updateLU2RD(...) -> void
- **Signature:** `public <E extends Exception> void updateLU2RD(final Throwables.IntUnaryOperator<E> operator) throws IllegalStateException, E`
- **Summary:** Updates the values on the main diagonal (left-up to right-down) by applying the specified operator.
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - `operator` (`Throwables.IntUnaryOperator<E>`) — the operator to apply to each diagonal element; receives current element value and returns new value
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square
  - `E` — if the operator throws an exception
##### getRU2LD(...) -> int\[\]
- **Signature:** `public int[] getRU2LD() throws IllegalStateException`
- **Summary:** Returns a copy of the elements on the anti-diagonal from right-upper to left-down.
- **Contract:**
  - The matrix must be square (rowCount == columnCount) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new int array containing a copy of the anti-diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rowCount != columnCount)
##### setRU2LD(...) -> void
- **Signature:** `public void setRU2LD(final int[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the anti-diagonal from right-upper to left-down (anti-diagonal).
- **Contract:**
  - The matrix must be square (rowCount == columnCount), and the diagonal array must have exactly as many elements as the matrix has rows.
- **Parameters:**
  - `diagonal` (`int[]`) — the new values for the anti-diagonal; must have length equal to rowCount
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rowCount != columnCount)
  - `java.lang.IllegalArgumentException` — if diagonal array length != rowCount
##### updateRU2LD(...) -> void
- **Signature:** `public <E extends Exception> void updateRU2LD(final Throwables.IntUnaryOperator<E> operator) throws IllegalStateException, E`
- **Summary:** Updates the values on the anti-diagonal (right-up to left-down) by applying the specified operator.
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - `operator` (`Throwables.IntUnaryOperator<E>`) — the operator to apply to each anti-diagonal element; receives current element value and returns new value
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square
  - `E` — if the operator throws an exception
##### updateAll(...) -> void
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.IntUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the matrix in-place by applying the specified operator.
- **Contract:**
  - Elements are processed in row-major order when executed sequentially.
- **Parameters:**
  - `operator` (`Throwables.IntUnaryOperator<E>`) — the operator to apply to each element; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.IntBiFunction<Integer, E> operator) throws E`
- **Summary:** Updates all elements in the matrix in-place based on their position (row and column indices).
- **Parameters:**
  - `operator` (`Throwables.IntBiFunction<Integer, E>`) — the operator that receives row index and column index (0-based) and returns the new value for that position
- **Throws:**
  - `E` — if the operator throws an exception
##### replaceIf(...) -> void
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.IntPredicate<E> predicate, final int newValue) throws E`
- **Summary:** Conditionally replaces elements in-place based on a predicate.
- **Parameters:**
  - `predicate` (`Throwables.IntPredicate<E>`) — the condition to test each element; elements for which this returns {@code true} will be replaced
  - `newValue` (`int`) — the value to use for replacing matching elements
- **Throws:**
  - `E` — if the predicate throws an exception
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.IntBiPredicate<E> predicate, final int newValue) throws E`
- **Summary:** Conditionally replaces elements in-place based on their position (row and column indices).
- **Parameters:**
  - `predicate` (`Throwables.IntBiPredicate<E>`) — the condition that tests row index and column index (0-based); elements at positions for which this returns {@code true} will be replaced
  - `newValue` (`int`) — the value to use for replacing matching elements
- **Throws:**
  - `E` — if the predicate throws an exception
##### map(...) -> IntMatrix
- **Signature:** `public <E extends Exception> IntMatrix map(final Throwables.IntUnaryOperator<E> mapper) throws E`
- **Summary:** Creates a new IntMatrix by applying a transformation function to each element.
- **Parameters:**
  - `mapper` (`Throwables.IntUnaryOperator<E>`) — the function to apply to each element; receives the current element value and returns the transformed value
- **Returns:** a new IntMatrix with transformed values
- **Throws:**
  - `E` — if the function throws an exception
- **See also:** #updateAll(Throwables.IntUnaryOperator)
##### mapToLong(...) -> LongMatrix
- **Signature:** `public <E extends Exception> LongMatrix mapToLong(final Throwables.IntToLongFunction<E> mapper) throws E`
- **Summary:** Creates a new LongMatrix by applying a function that converts int values to long.
- **Parameters:**
  - `mapper` (`Throwables.IntToLongFunction<E>`) — the function to convert int values to long
- **Returns:** a new LongMatrix with converted values
- **Throws:**
  - `E` — if the function throws an exception
##### mapToDouble(...) -> DoubleMatrix
- **Signature:** `public <E extends Exception> DoubleMatrix mapToDouble(final Throwables.IntToDoubleFunction<E> mapper) throws E`
- **Summary:** Creates a new DoubleMatrix by applying a function that converts int values to double.
- **Parameters:**
  - `mapper` (`Throwables.IntToDoubleFunction<E>`) — the function to convert int values to double
- **Returns:** a new DoubleMatrix with converted values
- **Throws:**
  - `E` — if the function throws an exception
##### mapToObj(...) -> Matrix<T>
- **Signature:** `public <T, E extends Exception> Matrix<T> mapToObj(final Throwables.IntFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Creates a new Matrix by applying a function that converts int values to objects of type T.
- **Parameters:**
  - `mapper` (`Throwables.IntFunction<? extends T, E>`) — the function to convert int values to type T
  - `targetElementType` (`Class<T>`) — the Class object for type T
- **Returns:** a new Matrix containing the converted values
- **Throws:**
  - `E` — if the function throws an exception
##### fill(...) -> void
- **Signature:** `public void fill(final int val)`
- **Summary:** Fills all elements of the matrix with the specified value.
- **Parameters:**
  - `val` (`int`) — the value to fill the matrix with
- **Signature:** `public void fill(final int[][] b)`
- **Summary:** Fills the matrix with values from another two-dimensional array, starting at position (0, 0).
- **Contract:**
  - If the source array is larger, only the portion that fits is copied.
- **Parameters:**
  - `b` (`int[][]`) — the two-dimensional array to copy values from
- **Signature:** `public void fill(final int fromRowIndex, final int fromColumnIndex, final int[][] b) throws IllegalArgumentException`
- **Summary:** Fills a region of the matrix with values from another two-dimensional array, starting at the specified position.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index in this matrix (0-based, must be 0 &lt; = fromRowIndex &lt; = rowCount)
  - `fromColumnIndex` (`int`) — the starting column index in this matrix (0-based, must be 0 &lt; = fromColumnIndex &lt; = columnCount)
  - `b` (`int[][]`) — the source array to copy values from
- **Throws:**
  - `java.lang.IllegalArgumentException` — if fromRowIndex &lt; 0 or &gt; rowCount, or if fromColumnIndex &lt; 0 or &gt; columnCount
##### copy(...) -> IntMatrix
- **Signature:** `@Override public IntMatrix copy()`
- **Summary:** Returns a copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is a deep copy of this matrix with full independence guarantee
- **Signature:** `@Override public IntMatrix copy(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a row range from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a new IntMatrix containing the specified rows
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
- **Signature:** `@Override public IntMatrix copy(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a submatrix defined by row and column ranges.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a new IntMatrix containing the specified submatrix
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
##### extend(...) -> IntMatrix
- **Signature:** `public IntMatrix extend(final int newRowCount, final int newColumnCount)`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with 0.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
- **Returns:** a new IntMatrix with the specified dimensions
- **Signature:** `public IntMatrix extend(final int newRowCount, final int newColumnCount, final int defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated from the top-left corner.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with the specified default value.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
  - `defaultValueForNewCell` (`int`) — the int value to fill new cells with during extension
- **Returns:** a new IntMatrix with the specified dimensions
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code newRowCount} or {@code newColumnCount} is negative, or if the resulting matrix would be too large (dimensions exceeding Integer.MAX_VALUE elements)
- **Signature:** `public IntMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight)`
- **Summary:** Creates a new matrix by extending this matrix in all four directions.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
- **Returns:** a new extended IntMatrix with dimensions ((toUp+rowCount+toDown) x (toLeft+columnCount+toRight))
- **Signature:** `public IntMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight, final int defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending this matrix in all four directions with padding.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
  - `defaultValueForNewCell` (`int`) — the int value to fill all new cells with
- **Returns:** a new extended IntMatrix with dimensions ((toUp+rowCount+toDown) x (toLeft+columnCount+toRight))
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any padding parameter is negative, or if the resulting dimensions would exceed Integer.MAX_VALUE
##### reverseH(...) -> void
- **Signature:** `public void reverseH()`
- **Summary:** Reverses the order of elements in each row in-place (horizontal flip).
- **Parameters:**
  - (none)
- **See also:** #flipH(), #reverseV()
##### reverseV(...) -> void
- **Signature:** `public void reverseV()`
- **Summary:** Reverses the order of rows in-place (vertical flip).
- **Parameters:**
  - (none)
- **See also:** #flipV(), #reverseH()
##### flipH(...) -> IntMatrix
- **Signature:** `public IntMatrix flipH()`
- **Summary:** Creates a horizontally flipped copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new IntMatrix with each row reversed
- **See also:** #flipV(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,MATLAB flip function,</a>
##### flipV(...) -> IntMatrix
- **Signature:** `public IntMatrix flipV()`
- **Summary:** Creates a vertically flipped copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new IntMatrix with rows reversed
- **See also:** #flipH(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,MATLAB flip function,</a>
##### rotate90(...) -> IntMatrix
- **Signature:** `@Override public IntMatrix rotate90()`
- **Summary:** Rotates this matrix 90 degrees clockwise.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 90 degrees clockwise
##### rotate180(...) -> IntMatrix
- **Signature:** `@Override public IntMatrix rotate180()`
- **Summary:** Rotates this matrix 180 degrees.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 180 degrees
##### rotate270(...) -> IntMatrix
- **Signature:** `@Override public IntMatrix rotate270()`
- **Summary:** Rotates this matrix 270 degrees clockwise (or 90 degrees counter-clockwise).
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 270 degrees clockwise
##### transpose(...) -> IntMatrix
- **Signature:** `@Override public IntMatrix transpose()`
- **Summary:** Creates the transpose of this matrix by swapping rows and columns.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is the transpose of this matrix with dimensions columnCount × rows
##### reshape(...) -> IntMatrix
- **Signature:** `@SuppressFBWarnings("ICAST_INTEGER_MULTIPLY_CAST_TO_LONG") @Override public IntMatrix reshape(final int newRowCount, final int newColumnCount)`
- **Summary:** Reshapes this matrix to have the specified dimensions.
- **Contract:**
  - If the new shape has fewer elements than the original, excess elements are discarded.
  - If the new shape has more elements, the extra positions are filled with default values (0 for numeric types, false for boolean, null for objects).
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the reshaped matrix (must be non-negative)
  - `newColumnCount` (`int`) — the number of columns in the reshaped matrix (must be non-negative)
- **Returns:** a new IntMatrix with the specified dimensions
##### repelem(...) -> IntMatrix
- **Signature:** `@Override public IntMatrix repelem(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats elements in both row and column directions.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat each element in row direction
  - `colRepeats` (`int`) — number of times to repeat each element in column direction
- **Returns:** a new IntMatrix with repeated elements
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
- **See also:** <a href="https://www.mathworks.com/help/matlab/ref/repelem.html">,MATLAB repelem function,</a>
##### repmat(...) -> IntMatrix
- **Signature:** `@Override public IntMatrix repmat(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats the entire matrix in a tiled pattern.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat the matrix vertically
  - `colRepeats` (`int`) — number of times to repeat the matrix horizontally
- **Returns:** a new IntMatrix with the tiled pattern
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats or colRepeats is not positive
- **See also:** <a href="https://www.mathworks.com/help/matlab/ref/repmat.html">,MATLAB repmat function,</a>
##### flatten(...) -> IntList
- **Signature:** `@Override public IntList flatten()`
- **Summary:** Returns a list containing all matrix elements in row-major order.
- **Parameters:**
  - (none)
- **Returns:** a list of all elements in row-major order
##### flatOp(...) -> void
- **Signature:** `@Override public <E extends Exception> void flatOp(final Throwables.Consumer<? super int[], E> op) throws E`
- **Summary:** Applies an operation to each row array of the matrix.
- **Parameters:**
  - `op` (`Throwables.Consumer<? super int[], E>`) — the operation to apply to each row array
- **Throws:**
  - `E` — if the operation throws an exception
- **See also:** Arrays#flatOp(int\[\]\[\], Throwables.Consumer)
##### vstack(...) -> IntMatrix
- **Signature:** `public IntMatrix vstack(final IntMatrix other) throws IllegalArgumentException`
- **Summary:** Stacks this matrix vertically with another matrix (vertical concatenation).
- **Contract:**
  - The matrices must have the same number of columns.
- **Parameters:**
  - `other` (`IntMatrix`) — the matrix to stack below this matrix (must have the same column count)
- **Returns:** a new IntMatrix with dimensions (this.rowCount + other.rowCount) x this.columnCount
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code this.columnCount != other.columnCount}
- **See also:** #hstack(IntMatrix)
##### hstack(...) -> IntMatrix
- **Signature:** `public IntMatrix hstack(final IntMatrix other) throws IllegalArgumentException`
- **Summary:** Stacks this matrix horizontally with another matrix (horizontal concatenation).
- **Contract:**
  - The matrices must have the same number of rows.
- **Parameters:**
  - `other` (`IntMatrix`) — the matrix to stack to the right of this matrix (must have the same row count)
- **Returns:** a new IntMatrix with dimensions this.rowCount x (this.columnCount + other.columnCount)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code this.rowCount != other.rowCount}
- **See also:** #vstack(IntMatrix)
##### add(...) -> IntMatrix
- **Signature:** `public IntMatrix add(final IntMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise addition with another matrix.
- **Contract:**
  - The matrices must have the same dimensions.
- **Parameters:**
  - `other` (`IntMatrix`) — the matrix to add to this matrix
- **Returns:** a new IntMatrix containing the element-wise sum
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
##### subtract(...) -> IntMatrix
- **Signature:** `public IntMatrix subtract(final IntMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise subtraction with another matrix.
- **Contract:**
  - The matrices must have the same dimensions.
- **Parameters:**
  - `other` (`IntMatrix`) — the matrix to subtract from this matrix
- **Returns:** a new IntMatrix containing the element-wise difference
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions
##### multiply(...) -> IntMatrix
- **Signature:** `public IntMatrix multiply(final IntMatrix other) throws IllegalArgumentException`
- **Summary:** Performs matrix multiplication with another matrix.
- **Contract:**
  - The number of columns in this matrix must equal the number of rows in the other matrix.
- **Parameters:**
  - `other` (`IntMatrix`) — the matrix to multiply with
- **Returns:** a new IntMatrix containing the matrix product
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrix dimensions are incompatible for multiplication
##### boxed(...) -> Matrix<Integer>
- **Signature:** `public Matrix<Integer> boxed()`
- **Summary:** Converts this primitive int matrix to a boxed Integer matrix.
- **Parameters:**
  - (none)
- **Returns:** a new Matrix containing boxed Integer values
##### toLongMatrix(...) -> LongMatrix
- **Signature:** `public LongMatrix toLongMatrix()`
- **Summary:** Converts this int matrix to a long matrix.
- **Parameters:**
  - (none)
- **Returns:** a new LongMatrix with converted values
##### toFloatMatrix(...) -> FloatMatrix
- **Signature:** `public FloatMatrix toFloatMatrix()`
- **Summary:** Converts this int matrix to a float matrix.
- **Parameters:**
  - (none)
- **Returns:** a new FloatMatrix with converted values
##### toDoubleMatrix(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix toDoubleMatrix()`
- **Summary:** Converts this int matrix to a double matrix.
- **Parameters:**
  - (none)
- **Returns:** a new DoubleMatrix with converted values
##### zipWith(...) -> IntMatrix
- **Signature:** `public <E extends Exception> IntMatrix zipWith(final IntMatrix matrixB, final Throwables.IntBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Performs element-wise operation on two matrices using a binary operator.
- **Contract:**
  - The matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`IntMatrix`) — the second matrix (must have the same dimensions as this matrix)
  - `zipFunction` (`Throwables.IntBinaryOperator<E>`) — the binary operator to apply to corresponding elements; receives element from this matrix as first argument and element from matrixB as second argument
- **Returns:** a new IntMatrix with the results of the element-wise operation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different dimensions (shape mismatch)
  - `E` — if the zip function throws an exception
- **See also:** #zipWith(IntMatrix, IntMatrix, Throwables.IntTernaryOperator)
- **Signature:** `public <E extends Exception> IntMatrix zipWith(final IntMatrix matrixB, final IntMatrix matrixC, final Throwables.IntTernaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Performs element-wise operation on three matrices using a ternary operator.
- **Contract:**
  - All matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`IntMatrix`) — the second matrix (must have the same dimensions as this matrix)
  - `matrixC` (`IntMatrix`) — the third matrix (must have the same dimensions as this matrix)
  - `zipFunction` (`Throwables.IntTernaryOperator<E>`) — the ternary operator to apply to corresponding elements; receives element from this matrix as first argument, element from matrixB as second argument, and element from matrixC as third argument
- **Returns:** a new IntMatrix with the results of the element-wise operation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any matrices have different dimensions (shape mismatch)
  - `E` — if the zip function throws an exception
- **See also:** #zipWith(IntMatrix, Throwables.IntBinaryOperator)
##### streamLU2RD(...) -> IntStream
- **Signature:** `@Override public IntStream streamLU2RD()`
- **Summary:** Returns a stream of elements on the main diagonal (left-up to right-down).
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - (none)
- **Returns:** an IntStream of diagonal elements
##### streamRU2LD(...) -> IntStream
- **Signature:** `@Override public IntStream streamRU2LD()`
- **Summary:** Returns a stream of elements on the anti-diagonal (right-up to left-down).
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - (none)
- **Returns:** an IntStream of anti-diagonal elements
##### streamH(...) -> IntStream
- **Signature:** `@Override public IntStream streamH()`
- **Summary:** Returns a stream of all elements in row-major order (horizontal).
- **Parameters:**
  - (none)
- **Returns:** an IntStream of all elements in row-major order, or an empty stream if the matrix is empty
- **Signature:** `@Override public IntStream streamH(final int rowIndex)`
- **Summary:** Returns a stream of elements from a single row.
- **Contract:**
  - <p> This method is particularly useful when you need to process or analyze a specific row of the matrix independently.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to stream (0-based)
- **Returns:** an IntStream of elements from the specified row
- **Signature:** `@Override public IntStream streamH(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of elements from a range of rows in row-major order.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** an IntStream of elements from the specified row range, or an empty stream if the matrix is empty
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rows, or fromRowIndex &gt; toRowIndex
##### streamV(...) -> IntStream
- **Signature:** `@Override @Beta public IntStream streamV()`
- **Summary:** Returns a stream of all elements in column-major order (vertical).
- **Parameters:**
  - (none)
- **Returns:** an IntStream of all elements in column-major order, or an empty stream if the matrix is empty
- **Signature:** `@Override public IntStream streamV(final int columnIndex)`
- **Summary:** Returns a stream of elements from a single column.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to stream (0-based)
- **Returns:** an IntStream of elements from the specified column
- **Signature:** `@Override @Beta public IntStream streamV(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of elements from a range of columns in column-major order.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** an IntStream of elements from the specified column range in column-major order, or an empty stream if the matrix is empty
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromColumnIndex &lt; 0, toColumnIndex &gt; columnCount, or fromColumnIndex &gt; toColumnIndex
##### streamR(...) -> Stream<IntStream>
- **Signature:** `@Override public Stream<IntStream> streamR()`
- **Summary:** Returns a stream of IntStream objects, where each IntStream represents a complete row.
- **Parameters:**
  - (none)
- **Returns:** a Stream of IntStream objects, one for each row in the matrix, or an empty stream if the matrix is empty
- **Signature:** `@Override public Stream<IntStream> streamR(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of IntStream objects for a range of rows.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a Stream of IntStream objects for the specified row range, or an empty stream if the matrix is empty
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rows, or fromRowIndex &gt; toRowIndex
##### streamC(...) -> Stream<IntStream>
- **Signature:** `@Override @Beta public Stream<IntStream> streamC()`
- **Summary:** Returns a stream of IntStream objects, where each IntStream represents a complete column.
- **Parameters:**
  - (none)
- **Returns:** a Stream of IntStream objects, one for each column in the matrix, or an empty stream if the matrix is empty
- **Signature:** `@Override @Beta public Stream<IntStream> streamC(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of IntStream objects for a range of columns.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a Stream of IntStream objects for the specified column range, or an empty stream if the matrix is empty
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromColumnIndex &lt; 0, toColumnIndex &gt; columnCount, or fromColumnIndex &gt; toColumnIndex
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.IntConsumer<E> action) throws E`
- **Summary:** Applies the given action to each element in the matrix.
- **Contract:**
  - Elements are processed in row-major order (row by row, left to right) when executed sequentially.
  - If parallelized, the order of execution is not guaranteed, but all elements will be processed exactly once.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code IntMatrix matrix = IntMatrix.of(new int\[\]\[\] {{1, 2}, {3, 4}}); // Collect all values List<Integer> values = new ArrayList<>(); matrix.forEach(value -> values.add(value)); // values now contains \[1, 2, 3, 4\] // Calculate sum using forEach (though streamH().sum() is preferable) int\[\] sum = {0}; matrix.forEach(value -> sum\[0\] += value); // sum\[0\] is now 10 // Print all positive values matrix.forEach(value -> { if (value > 0) System.out.println(value); }); } </pre>
- **Parameters:**
  - `action` (`Throwables.IntConsumer<E>`) — the action to be performed for each element; receives each element value
- **Throws:**
  - `E` — if the action throws an exception
- **See also:** #forEach(int, int, int, int, Throwables.IntConsumer)
- **Signature:** `public <E extends Exception> void forEach(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.IntConsumer<E> action) throws IndexOutOfBoundsException, E`
- **Summary:** Applies the given action to each element in the specified sub-matrix region.
- **Contract:**
  - The operation may be parallelized internally if the sub-matrix is large enough to benefit from parallel processing.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
  - `action` (`Throwables.IntConsumer<E>`) — the action to be performed for each element in the sub-matrix
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is out of bounds
  - `E` — if the action throws an exception
##### println(...) -> String
- **Signature:** `@Override public String println()`
- **Summary:** Prints the matrix to standard output in a formatted manner.
- **Parameters:**
  - (none)
- **Returns:** the formatted string representation of the matrix
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this matrix.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this matrix
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this matrix to the specified object for equality.
- **Contract:**
  - Returns {@code true} if the given object is also an IntMatrix with the same dimensions and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the objects are equal, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this matrix

### Class IntTuple (com.landawn.abacus.util.IntTuple)
Abstract base class for immutable tuple implementations that hold primitive int values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> IntTuple1
- **Signature:** `public static IntTuple1 of(final int _1)`
- **Summary:** Creates an IntTuple.IntTuple1 containing a single int value.
- **Parameters:**
  - `_1` (`int`) — the int value to wrap in a tuple
- **Returns:** a new IntTuple.IntTuple1 containing the provided value
- **Signature:** `public static IntTuple2 of(final int _1, final int _2)`
- **Summary:** Creates an IntTuple.IntTuple2 containing two int values.
- **Parameters:**
  - `_1` (`int`) — the first int value
  - `_2` (`int`) — the second int value
- **Returns:** a new IntTuple.IntTuple2 containing the provided values
- **Signature:** `public static IntTuple3 of(final int _1, final int _2, final int _3)`
- **Summary:** Creates an IntTuple.IntTuple3 containing three int values.
- **Parameters:**
  - `_1` (`int`) — the first int value
  - `_2` (`int`) — the second int value
  - `_3` (`int`) — the third int value
- **Returns:** a new IntTuple.IntTuple3 containing the provided values
- **Signature:** `public static IntTuple4 of(final int _1, final int _2, final int _3, final int _4)`
- **Summary:** Creates an IntTuple.IntTuple4 containing four int values.
- **Parameters:**
  - `_1` (`int`) — the first int value
  - `_2` (`int`) — the second int value
  - `_3` (`int`) — the third int value
  - `_4` (`int`) — the fourth int value
- **Returns:** a new IntTuple.IntTuple4 containing the provided values
- **Signature:** `public static IntTuple5 of(final int _1, final int _2, final int _3, final int _4, final int _5)`
- **Summary:** Creates an IntTuple.IntTuple5 containing five int values.
- **Parameters:**
  - `_1` (`int`) — the first int value
  - `_2` (`int`) — the second int value
  - `_3` (`int`) — the third int value
  - `_4` (`int`) — the fourth int value
  - `_5` (`int`) — the fifth int value
- **Returns:** a new IntTuple.IntTuple5 containing the provided values
- **Signature:** `public static IntTuple6 of(final int _1, final int _2, final int _3, final int _4, final int _5, final int _6)`
- **Summary:** Creates an IntTuple.IntTuple6 containing six int values.
- **Parameters:**
  - `_1` (`int`) — the first int value
  - `_2` (`int`) — the second int value
  - `_3` (`int`) — the third int value
  - `_4` (`int`) — the fourth int value
  - `_5` (`int`) — the fifth int value
  - `_6` (`int`) — the sixth int value
- **Returns:** a new IntTuple.IntTuple6 containing the provided values
- **Signature:** `public static IntTuple7 of(final int _1, final int _2, final int _3, final int _4, final int _5, final int _6, final int _7)`
- **Summary:** Creates an IntTuple.IntTuple7 containing seven int values.
- **Parameters:**
  - `_1` (`int`) — the first int value
  - `_2` (`int`) — the second int value
  - `_3` (`int`) — the third int value
  - `_4` (`int`) — the fourth int value
  - `_5` (`int`) — the fifth int value
  - `_6` (`int`) — the sixth int value
  - `_7` (`int`) — the seventh int value
- **Returns:** a new IntTuple.IntTuple7 containing the provided values
- **Signature:** `@Deprecated public static IntTuple8 of(final int _1, final int _2, final int _3, final int _4, final int _5, final int _6, final int _7, final int _8)`
- **Summary:** Creates an IntTuple.IntTuple8 containing eight int values.
- **Parameters:**
  - `_1` (`int`) — the first int value
  - `_2` (`int`) — the second int value
  - `_3` (`int`) — the third int value
  - `_4` (`int`) — the fourth int value
  - `_5` (`int`) — the fifth int value
  - `_6` (`int`) — the sixth int value
  - `_7` (`int`) — the seventh int value
  - `_8` (`int`) — the eighth int value
- **Returns:** a new IntTuple.IntTuple8 containing the provided values
- **Signature:** `@Deprecated public static IntTuple9 of(final int _1, final int _2, final int _3, final int _4, final int _5, final int _6, final int _7, final int _8, final int _9)`
- **Summary:** Creates an IntTuple.IntTuple9 containing nine int values.
- **Parameters:**
  - `_1` (`int`) — the first int value
  - `_2` (`int`) — the second int value
  - `_3` (`int`) — the third int value
  - `_4` (`int`) — the fourth int value
  - `_5` (`int`) — the fifth int value
  - `_6` (`int`) — the sixth int value
  - `_7` (`int`) — the seventh int value
  - `_8` (`int`) — the eighth int value
  - `_9` (`int`) — the ninth int value
- **Returns:** a new IntTuple.IntTuple9 containing the provided values
##### create(...) -> TP
- **Signature:** `@SuppressWarnings("deprecation") public static <TP extends IntTuple<TP>> TP create(final int[] values)`
- **Summary:** Creates an IntTuple from an array of int values.
- **Parameters:**
  - `values` (`int[]`) — the array of int values (must have length 0-9), may be {@code null}
- **Returns:** an IntTuple of appropriate size containing the array values, or an empty IntTuple if the array is null or empty

#### Public Instance Methods
##### min(...) -> int
- **Signature:** `public int min()`
- **Summary:** Returns the minimum int value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the minimum int value in this tuple
##### max(...) -> int
- **Signature:** `public int max()`
- **Summary:** Returns the maximum int value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the maximum int value in this tuple
##### median(...) -> int
- **Signature:** `public int median()`
- **Summary:** Returns the median value of the elements in this tuple.
- **Contract:**
  - <p> For tuples with an odd number of elements, returns the middle value when sorted.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Odd number of elements IntTuple.IntTuple3 tuple3 = IntTuple.of(30, 10, 20); int median = tuple3.median(); // 20 (middle value when sorted: 10, 20, 30) // Even number of elements IntTuple.IntTuple4 tuple4 = IntTuple.of(1, 2, 3, 4); int median2 = tuple4.median(); // 2 (lower middle value when sorted) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median int element in this tuple
##### sum(...) -> int
- **Signature:** `public int sum()`
- **Summary:** Returns the sum of all elements in this tuple.
- **Contract:**
  - If the sum exceeds {@code Integer.MAX_VALUE} , the result will wrap around according to standard int arithmetic.
- **Parameters:**
  - (none)
- **Returns:** the sum of all int values in this tuple
##### average(...) -> double
- **Signature:** `public double average()`
- **Summary:** Returns the average of all int values in this tuple as a double.
- **Contract:**
  - The result is always returned as a double to preserve precision, even when the average is a whole number.
- **Parameters:**
  - (none)
- **Returns:** the average of all int values in this tuple as a double
##### reverse(...) -> TP
- **Signature:** `public abstract TP reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Contract:**
  - For example, a tuple (1, 2, 3) becomes (3, 2, 1) when reversed.
- **Parameters:**
  - (none)
- **Returns:** a new tuple with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `public abstract boolean contains(int valueToFind)`
- **Summary:** Checks if this tuple contains the specified int value.
- **Contract:**
  - Checks if this tuple contains the specified int value.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code IntTuple.IntTuple3 tuple = IntTuple.of(1, 2, 3); boolean hasTwo = tuple.contains(2); // true boolean hasFive = tuple.contains(5); // false IntTuple.IntTuple5 numbers = IntTuple.of(10, 20, 30, 40, 50); if (numbers.contains(30)) { System.out.println("Found 30!"); // This will be printed } } </pre>
- **Parameters:**
  - `valueToFind` (`int`) — the int value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### toArray(...) -> int\[\]
- **Signature:** `public int[] toArray()`
- **Summary:** Returns a new array containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new int array containing all tuple elements
##### toList(...) -> IntList
- **Signature:** `public IntList toList()`
- **Summary:** Returns a new IntList containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new IntList containing all tuple elements
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.IntConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.IntConsumer<E>`) — the action to be performed for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### stream(...) -> IntStream
- **Signature:** `public IntStream stream()`
- **Summary:** Returns an IntStream of all elements in this tuple.
- **Parameters:**
  - (none)
- **Returns:** an IntStream containing all tuple elements
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this tuple
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Contract:**
  - <p> Two tuples are considered equal if and only if: <ul> <li> They are of the same class (same tuple type and arity) </li> <li> All corresponding elements are equal in the same order </li> </ul> This method provides a consistent equals-hashCode contract with {@link #hashCode()} .
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the specified object is equal to this tuple, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this tuple in the format "(element1, element2, ...)"

### Class IntTuple1 (com.landawn.abacus.util.IntTuple.IntTuple1)
An IntTuple containing exactly one int value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 1.
- **Parameters:**
  - (none)
- **Returns:** 1
##### min(...) -> int
- **Signature:** `@Override public int min()`
- **Summary:** Returns the minimum value in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### max(...) -> int
- **Signature:** `@Override public int max()`
- **Summary:** Returns the maximum value in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### median(...) -> int
- **Signature:** `@Override public int median()`
- **Summary:** Returns the median value.
- **Contract:**
  - The median is the middle element when the values are sorted in ascending order.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of elements in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of elements in this tuple, which is the single element.
- **Parameters:**
  - (none)
- **Returns:** the value of _1 as a double
##### reverse(...) -> IntTuple1
- **Signature:** `@Override public IntTuple1 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new IntTuple.IntTuple1 with the same value
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final int valueToFind)`
- **Summary:** Checks if this tuple contains the specified int value.
- **Contract:**
  - Checks if this tuple contains the specified int value.
- **Parameters:**
  - `valueToFind` (`int`) — the int value to search for
- **Returns:** {@code true} if _1 equals valueToFind, {@code false} otherwise
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on its single element.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is an IntTuple.IntTuple1 with equal value
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(value)" where value is _1

### Class IntTuple2 (com.landawn.abacus.util.IntTuple.IntTuple2)
An IntTuple containing exactly two int values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 2.
- **Parameters:**
  - (none)
- **Returns:** 2
##### min(...) -> int
- **Signature:** `@Override public int min()`
- **Summary:** Returns the minimum value among the two elements.
- **Parameters:**
  - (none)
- **Returns:** the smaller of _1 and _2
##### max(...) -> int
- **Signature:** `@Override public int max()`
- **Summary:** Returns the maximum value among the two elements.
- **Parameters:**
  - (none)
- **Returns:** the larger of _1 and _2
##### median(...) -> int
- **Signature:** `@Override public int median()`
- **Summary:** Returns the median value.
- **Contract:**
  - The median is the middle element when the values are sorted in ascending order.
- **Parameters:**
  - (none)
- **Returns:** the median (lower middle) int value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of the two elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the two elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2) / 2.0
##### reverse(...) -> IntTuple2
- **Signature:** `@Override public IntTuple2 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new IntTuple.IntTuple2 with (_2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final int valueToFind)`
- **Summary:** Checks if this tuple contains the specified int value.
- **Contract:**
  - Checks if this tuple contains the specified int value.
- **Parameters:**
  - `valueToFind` (`int`) — the int value to search for
- **Returns:** {@code true} if either element equals valueToFind
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.IntConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.IntConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.IntBiConsumer<E> action) throws E`
- **Summary:** Performs the given bi-consumer on the two elements.
- **Parameters:**
  - `action` (`Throwables.IntBiConsumer<E>`) — the bi-consumer to perform on the two elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `@MayReturnNull public <U, E extends Exception> U map(final Throwables.IntBiFunction<U, E> mapper) throws E`
- **Summary:** Applies the given bi-function to the two elements and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.IntBiFunction<U, E>`) — the bi-function to apply to the two elements
- **Returns:** the result of applying the mapper to _1 and _2, may be {@code null}
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<IntTuple2>
- **Signature:** `public <E extends Exception> Optional<IntTuple2> filter(final Throwables.IntBiPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Contract:**
  - Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Parameters:**
  - `predicate` (`Throwables.IntBiPredicate<E>`) — the bi-predicate to test the two elements
- **Returns:** Optional containing this tuple if predicate returns true, empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on both elements.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is an IntTuple.IntTuple2 with equal elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(_1, _2)"

### Class IntTuple3 (com.landawn.abacus.util.IntTuple.IntTuple3)
An IntTuple containing exactly three int values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 3.
- **Parameters:**
  - (none)
- **Returns:** 3
##### min(...) -> int
- **Signature:** `@Override public int min()`
- **Summary:** Returns the minimum value among the three elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, and _3
##### max(...) -> int
- **Signature:** `@Override public int max()`
- **Summary:** Returns the maximum value among the three elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, and _3
##### median(...) -> int
- **Signature:** `@Override public int median()`
- **Summary:** Returns the median value.
- **Contract:**
  - The median is the middle element when the values are sorted in ascending order.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of the three elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the three elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3) / 3.0
##### reverse(...) -> IntTuple3
- **Signature:** `@Override public IntTuple3 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new IntTuple.IntTuple3 with (_3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final int valueToFind)`
- **Summary:** Checks if this tuple contains the specified int value.
- **Contract:**
  - Checks if this tuple contains the specified int value.
- **Parameters:**
  - `valueToFind` (`int`) — the int value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.IntConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.IntConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.IntTriConsumer<E> action) throws E`
- **Summary:** Performs the given tri-consumer on the three elements.
- **Parameters:**
  - `action` (`Throwables.IntTriConsumer<E>`) — the tri-consumer to perform on the three elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `@MayReturnNull public <U, E extends Exception> U map(final Throwables.IntTriFunction<U, E> mapper) throws E`
- **Summary:** Applies the given tri-function to the three elements and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.IntTriFunction<U, E>`) — the tri-function to apply to the three elements
- **Returns:** the result of applying the mapper to _1, _2, and _3, may be {@code null}
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<IntTuple3>
- **Signature:** `public <E extends Exception> Optional<IntTuple3> filter(final Throwables.IntTriPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Contract:**
  - Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Parameters:**
  - `predicate` (`Throwables.IntTriPredicate<E>`) — the tri-predicate to test the three elements
- **Returns:** Optional containing this tuple if predicate returns true, empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code for this tuple based on all three elements.
- **Parameters:**
  - (none)
- **Returns:** the hash code
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is an IntTuple.IntTuple3 with equal elements
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** "(_1, _2, _3)"

### Class IntTuple4 (com.landawn.abacus.util.IntTuple.IntTuple4)
An IntTuple containing exactly four int values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 4.
- **Parameters:**
  - (none)
- **Returns:** 4
##### min(...) -> int
- **Signature:** `@Override public int min()`
- **Summary:** Returns the minimum value among the four elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, and _4
##### max(...) -> int
- **Signature:** `@Override public int max()`
- **Summary:** Returns the maximum value among the four elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, and _4
##### median(...) -> int
- **Signature:** `@Override public int median()`
- **Summary:** Returns the median value.
- **Contract:**
  - The median is the middle element when the values are sorted in ascending order.
- **Parameters:**
  - (none)
- **Returns:** the median (lower middle) int value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of the four elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the four elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4) / 4.0
##### reverse(...) -> IntTuple4
- **Signature:** `@Override public IntTuple4 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new IntTuple.IntTuple4 with (_4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final int valueToFind)`
- **Summary:** Checks if this tuple contains the specified int value.
- **Contract:**
  - Checks if this tuple contains the specified int value.
- **Parameters:**
  - `valueToFind` (`int`) — the int value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.IntConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.IntConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all four elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both IntTuple.IntTuple4 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is an IntTuple.IntTuple4 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4)"

### Class IntTuple5 (com.landawn.abacus.util.IntTuple.IntTuple5)
An IntTuple containing exactly five int values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 5.
- **Parameters:**
  - (none)
- **Returns:** 5
##### min(...) -> int
- **Signature:** `@Override public int min()`
- **Summary:** Returns the minimum value among the five elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, and _5
##### max(...) -> int
- **Signature:** `@Override public int max()`
- **Summary:** Returns the maximum value among the five elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, and _5
##### median(...) -> int
- **Signature:** `@Override public int median()`
- **Summary:** Returns the median value.
- **Contract:**
  - The median is the middle element when the values are sorted in ascending order.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of the five elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the five elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5) / 5.0
##### reverse(...) -> IntTuple5
- **Signature:** `@Override public IntTuple5 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new IntTuple.IntTuple5 with (_5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final int valueToFind)`
- **Summary:** Checks if this tuple contains the specified int value.
- **Contract:**
  - Checks if this tuple contains the specified int value.
- **Parameters:**
  - `valueToFind` (`int`) — the int value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.IntConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.IntConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all five elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both IntTuple.IntTuple5 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is an IntTuple.IntTuple5 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5)"

### Class IntTuple6 (com.landawn.abacus.util.IntTuple.IntTuple6)
An IntTuple containing exactly six int values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 6.
- **Parameters:**
  - (none)
- **Returns:** 6
##### min(...) -> int
- **Signature:** `@Override public int min()`
- **Summary:** Returns the minimum value among the six elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, and _6
##### max(...) -> int
- **Signature:** `@Override public int max()`
- **Summary:** Returns the maximum value among the six elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, and _6
##### median(...) -> int
- **Signature:** `@Override public int median()`
- **Summary:** Returns the median value.
- **Contract:**
  - The median is the middle element when the values are sorted in ascending order.
- **Parameters:**
  - (none)
- **Returns:** the median (lower middle) int value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of the six elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the six elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6) / 6.0
##### reverse(...) -> IntTuple6
- **Signature:** `@Override public IntTuple6 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new IntTuple.IntTuple6 with (_6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final int valueToFind)`
- **Summary:** Checks if this tuple contains the specified int value.
- **Contract:**
  - Checks if this tuple contains the specified int value.
- **Parameters:**
  - `valueToFind` (`int`) — the int value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.IntConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.IntConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all six elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both IntTuple.IntTuple6 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is an IntTuple.IntTuple6 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6)"

### Class IntTuple7 (com.landawn.abacus.util.IntTuple.IntTuple7)
An IntTuple containing exactly seven int values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 7.
- **Parameters:**
  - (none)
- **Returns:** 7
##### min(...) -> int
- **Signature:** `@Override public int min()`
- **Summary:** Returns the minimum value among the seven elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, _6, and _7
##### max(...) -> int
- **Signature:** `@Override public int max()`
- **Summary:** Returns the maximum value among the seven elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, _6, and _7
##### median(...) -> int
- **Signature:** `@Override public int median()`
- **Summary:** Returns the median value.
- **Contract:**
  - The median is the middle element when the values are sorted in ascending order.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of the seven elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the seven elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7) / 7.0
##### reverse(...) -> IntTuple7
- **Signature:** `@Override public IntTuple7 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new IntTuple.IntTuple7 with (_7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final int valueToFind)`
- **Summary:** Checks if this tuple contains the specified int value.
- **Contract:**
  - Checks if this tuple contains the specified int value.
- **Parameters:**
  - `valueToFind` (`int`) — the int value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.IntConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.IntConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all seven elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both IntTuple.IntTuple7 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is an IntTuple.IntTuple7 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7)"

### Class IntTuple8 (com.landawn.abacus.util.IntTuple.IntTuple8)
An IntTuple containing exactly eight int values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 8.
- **Parameters:**
  - (none)
- **Returns:** 8
##### min(...) -> int
- **Signature:** `@Override public int min()`
- **Summary:** Returns the minimum value among the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of all eight elements
##### max(...) -> int
- **Signature:** `@Override public int max()`
- **Summary:** Returns the maximum value among the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of all eight elements
##### median(...) -> int
- **Signature:** `@Override public int median()`
- **Summary:** Returns the median value.
- **Contract:**
  - The median is the middle element when the values are sorted in ascending order.
- **Parameters:**
  - (none)
- **Returns:** the median (lower middle) int value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7 + _8) / 8.0
##### reverse(...) -> IntTuple8
- **Signature:** `@Override public IntTuple8 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new IntTuple.IntTuple8 with (_8, _7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final int valueToFind)`
- **Summary:** Checks if this tuple contains the specified int value.
- **Contract:**
  - Checks if this tuple contains the specified int value.
- **Parameters:**
  - `valueToFind` (`int`) — the int value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.IntConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.IntConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all eight elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both IntTuple.IntTuple8 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is an IntTuple.IntTuple8 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7, _8)"

### Class IntTuple9 (com.landawn.abacus.util.IntTuple.IntTuple9)
An IntTuple containing exactly nine int values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 9.
- **Parameters:**
  - (none)
- **Returns:** 9
##### min(...) -> int
- **Signature:** `@Override public int min()`
- **Summary:** Returns the minimum value among the nine elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of all nine elements
##### max(...) -> int
- **Signature:** `@Override public int max()`
- **Summary:** Returns the maximum value among the nine elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of all nine elements
##### median(...) -> int
- **Signature:** `@Override public int median()`
- **Summary:** Returns the median value.
- **Contract:**
  - The median is the middle element when the values are sorted in ascending order.
- **Parameters:**
  - (none)
- **Returns:** the middle value when sorted
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of the nine elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 + _9
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the nine elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 + _9) / 9.0
##### reverse(...) -> IntTuple9
- **Signature:** `@Override public IntTuple9 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new IntTuple.IntTuple9 with (_9, _8, _7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final int valueToFind)`
- **Summary:** Checks if this tuple contains the specified int value.
- **Contract:**
  - Checks if this tuple contains the specified int value.
- **Parameters:**
  - `valueToFind` (`int`) — the int value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.IntConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.IntConsumer<E>`) — the action to perform
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all nine elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both IntTuple.IntTuple9 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is an IntTuple.IntTuple9 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7, _8, _9)"

### Class LongMatrix (com.landawn.abacus.util.LongMatrix)
A matrix implementation for long primitive values, providing efficient storage and operations for two-dimensional long arrays.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### empty(...) -> LongMatrix
- **Signature:** `public static LongMatrix empty()`
- **Summary:** Creates an empty matrix with zero rows and zero columns.
- **Parameters:**
  - (none)
- **Returns:** an empty long matrix
##### of(...) -> LongMatrix
- **Signature:** `public static LongMatrix of(final long[]... a)`
- **Summary:** Creates a LongMatrix from a two-dimensional long array.
- **Parameters:**
  - `a` (`long[][]`) — the two-dimensional long array to create the matrix from, or null/empty for an empty matrix
- **Returns:** a new LongMatrix containing the provided data, or an empty LongMatrix if input is null or empty
##### from(...) -> LongMatrix
- **Signature:** `public static LongMatrix from(final int[]... a)`
- **Summary:** Creates a LongMatrix from a two-dimensional int array by converting int values to long.
- **Contract:**
  - <p> All rows must have the same length as the first row (rectangular array required).
  - The method validates array structure and throws an exception if the array is jagged (rows of different lengths).
- **Parameters:**
  - `a` (`int[][]`) — the two-dimensional int array to convert to a long matrix, or null/empty for an empty matrix
- **Returns:** a new LongMatrix with converted values, or an empty LongMatrix if input is null or empty
##### random(...) -> LongMatrix
- **Signature:** `public static LongMatrix random(final int size)`
- **Summary:** Creates a new 1xsize matrix filled with random long values.
- **Parameters:**
  - `size` (`int`) — the number of columns in the new matrix
- **Returns:** a new LongMatrix of dimensions 1 x size filled with random values
- **Signature:** `public static LongMatrix random(final int rowCount, final int columnCount)`
- **Summary:** Creates a new matrix of the specified dimensions filled with random long values.
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
- **Returns:** a new LongMatrix of dimensions rowCount x columnCount filled with random values
##### repeat(...) -> LongMatrix
- **Signature:** `public static LongMatrix repeat(final int rowCount, final int columnCount, final long element)`
- **Summary:** Creates a new matrix of the specified dimensions where every element is the provided {@code element} .
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
  - `element` (`long`) — the long value to fill the matrix with
- **Returns:** a new LongMatrix of dimensions rowCount x columnCount filled with the specified element
##### range(...) -> LongMatrix
- **Signature:** `public static LongMatrix range(final long startInclusive, final long endExclusive)`
- **Summary:** Creates a 1-row LongMatrix with values from startInclusive to endExclusive.
- **Contract:**
  - If {@code startInclusive >= endExclusive} , an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`long`) — the starting value (inclusive)
  - `endExclusive` (`long`) — the ending value (exclusive)
- **Returns:** a new 1×n LongMatrix where n = max(0, endExclusive - startInclusive)
- **Signature:** `public static LongMatrix range(final long startInclusive, final long endExclusive, final long by)`
- **Summary:** Creates a 1-row LongMatrix with values from startInclusive to endExclusive with the specified step.
- **Contract:**
  - If the step would not reach endExclusive from startInclusive, an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`long`) — the starting value (inclusive)
  - `endExclusive` (`long`) — the ending value (exclusive)
  - `by` (`long`) — the step size (must not be zero; can be positive or negative)
- **Returns:** a new 1×n LongMatrix with values incremented by the step size
##### rangeClosed(...) -> LongMatrix
- **Signature:** `public static LongMatrix rangeClosed(final long startInclusive, final long endInclusive)`
- **Summary:** Creates a 1-row LongMatrix with values from startInclusive to endInclusive.
- **Contract:**
  - If {@code startInclusive > endInclusive} , an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`long`) — the starting value (inclusive)
  - `endInclusive` (`long`) — the ending value (inclusive)
- **Returns:** a new 1×n LongMatrix where n = max(0, endInclusive - startInclusive + 1)
- **Signature:** `public static LongMatrix rangeClosed(final long startInclusive, final long endInclusive, final long by)`
- **Summary:** Creates a 1-row LongMatrix with values from startInclusive to endInclusive with the specified step.
- **Contract:**
  - The end value is included only if it is reachable by stepping from start.
  - If the step would not reach endInclusive from startInclusive, an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`long`) — the starting value (inclusive)
  - `endInclusive` (`long`) — the ending value (inclusive, if reachable by stepping)
  - `by` (`long`) — the step size (must not be zero; can be positive or negative)
- **Returns:** a new 1×n LongMatrix with values incremented by the step size
##### diagonalLU2RD(...) -> LongMatrix
- **Signature:** `public static LongMatrix diagonalLU2RD(final long[] leftUp2RightDownDiagonal)`
- **Summary:** Creates a square matrix from the specified main diagonal elements (left-upper to right-down).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`long[]`) — the array of main diagonal elements (from top-left to bottom-right)
- **Returns:** a square n×n matrix with the specified main diagonal, where n is the array length
##### diagonalRU2LD(...) -> LongMatrix
- **Signature:** `public static LongMatrix diagonalRU2LD(final long[] rightUp2LeftDownDiagonal)`
- **Summary:** Creates a square matrix from the specified anti-diagonal elements (right-upper to left-down).
- **Parameters:**
  - `rightUp2LeftDownDiagonal` (`long[]`) — the array of anti-diagonal elements (from top-right to bottom-left)
- **Returns:** a square n×n matrix with the specified anti-diagonal, where n is the array length
##### diagonal(...) -> LongMatrix
- **Signature:** `public static LongMatrix diagonal(final long[] leftUp2RightDownDiagonal, final long[] rightUp2LeftDownDiagonal) throws IllegalArgumentException`
- **Summary:** Creates a square matrix from the specified main diagonal and anti-diagonal elements.
- **Contract:**
  - If both arrays are provided, they must have the same length.
  - The resulting matrix has dimensions n×n where n is the length of the non-null/non-empty array (or the maximum length if both are provided).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`long[]`) — the array of main diagonal elements (can be null or empty)
  - `rightUp2LeftDownDiagonal` (`long[]`) — the array of anti-diagonal elements (can be null or empty)
- **Returns:** a square matrix with the specified diagonals, or an empty matrix if both inputs are null or empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — if both arrays are non-empty and have different lengths
##### unbox(...) -> LongMatrix
- **Signature:** `public static LongMatrix unbox(final Matrix<Long> x)`
- **Summary:** Converts a boxed {@code Matrix<Long>} to a primitive {@code LongMatrix} .
- **Contract:**
  - This is particularly beneficial when working with large matrices, as primitive arrays have less memory overhead and better cache locality than arrays of wrapper objects.
- **Parameters:**
  - `x` (`Matrix<Long>`) — the boxed Long matrix to convert
- **Returns:** a new LongMatrix with unboxed primitive values

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public LongMatrix(final long[][] a)`
- **Summary:** Constructs a LongMatrix from a two-dimensional long array.
- **Contract:**
  - If the input array is null, an empty matrix (0x0) is created.
  - If you need an independent copy, use {@link #copy()} after construction.
- **Parameters:**
  - `a` (`long[][]`) — the two-dimensional long array to wrap as a matrix. Can be null, which creates an empty matrix.
##### componentType(...) -> Class
- **Signature:** `@SuppressWarnings("rawtypes") @Override public Class componentType()`
- **Summary:** Returns the component type of the matrix elements, which is always {@code long.class} .
- **Parameters:**
  - (none)
- **Returns:** {@code long.class}
##### get(...) -> long
- **Signature:** `public long get(final int i, final int j)`
- **Summary:** Returns the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** the element at position (rowIndex, columnIndex)
- **Signature:** `public long get(final Point point)`
- **Summary:** Returns the element at the specified Sheet.Point.
- **Parameters:**
  - `point` (`Point`)
- **Returns:** the long element at the specified Sheet.Point
- **See also:** #get(int, int)
##### set(...) -> void
- **Signature:** `public void set(final int i, final int j, final long val)`
- **Summary:** Sets the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
  - `val` (`long`) — the value to set
- **Signature:** `public void set(final Point point, final long val)`
- **Summary:** Sets the element at the specified Sheet.Point to the given value.
- **Parameters:**
  - `point` (`Point`)
  - `val` (`long`) — the new long value to set at the specified Sheet.Point
- **See also:** #set(int, int, long)
##### upOf(...) -> OptionalLong
- **Signature:** `public OptionalLong upOf(final int i, final int j)`
- **Summary:** Returns the element directly above the specified position, if it exists.
- **Contract:**
  - Returns the element directly above the specified position, if it exists.
  - This method provides safe access to the element directly above the given position without throwing an exception when at the top edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalLong containing the element at position (rowIndex - 1, columnIndex), or empty if rowIndex == 0
##### downOf(...) -> OptionalLong
- **Signature:** `public OptionalLong downOf(final int i, final int j)`
- **Summary:** Returns the element directly below the specified position, if it exists.
- **Contract:**
  - Returns the element directly below the specified position, if it exists.
  - This method provides safe access to the element directly below the given position without throwing an exception when at the bottom edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalLong containing the element at position (rowIndex + 1, columnIndex), or empty if rowIndex == rowCount - 1
##### leftOf(...) -> OptionalLong
- **Signature:** `public OptionalLong leftOf(final int i, final int j)`
- **Summary:** Returns the element directly to the left of the specified position, if it exists.
- **Contract:**
  - Returns the element directly to the left of the specified position, if it exists.
  - This method provides safe access to the element directly to the left of the given position without throwing an exception when at the leftmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalLong containing the element at position (rowIndex, columnIndex - 1), or empty if columnIndex == 0
##### rightOf(...) -> OptionalLong
- **Signature:** `public OptionalLong rightOf(final int i, final int j)`
- **Summary:** Returns the element directly to the right of the specified position, if it exists.
- **Contract:**
  - Returns the element directly to the right of the specified position, if it exists.
  - This method provides safe access to the element directly to the right of the given position without throwing an exception when at the rightmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an u.OptionalLong containing the element at position (rowIndex, columnIndex + 1), or empty if columnIndex == columnCount - 1
##### row(...) -> long\[\]
- **Signature:** `public long[] row(final int rowIndex) throws IllegalArgumentException`
- **Summary:** Returns the specified row as a long array.
- **Contract:**
  - If you need an independent copy, use {@code Arrays.copyOf(matrix.row(i), matrix.columnCount())} .
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to retrieve (0-based)
- **Returns:** the specified row array (direct reference to internal storage)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex &lt; 0 or rowIndex &gt; = rows
##### column(...) -> long\[\]
- **Signature:** `public long[] column(final int columnIndex) throws IllegalArgumentException`
- **Summary:** Returns a copy of the specified column as a new long array.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to retrieve (0-based)
- **Returns:** a new array containing the values from the specified column
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex &lt; 0 or columnIndex &gt; = columnCount
##### setRow(...) -> void
- **Signature:** `public void setRow(final int rowIndex, final long[] row) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified row by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of columns in the matrix.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to set (0-based)
  - `row` (`long[]`) — the array of values to copy into the row; must have length equal to the number of columns
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex is out of bounds or row length does not match column count
##### setColumn(...) -> void
- **Signature:** `public void setColumn(final int columnIndex, final long[] column) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified column by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of rows in the matrix.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to set (0-based)
  - `column` (`long[]`) — the array of values to copy into the column; must have length equal to the number of rows
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex is out of bounds or column length does not match row count
##### updateRow(...) -> void
- **Signature:** `public <E extends Exception> void updateRow(final int rowIndex, final Throwables.LongUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a row in-place by applying the specified operator to each element.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to update (0-based)
  - `operator` (`Throwables.LongUnaryOperator<E>`) — the operator to apply to each element in the row; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### updateColumn(...) -> void
- **Signature:** `public <E extends Exception> void updateColumn(final int columnIndex, final Throwables.LongUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in a column in-place by applying the specified operator to each element.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to update (0-based)
  - `operator` (`Throwables.LongUnaryOperator<E>`) — the operator to apply to each element in the column; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
##### getLU2RD(...) -> long\[\]
- **Signature:** `public long[] getLU2RD() throws IllegalStateException`
- **Summary:** Returns a copy of the elements on the main diagonal from left-upper to right-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new long array containing a copy of the main diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setLU2RD(...) -> void
- **Signature:** `public void setLU2RD(final long[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the main diagonal from left-upper to right-down (main diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array must have exactly as many elements as the matrix has rows.
  - The diagonal array length must exactly match the number of rows.
- **Parameters:**
  - `diagonal` (`long[]`) — the new values for the main diagonal; must have length == rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal rows
##### updateLU2RD(...) -> void
- **Signature:** `public <E extends Exception> void updateLU2RD(final Throwables.LongUnaryOperator<E> operator) throws E`
- **Summary:** Updates the values on the main diagonal (left-up to right-down) by applying the specified operator.
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - `operator` (`Throwables.LongUnaryOperator<E>`) — the operator to apply to each diagonal element; receives current element value and returns new value
- **Throws:**
  - `E` — if the operator throws an exception
##### getRU2LD(...) -> long\[\]
- **Signature:** `public long[] getRU2LD() throws IllegalStateException`
- **Summary:** Returns a copy of the elements on the anti-diagonal from right-upper to left-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new long array containing a copy of the anti-diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setRU2LD(...) -> void
- **Signature:** `public void setRU2LD(final long[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the anti-diagonal from right-upper to left-down (anti-diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array must have exactly as many elements as the matrix has rows.
- **Parameters:**
  - `diagonal` (`long[]`) — the new values for the anti-diagonal; must have length equal to rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal rows
##### updateRU2LD(...) -> void
- **Signature:** `public <E extends Exception> void updateRU2LD(final Throwables.LongUnaryOperator<E> operator) throws E`
- **Summary:** Updates the values on the anti-diagonal (right-up to left-down) by applying the specified operator.
- **Contract:**
  - The matrix must be square.
- **Parameters:**
  - `operator` (`Throwables.LongUnaryOperator<E>`) — the operator to apply to each anti-diagonal element; receives current element value and returns new value
- **Throws:**
  - `E` — if the operator throws an exception
##### updateAll(...) -> void
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.LongUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the matrix in-place by applying the specified operator.
- **Contract:**
  - Elements are processed in row-major order when executed sequentially.
- **Parameters:**
  - `operator` (`Throwables.LongUnaryOperator<E>`) — the operator to apply to each element; receives the current element value and returns the new value
- **Throws:**
  - `E` — if the operator throws an exception
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.IntBiFunction<Long, E> operator) throws E`
- **Summary:** Updates all elements in the matrix in-place based on their position (row and column indices).
- **Parameters:**
  - `operator` (`Throwables.IntBiFunction<Long, E>`) — the operator that receives row index and column index (0-based) and returns the new value for that position
- **Throws:**
  - `E` — if the operator throws an exception
##### replaceIf(...) -> void
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.LongPredicate<E> predicate, final long newValue) throws E`
- **Summary:** Conditionally replaces elements in-place based on a predicate.
- **Parameters:**
  - `predicate` (`Throwables.LongPredicate<E>`) — the condition to test each element; elements for which this returns {@code true} will be replaced
  - `newValue` (`long`) — the value to use for replacing matching elements
- **Throws:**
  - `E` — if the predicate throws an exception
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.IntBiPredicate<E> predicate, final long newValue) throws E`
- **Summary:** Conditionally replaces elements in-place based on their position (row and column indices).
- **Parameters:**
  - `predicate` (`Throwables.IntBiPredicate<E>`) — the condition that tests row index and column index (0-based); elements at positions for which this returns {@code true} will be replaced
  - `newValue` (`long`) — the value to use for replacing matching elements
- **Throws:**
  - `E` — if the predicate throws an exception
##### map(...) -> LongMatrix
- **Signature:** `public <E extends Exception> LongMatrix map(final Throwables.LongUnaryOperator<E> mapper) throws E`
- **Summary:** Creates a new LongMatrix by applying a transformation function to each element.
- **Parameters:**
  - `mapper` (`Throwables.LongUnaryOperator<E>`) — the function to apply to each element; receives the current element value and returns the transformed value
- **Returns:** a new LongMatrix with transformed values
- **Throws:**
  - `E` — if the function throws an exception
- **See also:** #updateAll(Throwables.LongUnaryOperator)
##### mapToInt(...) -> IntMatrix
- **Signature:** `public <E extends Exception> IntMatrix mapToInt(final Throwables.LongToIntFunction<E> mapper) throws E`
- **Summary:** Creates a new IntMatrix by applying the specified function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.LongToIntFunction<E>`) — the mapping function that converts each long element to an int; must not be null
- **Returns:** a new IntMatrix with the mapped values (same dimensions as the original)
- **Throws:**
  - `E` — if the function throws an exception
##### mapToDouble(...) -> DoubleMatrix
- **Signature:** `public <E extends Exception> DoubleMatrix mapToDouble(final Throwables.LongToDoubleFunction<E> mapper) throws E`
- **Summary:** Creates a new DoubleMatrix by applying the specified function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.LongToDoubleFunction<E>`) — the mapping function that converts each long element to a double; must not be null
- **Returns:** a new DoubleMatrix with the mapped values (same dimensions as the original)
- **Throws:**
  - `E` — if the function throws an exception
##### mapToObj(...) -> Matrix<T>
- **Signature:** `public <T, E extends Exception> Matrix<T> mapToObj(final Throwables.LongFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Creates a new object Matrix by applying the specified function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.LongFunction<? extends T, E>`) — the mapping function that converts each long element to type T; must not be null
  - `targetElementType` (`Class<T>`) — the class object representing the target element type (used for array creation); must not be null
- **Returns:** a new Matrix &lt; T &gt; with the mapped values (same dimensions as the original)
- **Throws:**
  - `E` — if the function throws an exception
##### fill(...) -> void
- **Signature:** `public void fill(final long val)`
- **Summary:** Fills all elements of the matrix with the specified value.
- **Parameters:**
  - `val` (`long`) — the value to fill the matrix with
- **Signature:** `public void fill(final long[][] b)`
- **Summary:** Fills the matrix with values from another two-dimensional array, starting at position (0, 0).
- **Contract:**
  - If the source array is larger, only the portion that fits is copied.
- **Parameters:**
  - `b` (`long[][]`) — the two-dimensional array to copy values from
- **Signature:** `public void fill(final int fromRowIndex, final int fromColumnIndex, final long[][] b) throws IllegalArgumentException`
- **Summary:** Fills a region of the matrix with values from another two-dimensional array, starting at the specified position.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index in this matrix (0-based, must be 0 &lt; = fromRowIndex &lt; = rows)
  - `fromColumnIndex` (`int`) — the starting column index in this matrix (0-based, must be 0 &lt; = fromColumnIndex &lt; = columnCount)
  - `b` (`long[][]`) — the source array to copy values from
- **Throws:**
  - `java.lang.IllegalArgumentException` — if fromRowIndex &lt; 0 or &gt; rows, or if fromColumnIndex &lt; 0 or &gt; columnCount
##### copy(...) -> LongMatrix
- **Signature:** `@Override public LongMatrix copy()`
- **Summary:** Returns a copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is a deep copy of this matrix with full independence guarantee
- **Signature:** `@Override public LongMatrix copy(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a row range from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a new LongMatrix containing the specified rows
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
- **Signature:** `@Override public LongMatrix copy(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a submatrix defined by row and column ranges.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a new LongMatrix containing the specified submatrix
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
##### extend(...) -> LongMatrix
- **Signature:** `public LongMatrix extend(final int newRowCount, final int newColumnCount)`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with 0L.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
- **Returns:** a new LongMatrix with the specified dimensions
- **Signature:** `public LongMatrix extend(final int newRowCount, final int newColumnCount, final long defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated from the top-left corner.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with the specified default value.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
  - `defaultValueForNewCell` (`long`) — the long value to fill new cells with during extension
- **Returns:** a new LongMatrix with the specified dimensions
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code newRowCount} or {@code newColumnCount} is negative, or if the resulting matrix would be too large (dimensions exceeding Integer.MAX_VALUE elements)
- **Signature:** `public LongMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight)`
- **Summary:** Creates a new matrix by extending this matrix in all four directions.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
- **Returns:** a new extended LongMatrix with dimensions ((toUp+rows+toDown) x (toLeft+columnCount+toRight))
- **Signature:** `public LongMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight, final long defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending this matrix in all four directions with padding.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
  - `defaultValueForNewCell` (`long`) — the long value to fill all new cells with
- **Returns:** a new extended LongMatrix with dimensions ((toUp+rows+toDown) x (toLeft+columnCount+toRight))
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any padding parameter is negative, or if the resulting dimensions would exceed Integer.MAX_VALUE
##### reverseH(...) -> void
- **Signature:** `public void reverseH()`
- **Summary:** Reverses the order of elements in each row (horizontal flip in-place).
- **Parameters:**
  - (none)
- **See also:** #flipH()
##### reverseV(...) -> void
- **Signature:** `public void reverseV()`
- **Summary:** Reverses the order of rows in the matrix (vertical flip in-place).
- **Parameters:**
  - (none)
- **See also:** #flipV()
##### flipH(...) -> LongMatrix
- **Signature:** `public LongMatrix flipH()`
- **Summary:** Creates a new matrix that is horizontally flipped (each row reversed).
- **Parameters:**
  - (none)
- **Returns:** a new matrix with each row reversed
- **See also:** #flipV(), IntMatrix#flipH(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1,</a>
##### flipV(...) -> LongMatrix
- **Signature:** `public LongMatrix flipV()`
- **Summary:** Creates a new matrix that is vertically flipped (each column reversed).
- **Parameters:**
  - (none)
- **Returns:** a new matrix with rows in reversed order
- **See also:** #flipH(), IntMatrix#flipV(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1,</a>
##### rotate90(...) -> LongMatrix
- **Signature:** `@Override public LongMatrix rotate90()`
- **Summary:** Rotates this matrix 90 degrees clockwise.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 90 degrees clockwise
##### rotate180(...) -> LongMatrix
- **Signature:** `@Override public LongMatrix rotate180()`
- **Summary:** Rotates this matrix 180 degrees.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 180 degrees
##### rotate270(...) -> LongMatrix
- **Signature:** `@Override public LongMatrix rotate270()`
- **Summary:** Rotates this matrix 270 degrees clockwise (or 90 degrees counter-clockwise).
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 270 degrees clockwise
##### transpose(...) -> LongMatrix
- **Signature:** `@Override public LongMatrix transpose()`
- **Summary:** Creates the transpose of this matrix by swapping rows and columns.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is the transpose of this matrix with dimensions columnCount × rows
##### reshape(...) -> LongMatrix
- **Signature:** `@SuppressFBWarnings("ICAST_INTEGER_MULTIPLY_CAST_TO_LONG") @Override public LongMatrix reshape(final int newRowCount, final int newColumnCount)`
- **Summary:** Reshapes the matrix to new dimensions while preserving element order.
- **Contract:**
  - <p> If the new shape has fewer total elements than the original, excess elements are truncated.
  - If the new shape has more total elements, the additional positions are filled with zeros.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the reshaped matrix
  - `newColumnCount` (`int`) — the number of columns in the reshaped matrix
- **Returns:** a new LongMatrix with the specified shape containing this matrix's elements
##### repelem(...) -> LongMatrix
- **Signature:** `@Override public LongMatrix repelem(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats elements in the matrix by the specified factors in both row and column directions.
- **Parameters:**
  - `rowRepeats` (`int`) — the number of times to repeat each element in the row direction
  - `colRepeats` (`int`) — the number of times to repeat each element in the column direction
- **Returns:** a new matrix with repeated elements
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rowRepeats} or {@code colRepeats} is less than or equal to 0
- **See also:** IntMatrix#repelem(int, int)
##### repmat(...) -> LongMatrix
- **Signature:** `@Override public LongMatrix repmat(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats the entire matrix as a tile pattern by the specified factors in both row and column directions.
- **Parameters:**
  - `rowRepeats` (`int`) — the number of times to repeat the matrix in the row direction
  - `colRepeats` (`int`) — the number of times to repeat the matrix in the column direction
- **Returns:** a new matrix with the original matrix repeated as tiles
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rowRepeats} or {@code colRepeats} is less than or equal to 0
- **See also:** IntMatrix#repmat(int, int)
##### flatten(...) -> LongList
- **Signature:** `@Override public LongList flatten()`
- **Summary:** Returns a list containing all matrix elements in row-major order (row by row, left to right).
- **Parameters:**
  - (none)
- **Returns:** a new LongList containing all elements in row-major order
##### flatOp(...) -> void
- **Signature:** `@Override public <E extends Exception> void flatOp(final Throwables.Consumer<? super long[], E> op) throws E`
- **Summary:** Applies an operation to each row array of the underlying two-dimensional array.
- **Parameters:**
  - `op` (`Throwables.Consumer<? super long[], E>`) — the operation to apply to each row array
- **Throws:**
  - `E` — if the operation throws an exception
- **See also:** Arrays#flatOp(long\[\]\[\], Throwables.Consumer)
##### vstack(...) -> LongMatrix
- **Signature:** `public LongMatrix vstack(final LongMatrix other) throws IllegalArgumentException`
- **Summary:** Vertically stacks this matrix with another matrix.
- **Contract:**
  - The two matrices must have the same number of columns.
- **Parameters:**
  - `other` (`LongMatrix`) — the matrix to stack below this matrix
- **Returns:** a new matrix with rows from both matrices stacked vertically
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same number of columns
- **See also:** IntMatrix#vstack(IntMatrix)
##### hstack(...) -> LongMatrix
- **Signature:** `public LongMatrix hstack(final LongMatrix other) throws IllegalArgumentException`
- **Summary:** Horizontally stacks this matrix with another matrix.
- **Contract:**
  - The two matrices must have the same number of rows.
- **Parameters:**
  - `other` (`LongMatrix`) — the matrix to stack to the right of this matrix
- **Returns:** a new matrix with columns from both matrices stacked horizontally
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same number of rows
- **See also:** IntMatrix#hstack(IntMatrix)
##### add(...) -> LongMatrix
- **Signature:** `public LongMatrix add(final LongMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise addition of this matrix with another matrix.
- **Contract:**
  - The two matrices must have the same dimensions.
- **Parameters:**
  - `other` (`LongMatrix`) — the matrix to add to this matrix
- **Returns:** a new matrix containing the element-wise sum
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same shape
##### subtract(...) -> LongMatrix
- **Signature:** `public LongMatrix subtract(final LongMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise subtraction of another matrix from this matrix.
- **Contract:**
  - The two matrices must have the same dimensions.
- **Parameters:**
  - `other` (`LongMatrix`) — the matrix to subtract from this matrix
- **Returns:** a new matrix containing the element-wise difference
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same shape
##### multiply(...) -> LongMatrix
- **Signature:** `public LongMatrix multiply(final LongMatrix other) throws IllegalArgumentException`
- **Summary:** Performs matrix multiplication with another matrix.
- **Contract:**
  - The number of columns in this matrix must equal the number of rows in the specified matrix.
- **Parameters:**
  - `other` (`LongMatrix`) — the matrix to multiply with this matrix
- **Returns:** a new matrix containing the matrix product
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrix dimensions are incompatible (this.columnCount != other.rowCount)
##### boxed(...) -> Matrix<Long>
- **Signature:** `public Matrix<Long> boxed()`
- **Summary:** Converts this primitive long matrix to a boxed {@code Matrix<Long>} .
- **Contract:**
  - Use this method only when you need to work with generic Matrix API or when null values are required.
- **Parameters:**
  - (none)
- **Returns:** a new {@code Matrix<Long>} containing boxed values
##### toFloatMatrix(...) -> FloatMatrix
- **Signature:** `public FloatMatrix toFloatMatrix()`
- **Summary:** Converts this long matrix to a float matrix.
- **Parameters:**
  - (none)
- **Returns:** a new {@code FloatMatrix} with values converted from long to float
##### toDoubleMatrix(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix toDoubleMatrix()`
- **Summary:** Converts this long matrix to a double matrix.
- **Contract:**
  - <p> <b> Note: </b> Very large long values (with absolute value greater than 2^53) may lose precision when converted to double, since double has only 53 bits of precision in its mantissa.
- **Parameters:**
  - (none)
- **Returns:** a new {@code DoubleMatrix} with values converted from long to double
##### zipWith(...) -> LongMatrix
- **Signature:** `public <E extends Exception> LongMatrix zipWith(final LongMatrix matrixB, final Throwables.LongBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Applies a binary operation element-wise to this matrix and another matrix.
- **Contract:**
  - The two matrices must have the same dimensions (same number of rows and columns).
- **Parameters:**
  - `matrixB` (`LongMatrix`) — the second matrix to zip with this matrix; must have the same dimensions
  - `zipFunction` (`Throwables.LongBinaryOperator<E>`) — the binary operation to apply to corresponding elements from this and matrixB
- **Returns:** a new LongMatrix with the results of the zip operation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same shape (rows and columns)
  - `E` — if the zip function throws an exception
- **Signature:** `public <E extends Exception> LongMatrix zipWith(final LongMatrix matrixB, final LongMatrix matrixC, final Throwables.LongTernaryOperator<E> zipFunction) throws E`
- **Summary:** Applies a ternary operation element-wise to this matrix and two other matrices.
- **Contract:**
  - All three matrices must have the same dimensions (same number of rows and columns).
- **Parameters:**
  - `matrixB` (`LongMatrix`) — the second matrix to zip with; must have the same dimensions as this matrix
  - `matrixC` (`LongMatrix`) — the third matrix to zip with; must have the same dimensions as this matrix
  - `zipFunction` (`Throwables.LongTernaryOperator<E>`) — the ternary operation to apply to corresponding elements from this, matrixB, and matrixC
- **Returns:** a new LongMatrix with the results of the zip operation
- **Throws:**
  - `E` — if the zip function throws an exception
##### streamLU2RD(...) -> LongStream
- **Signature:** `@Override public LongStream streamLU2RD()`
- **Summary:** Creates a stream of elements on the diagonal from left-upper to right-down.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a stream of diagonal elements from left-upper to right-down
##### streamRU2LD(...) -> LongStream
- **Signature:** `@Override public LongStream streamRU2LD()`
- **Summary:** Creates a stream of elements on the diagonal from right-upper to left-down.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a stream of diagonal elements from right-upper to left-down
##### streamH(...) -> LongStream
- **Signature:** `@Override public LongStream streamH()`
- **Summary:** Returns a stream of all matrix elements in row-major order (left to right, then top to bottom).
- **Parameters:**
  - (none)
- **Returns:** a stream of all matrix elements in row-major order, or an empty stream if the matrix is empty
- **Signature:** `@Override public LongStream streamH(final int rowIndex)`
- **Summary:** Returns a stream of elements from a single row.
- **Contract:**
  - <p> This method is particularly useful when you need to process or analyze a specific row of the matrix independently.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to stream (0-based)
- **Returns:** a stream of elements from the specified row
- **Signature:** `@Override public LongStream streamH(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Returns a stream of elements from a range of rows in row-major order.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a stream of elements from the specified row range, or an empty stream if the matrix is empty
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rows, or fromRowIndex &gt; toRowIndex
##### streamV(...) -> LongStream
- **Signature:** `@Override @Beta public LongStream streamV()`
- **Summary:** Creates a stream of all elements in the matrix in column-major order (vertically).
- **Parameters:**
  - (none)
- **Returns:** a stream of all matrix elements in column-major order
- **Signature:** `@Override public LongStream streamV(final int columnIndex)`
- **Summary:** Creates a stream of elements from a specific column.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to stream
- **Returns:** a stream of elements from the specified column
- **Signature:** `@Override @Beta public LongStream streamV(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of elements from a range of columns in column-major order.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a stream of elements from the specified column range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the column indices are out of bounds
##### streamR(...) -> Stream<LongStream>
- **Signature:** `@Override public Stream<LongStream> streamR()`
- **Summary:** Creates a stream of row streams, where each element is a stream of a complete row.
- **Parameters:**
  - (none)
- **Returns:** a stream of row streams
- **Signature:** `@Override public Stream<LongStream> streamR(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of row streams from a range of rows.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a stream of row streams from the specified range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the row indices are out of bounds
##### streamC(...) -> Stream<LongStream>
- **Signature:** `@Override @Beta public Stream<LongStream> streamC()`
- **Summary:** Creates a stream of column streams, where each element is a stream of a complete column.
- **Parameters:**
  - (none)
- **Returns:** a stream of column streams
- **Signature:** `@Override @Beta public Stream<LongStream> streamC(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of column streams from a range of columns.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a stream of column streams from the specified range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the column indices are out of bounds
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.LongConsumer<E> action) throws E`
- **Summary:** Applies the specified action to each element in the matrix.
- **Parameters:**
  - `action` (`Throwables.LongConsumer<E>`) — the action to apply to each element
- **Throws:**
  - `E` — if the action throws an exception
- **Signature:** `public <E extends Exception> void forEach(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.LongConsumer<E> action) throws IndexOutOfBoundsException, E`
- **Summary:** Applies the specified action to each element in a sub-region of the matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
  - `action` (`Throwables.LongConsumer<E>`) — the action to apply to each element in the specified region
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the indices are out of bounds \[0, rows\] or \[0, columnCount\], or if fromRowIndex &gt; toRowIndex or fromColumnIndex &gt; toColumnIndex
  - `E` — if the action throws an exception
##### println(...) -> String
- **Signature:** `@Override public String println()`
- **Summary:** Prints the matrix to the standard output.
- **Parameters:**
  - (none)
- **Returns:** the formatted string representation of the matrix
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this matrix.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this matrix
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this matrix to the specified object for equality.
- **Contract:**
  - Returns {@code true} if the given object is also a LongMatrix with the same dimensions and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the objects are equal, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this matrix

### Class LongTuple (com.landawn.abacus.util.LongTuple)
Abstract base class for immutable tuples containing long primitive values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> LongTuple1
- **Signature:** `public static LongTuple1 of(final long _1)`
- **Summary:** Creates a LongTuple.LongTuple1 containing a single long value.
- **Parameters:**
  - `_1` (`long`) — the long value to wrap in a tuple
- **Returns:** a new LongTuple.LongTuple1 containing the provided value
- **Signature:** `public static LongTuple2 of(final long _1, final long _2)`
- **Summary:** Creates a LongTuple.LongTuple2 containing two long values.
- **Parameters:**
  - `_1` (`long`) — the first long value
  - `_2` (`long`) — the second long value
- **Returns:** a new LongTuple.LongTuple2 containing the provided values
- **Signature:** `public static LongTuple3 of(final long _1, final long _2, final long _3)`
- **Summary:** Creates a LongTuple.LongTuple3 containing three long values.
- **Parameters:**
  - `_1` (`long`) — the first long value
  - `_2` (`long`) — the second long value
  - `_3` (`long`) — the third long value
- **Returns:** a new LongTuple.LongTuple3 containing the provided values
- **Signature:** `public static LongTuple4 of(final long _1, final long _2, final long _3, final long _4)`
- **Summary:** Creates a LongTuple.LongTuple4 containing four long values.
- **Parameters:**
  - `_1` (`long`) — the first long value
  - `_2` (`long`) — the second long value
  - `_3` (`long`) — the third long value
  - `_4` (`long`) — the fourth long value
- **Returns:** a new LongTuple.LongTuple4 containing the provided values
- **Signature:** `public static LongTuple5 of(final long _1, final long _2, final long _3, final long _4, final long _5)`
- **Summary:** Creates a LongTuple.LongTuple5 containing five long values.
- **Parameters:**
  - `_1` (`long`) — the first long value
  - `_2` (`long`) — the second long value
  - `_3` (`long`) — the third long value
  - `_4` (`long`) — the fourth long value
  - `_5` (`long`) — the fifth long value
- **Returns:** a new LongTuple.LongTuple5 containing the provided values
- **Signature:** `public static LongTuple6 of(final long _1, final long _2, final long _3, final long _4, final long _5, final long _6)`
- **Summary:** Creates a LongTuple.LongTuple6 containing six long values.
- **Parameters:**
  - `_1` (`long`) — the first long value
  - `_2` (`long`) — the second long value
  - `_3` (`long`) — the third long value
  - `_4` (`long`) — the fourth long value
  - `_5` (`long`) — the fifth long value
  - `_6` (`long`) — the sixth long value
- **Returns:** a new LongTuple.LongTuple6 containing the provided values
- **Signature:** `public static LongTuple7 of(final long _1, final long _2, final long _3, final long _4, final long _5, final long _6, final long _7)`
- **Summary:** Creates a LongTuple.LongTuple7 containing seven long values.
- **Parameters:**
  - `_1` (`long`) — the first long value
  - `_2` (`long`) — the second long value
  - `_3` (`long`) — the third long value
  - `_4` (`long`) — the fourth long value
  - `_5` (`long`) — the fifth long value
  - `_6` (`long`) — the sixth long value
  - `_7` (`long`) — the seventh long value
- **Returns:** a new LongTuple.LongTuple7 containing the provided values
- **Signature:** `@Deprecated public static LongTuple8 of(final long _1, final long _2, final long _3, final long _4, final long _5, final long _6, final long _7, final long _8)`
- **Summary:** Creates a LongTuple.LongTuple8 containing eight long values.
- **Parameters:**
  - `_1` (`long`) — the first long value
  - `_2` (`long`) — the second long value
  - `_3` (`long`) — the third long value
  - `_4` (`long`) — the fourth long value
  - `_5` (`long`) — the fifth long value
  - `_6` (`long`) — the sixth long value
  - `_7` (`long`) — the seventh long value
  - `_8` (`long`) — the eighth long value
- **Returns:** a new LongTuple.LongTuple8 containing the provided values
- **Signature:** `@Deprecated public static LongTuple9 of(final long _1, final long _2, final long _3, final long _4, final long _5, final long _6, final long _7, final long _8, final long _9)`
- **Summary:** Creates a LongTuple.LongTuple9 containing nine long values.
- **Parameters:**
  - `_1` (`long`) — the first long value
  - `_2` (`long`) — the second long value
  - `_3` (`long`) — the third long value
  - `_4` (`long`) — the fourth long value
  - `_5` (`long`) — the fifth long value
  - `_6` (`long`) — the sixth long value
  - `_7` (`long`) — the seventh long value
  - `_8` (`long`) — the eighth long value
  - `_9` (`long`) — the ninth long value
- **Returns:** a new LongTuple.LongTuple9 containing the provided values
##### create(...) -> TP
- **Signature:** `@SuppressWarnings("deprecation") public static <TP extends LongTuple<TP>> TP create(final long[] values)`
- **Summary:** Creates a LongTuple from an array of long values.
- **Parameters:**
  - `values` (`long[]`) — the array of long values (must have length 0-9), may be {@code null}
- **Returns:** a LongTuple of appropriate size containing the array values, or an empty LongTuple if the array is null or empty

#### Public Instance Methods
##### min(...) -> long
- **Signature:** `public long min()`
- **Summary:** Returns the minimum long value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the minimum long value in this tuple
##### max(...) -> long
- **Signature:** `public long max()`
- **Summary:** Returns the maximum long value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the maximum long value in this tuple
##### median(...) -> long
- **Signature:** `public long median()`
- **Summary:** Returns the median long value in this tuple.
- **Contract:**
  - <p> The median is calculated as follows: <ul> <li> For tuples with an odd number of elements, returns the middle value when sorted </li> <li> For tuples with an even number of elements, returns the lower middle value when sorted </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code LongTuple.LongTuple3 tuple = LongTuple.of(3L, 1L, 2L); long median = tuple.median(); // 2 LongTuple.LongTuple4 quad = LongTuple.of(1L, 2L, 3L, 4L); long median2 = quad.median(); // 2 (lower middle value) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median long value in this tuple
##### sum(...) -> long
- **Signature:** `public long sum()`
- **Summary:** Returns the sum of all elements in this tuple.
- **Contract:**
  - If the sum exceeds {@code Long.MAX_VALUE} , the result will wrap around according to standard long arithmetic.
- **Parameters:**
  - (none)
- **Returns:** the sum of all long values in this tuple
##### average(...) -> double
- **Signature:** `public double average()`
- **Summary:** Returns the average of all long values in this tuple as a double.
- **Parameters:**
  - (none)
- **Returns:** the average of all long values in this tuple as a double
##### reverse(...) -> TP
- **Signature:** `public abstract TP reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new tuple with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `public abstract boolean contains(long valueToFind)`
- **Summary:** Checks if this tuple contains the specified long value.
- **Contract:**
  - Checks if this tuple contains the specified long value.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code LongTuple.LongTuple3 tuple = LongTuple.of(1L, 2L, 3L); boolean hasTwo = tuple.contains(2L); // true boolean hasFive = tuple.contains(5L); // false LongTuple.LongTuple5 numbers = LongTuple.of(10L, 20L, 30L, 40L, 50L); if (numbers.contains(30L)) { System.out.println("Found 30!"); // This will be printed } } </pre>
- **Parameters:**
  - `valueToFind` (`long`) — the long value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### toArray(...) -> long\[\]
- **Signature:** `public long[] toArray()`
- **Summary:** Returns a new array containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new long array containing all tuple elements
##### toList(...) -> LongList
- **Signature:** `public LongList toList()`
- **Summary:** Returns a new LongList containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new LongList containing all tuple elements
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.LongConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple in order.
- **Contract:**
  - If the consumer throws an exception, iteration stops and the exception is propagated.
- **Parameters:**
  - `consumer` (`Throwables.LongConsumer<E>`) — the action to perform for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### stream(...) -> LongStream
- **Signature:** `public LongStream stream()`
- **Summary:** Returns a LongStream of all elements in this tuple.
- **Parameters:**
  - (none)
- **Returns:** a LongStream containing all tuple elements in order
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this tuple
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are of the same class and contain equal elements in the same order.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the objects are equal, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this tuple

### Class LongTuple1 (com.landawn.abacus.util.LongTuple.LongTuple1)
A tuple containing exactly one long value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 1.
- **Parameters:**
  - (none)
- **Returns:** 1
##### min(...) -> long
- **Signature:** `@Override public long min()`
- **Summary:** Returns the minimum value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single element value
##### max(...) -> long
- **Signature:** `@Override public long max()`
- **Summary:** Returns the maximum value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single element value
##### median(...) -> long
- **Signature:** `@Override public long median()`
- **Summary:** Returns the median value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single element value
##### sum(...) -> long
- **Signature:** `@Override public long sum()`
- **Summary:** Returns the sum of all values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single element value
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single element value as a double
##### reverse(...) -> LongTuple1
- **Signature:** `@Override public LongTuple1 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new LongTuple.LongTuple1 with the same value
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final long valueToFind)`
- **Summary:** Checks if this tuple contains the specified value.
- **Contract:**
  - Checks if this tuple contains the specified value.
- **Parameters:**
  - `valueToFind` (`long`) — the long value to search for
- **Returns:** {@code true} if the value equals _1, {@code false} otherwise
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** the hash code of the single element
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the object is a LongTuple.LongTuple1 with the same value
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string in the format "(value)"

### Class LongTuple2 (com.landawn.abacus.util.LongTuple.LongTuple2)
A tuple containing exactly two long values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 2.
- **Parameters:**
  - (none)
- **Returns:** 2
##### min(...) -> long
- **Signature:** `@Override public long min()`
- **Summary:** Returns the minimum value among the two elements.
- **Parameters:**
  - (none)
- **Returns:** the smaller of _1 and _2
##### max(...) -> long
- **Signature:** `@Override public long max()`
- **Summary:** Returns the maximum value among the two elements.
- **Parameters:**
  - (none)
- **Returns:** the larger of _1 and _2
##### median(...) -> long
- **Signature:** `@Override public long median()`
- **Summary:** Returns the median long value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the median (lower middle) long value
##### sum(...) -> long
- **Signature:** `@Override public long sum()`
- **Summary:** Returns the sum of the two elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 as a long
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the two elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2) / 2.0 as a double
##### reverse(...) -> LongTuple2
- **Signature:** `@Override public LongTuple2 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new LongTuple.LongTuple2 with values (_2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final long valueToFind)`
- **Summary:** Checks if either element equals the specified value.
- **Contract:**
  - Checks if either element equals the specified value.
- **Parameters:**
  - `valueToFind` (`long`) — the long value to search for
- **Returns:** {@code true} if valueToFind equals _1 or _2
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.LongConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.LongConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.LongBiConsumer<E> action) throws E`
- **Summary:** Performs the given bi-consumer action on the two elements of this tuple.
- **Parameters:**
  - `action` (`Throwables.LongBiConsumer<E>`) — the bi-consumer to perform on the two elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `@MayReturnNull public <U, E extends Exception> U map(final Throwables.LongBiFunction<U, E> mapper) throws E`
- **Summary:** Applies the given bi-function to the two elements and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.LongBiFunction<U, E>`) — the bi-function to apply to the two elements
- **Returns:** the result of applying the mapper function, may be {@code null}
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<LongTuple2>
- **Signature:** `public <E extends Exception> Optional<LongTuple2> filter(final Throwables.LongBiPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Contract:**
  - Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
  - If the predicate returns {@code true} , an Optional containing this tuple is returned.
- **Parameters:**
  - `predicate` (`Throwables.LongBiPredicate<E>`) — the bi-predicate to test the two elements
- **Returns:** an Optional containing this tuple if the predicate returns {@code true} , empty Optional otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** 31 * Long.hashCode(_1) + Long.hashCode(_2)
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the object is a LongTuple.LongTuple2 with the same values
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string in the format "(_1, _2)"

### Class LongTuple3 (com.landawn.abacus.util.LongTuple.LongTuple3)
A tuple containing exactly three long values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 3.
- **Parameters:**
  - (none)
- **Returns:** 3
##### min(...) -> long
- **Signature:** `@Override public long min()`
- **Summary:** Returns the minimum value among the three elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, and _3
##### max(...) -> long
- **Signature:** `@Override public long max()`
- **Summary:** Returns the maximum value among the three elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, and _3
##### median(...) -> long
- **Signature:** `@Override public long median()`
- **Summary:** Returns the median value of the three elements.
- **Contract:**
  - For tuples with an odd number of elements, returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the median long value
##### sum(...) -> long
- **Signature:** `@Override public long sum()`
- **Summary:** Returns the sum of all three elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 as a long
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all three elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3) / 3.0 as a double
##### reverse(...) -> LongTuple3
- **Signature:** `@Override public LongTuple3 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new LongTuple.LongTuple3 with values (_3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final long valueToFind)`
- **Summary:** Checks if any element equals the specified value.
- **Contract:**
  - Checks if any element equals the specified value.
- **Parameters:**
  - `valueToFind` (`long`) — the long value to search for
- **Returns:** {@code true} if valueToFind equals _1, _2, or _3
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.LongConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.LongConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.LongTriConsumer<E> action) throws E`
- **Summary:** Performs the given tri-consumer action on the three elements of this tuple.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code LongTuple.LongTuple3 triple = LongTuple.of(3L, 4L, 5L); triple.accept((a, b, c) -> { if (a*a + b*b == c*c) System.out.println("Pythagorean triple!"); }); LongTuple.LongTuple3 rgb = LongTuple.of(255L, 128L, 64L); rgb.accept((r, g, b) -> System.out.println("RGB(" + r + ", " + g + ", " + b + ")")); } </pre>
- **Parameters:**
  - `action` (`Throwables.LongTriConsumer<E>`) — the action to perform on the three elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `@MayReturnNull public <U, E extends Exception> U map(final Throwables.LongTriFunction<U, E> mapper) throws E`
- **Summary:** Applies the given tri-function to the three elements and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.LongTriFunction<U, E>`) — the tri-function to apply to the three elements
- **Returns:** the result of applying the mapper function, may be {@code null}
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<LongTuple3>
- **Signature:** `public <E extends Exception> Optional<LongTuple3> filter(final Throwables.LongTriPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Contract:**
  - Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
  - If the predicate returns {@code true} , an Optional containing this tuple is returned.
- **Parameters:**
  - `predicate` (`Throwables.LongTriPredicate<E>`) — the tri-predicate to test the three elements
- **Returns:** an Optional containing this tuple if the predicate returns {@code true} , empty Optional otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** (31 * (31 * Long.hashCode(_1) + Long.hashCode(_2))) + Long.hashCode(_3)
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the object is a LongTuple.LongTuple3 with the same values
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string in the format "(_1, _2, _3)"

### Class LongTuple4 (com.landawn.abacus.util.LongTuple.LongTuple4)
A tuple containing exactly four long values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 4.
- **Parameters:**
  - (none)
- **Returns:** 4
##### reverse(...) -> LongTuple4
- **Signature:** `@Override public LongTuple4 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new LongTuple.LongTuple4 with values (_4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final long valueToFind)`
- **Summary:** Checks if any element equals the specified value.
- **Contract:**
  - Checks if any element equals the specified value.
- **Parameters:**
  - `valueToFind` (`long`) — the long value to search for
- **Returns:** {@code true} if valueToFind equals any of the four elements
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.LongConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.LongConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### min(...) -> long
- **Signature:** `@Override public long min()`
- **Summary:** Returns the minimum value among the four elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, and _4
##### max(...) -> long
- **Signature:** `@Override public long max()`
- **Summary:** Returns the maximum value among the four elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, and _4
##### median(...) -> long
- **Signature:** `@Override public long median()`
- **Summary:** Returns the median value of the four elements.
- **Parameters:**
  - (none)
- **Returns:** the median (lower middle) long value
##### sum(...) -> long
- **Signature:** `@Override public long sum()`
- **Summary:** Returns the sum of all four elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 as a long
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all four elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4) / 4.0 as a double
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all four elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both LongTuple.LongTuple4 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a LongTuple.LongTuple4 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4)"

### Class LongTuple5 (com.landawn.abacus.util.LongTuple.LongTuple5)
A tuple containing exactly five long values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 5.
- **Parameters:**
  - (none)
- **Returns:** 5
##### min(...) -> long
- **Signature:** `@Override public long min()`
- **Summary:** Returns the minimum value among the five elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, and _5
##### max(...) -> long
- **Signature:** `@Override public long max()`
- **Summary:** Returns the maximum value among the five elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, and _5
##### median(...) -> long
- **Signature:** `@Override public long median()`
- **Summary:** Returns the median value of the five elements.
- **Contract:**
  - For tuples with an odd number of elements, returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the median long value
##### sum(...) -> long
- **Signature:** `@Override public long sum()`
- **Summary:** Returns the sum of all five elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 as a long
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all five elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5) / 5.0 as a double
##### reverse(...) -> LongTuple5
- **Signature:** `@Override public LongTuple5 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new LongTuple.LongTuple5 with values (_5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final long valueToFind)`
- **Summary:** Checks if any element equals the specified value.
- **Contract:**
  - Checks if any element equals the specified value.
- **Parameters:**
  - `valueToFind` (`long`) — the long value to search for
- **Returns:** {@code true} if valueToFind equals any of the five elements
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.LongConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.LongConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all five elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both LongTuple.LongTuple5 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a LongTuple.LongTuple5 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5)"

### Class LongTuple6 (com.landawn.abacus.util.LongTuple.LongTuple6)
A tuple containing exactly six long values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple (always 6).
- **Parameters:**
  - (none)
- **Returns:** 6
##### reverse(...) -> LongTuple6
- **Signature:** `@Override public LongTuple6 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new LongTuple.LongTuple6 with elements in order (_6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final long valueToFind)`
- **Summary:** Checks if this tuple contains the specified value.
- **Contract:**
  - Checks if this tuple contains the specified value.
- **Parameters:**
  - `valueToFind` (`long`) — the long value to search for
- **Returns:** {@code true} if any element equals the value, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.LongConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.LongConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### min(...) -> long
- **Signature:** `@Override public long min()`
- **Summary:** Returns the minimum value among the six elements.
- **Parameters:**
  - (none)
- **Returns:** the minimum of _1, _2, _3, _4, _5, and _6
##### max(...) -> long
- **Signature:** `@Override public long max()`
- **Summary:** Returns the maximum value among the six elements.
- **Parameters:**
  - (none)
- **Returns:** the maximum of _1, _2, _3, _4, _5, and _6
##### median(...) -> long
- **Signature:** `@Override public long median()`
- **Summary:** Returns the median value of the six elements.
- **Parameters:**
  - (none)
- **Returns:** the median (lower middle) long value
##### sum(...) -> long
- **Signature:** `@Override public long sum()`
- **Summary:** Returns the sum of the six elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the six elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6) / 6.0
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all six elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both LongTuple.LongTuple6 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a LongTuple.LongTuple6 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6)"

### Class LongTuple7 (com.landawn.abacus.util.LongTuple.LongTuple7)
A tuple containing exactly seven long values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple (always 7).
- **Parameters:**
  - (none)
- **Returns:** 7
##### reverse(...) -> LongTuple7
- **Signature:** `@Override public LongTuple7 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new LongTuple.LongTuple7 with elements in order (_7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final long valueToFind)`
- **Summary:** Checks if this tuple contains the specified value.
- **Contract:**
  - Checks if this tuple contains the specified value.
- **Parameters:**
  - `valueToFind` (`long`) — the long value to search for
- **Returns:** {@code true} if any element equals the value, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.LongConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.LongConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### min(...) -> long
- **Signature:** `@Override public long min()`
- **Summary:** Returns the minimum value among the seven elements.
- **Parameters:**
  - (none)
- **Returns:** the minimum of _1, _2, _3, _4, _5, _6, and _7
##### max(...) -> long
- **Signature:** `@Override public long max()`
- **Summary:** Returns the maximum value among the seven elements.
- **Parameters:**
  - (none)
- **Returns:** the maximum of _1, _2, _3, _4, _5, _6, and _7
##### median(...) -> long
- **Signature:** `@Override public long median()`
- **Summary:** Returns the median value of the seven elements.
- **Contract:**
  - For tuples with an odd number of elements, returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the median long value
##### sum(...) -> long
- **Signature:** `@Override public long sum()`
- **Summary:** Returns the sum of the seven elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the seven elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7) / 7.0
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all seven elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both LongTuple.LongTuple7 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a LongTuple.LongTuple7 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7)"

### Class LongTuple8 (com.landawn.abacus.util.LongTuple.LongTuple8)
A tuple containing exactly eight long values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple (always 8).
- **Parameters:**
  - (none)
- **Returns:** 8
##### reverse(...) -> LongTuple8
- **Signature:** `@Override public LongTuple8 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new LongTuple.LongTuple8 with elements in order (_8, _7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final long valueToFind)`
- **Summary:** Checks if this tuple contains the specified value.
- **Contract:**
  - Checks if this tuple contains the specified value.
- **Parameters:**
  - `valueToFind` (`long`) — the long value to search for
- **Returns:** {@code true} if any element equals the value, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.LongConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.LongConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### min(...) -> long
- **Signature:** `@Override public long min()`
- **Summary:** Returns the minimum value among the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the minimum of all eight elements
##### max(...) -> long
- **Signature:** `@Override public long max()`
- **Summary:** Returns the maximum value among the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the maximum of all eight elements
##### median(...) -> long
- **Signature:** `@Override public long median()`
- **Summary:** Returns the median value of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the median (lower middle) long value
##### sum(...) -> long
- **Signature:** `@Override public long sum()`
- **Summary:** Returns the sum of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7 + _8) / 8.0
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all eight elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both LongTuple.LongTuple8 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a LongTuple.LongTuple8 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7, _8)"

### Class LongTuple9 (com.landawn.abacus.util.LongTuple.LongTuple9)
A tuple containing exactly nine long values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple (always 9).
- **Parameters:**
  - (none)
- **Returns:** 9
##### reverse(...) -> LongTuple9
- **Signature:** `@Override public LongTuple9 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new LongTuple.LongTuple9 with elements in order (_9, _8, _7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final long valueToFind)`
- **Summary:** Checks if this tuple contains the specified value.
- **Contract:**
  - Checks if this tuple contains the specified value.
- **Parameters:**
  - `valueToFind` (`long`) — the long value to search for
- **Returns:** {@code true} if any element equals the value, {@code false} otherwise
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.LongConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.LongConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### min(...) -> long
- **Signature:** `@Override public long min()`
- **Summary:** Returns the minimum value among the nine elements.
- **Parameters:**
  - (none)
- **Returns:** the minimum of all nine elements
##### max(...) -> long
- **Signature:** `@Override public long max()`
- **Summary:** Returns the maximum value among the nine elements.
- **Parameters:**
  - (none)
- **Returns:** the maximum of all nine elements
##### median(...) -> long
- **Signature:** `@Override public long median()`
- **Summary:** Returns the median value of the nine elements.
- **Contract:**
  - For tuples with an odd number of elements, returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the median long value
##### sum(...) -> long
- **Signature:** `@Override public long sum()`
- **Summary:** Returns the sum of the nine elements.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 + _9
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the nine elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 + _9) / 9.0
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all nine elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both LongTuple.LongTuple9 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a LongTuple.LongTuple9 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7, _8, _9)"

### Class Matrix (com.landawn.abacus.util.Matrix)
A generic matrix implementation that stores elements in a two-dimensional array.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> Matrix<T>
- **Signature:** `@SafeVarargs public static <T> Matrix<T> of(final T[]... a)`
- **Summary:** Creates a Matrix from a two-dimensional array.
- **Contract:**
  - </p> <p> All rows must have the same length as the first row (rectangular array required).
  - The array must not be null.
- **Parameters:**
  - `a` (`T[][]`) — the two-dimensional array to create the matrix from (must not be null)
- **Returns:** a new Matrix containing the provided data
##### repeat(...) -> Matrix<T>
- **Signature:** `public static <T> Matrix<T> repeat(final int rowCount, final int columnCount, final T element) throws IllegalArgumentException`
- **Summary:** Creates a new matrix of the specified dimensions where every element is the provided {@code element} .
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
  - `element` (`T`) — the value to fill the matrix with (must not be null)
- **Returns:** a new Matrix of dimensions rowCount x columnCount filled with the specified element
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowCount or columnCount is negative, or if element is null
##### diagonalLU2RD(...) -> Matrix<T>
- **Signature:** `public static <T> Matrix<T> diagonalLU2RD(final T[] leftUp2RightDownDiagonal)`
- **Summary:** Creates a square diagonal matrix with the given values on the main diagonal (left-up to right-down).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`T[]`) — the diagonal values (must not be null)
- **Returns:** a square matrix with the given diagonal values on the main diagonal
- **See also:** #diagonal(Object\[\], Object\[\]), #diagonalRU2LD(Object\[\])
##### diagonalRU2LD(...) -> Matrix<T>
- **Signature:** `public static <T> Matrix<T> diagonalRU2LD(final T[] rightUp2LeftDownDiagonal)`
- **Summary:** Creates a square diagonal matrix with the given values on the anti-diagonal (right-up to left-down).
- **Parameters:**
  - `rightUp2LeftDownDiagonal` (`T[]`) — the anti-diagonal values (must not be null)
- **Returns:** a square matrix with the given anti-diagonal values
- **See also:** #diagonal(Object\[\], Object\[\]), #diagonalLU2RD(Object\[\])
##### diagonal(...) -> Matrix<T>
- **Signature:** `@SuppressWarnings("null") public static <T> Matrix<T> diagonal(final T[] leftUp2RightDownDiagonal, final T[] rightUp2LeftDownDiagonal) throws IllegalArgumentException`
- **Summary:** Creates a square matrix with values on both diagonals.
- **Contract:**
  - If diagonals intersect (odd dimension), the main diagonal value takes precedence.
  - At least one diagonal must be non-null.
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`T[]`) — the main diagonal values.
  - `rightUp2LeftDownDiagonal` (`T[]`) — the anti-diagonal values.
- **Returns:** a square matrix with the given diagonal values
- **Throws:**
  - `java.lang.IllegalArgumentException` — if both arrays are null, or if both diagonals are non-empty and have different lengths

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public Matrix(final T[][] a)`
- **Summary:** Constructs a Matrix from a two-dimensional array.
- **Contract:**
  - </p> <p> The array must be rectangular (all rows must have the same length).
- **Parameters:**
  - `a` (`T[][]`) — the two-dimensional array of elements (must not be null)
##### componentType(...) -> Class
- **Signature:** `@SuppressWarnings("rawtypes") @Override public Class componentType()`
- **Summary:** Returns the component type of the elements in this matrix.
- **Contract:**
  - This is useful for reflection-based operations or when creating new arrays of the same type as the matrix elements.
- **Parameters:**
  - (none)
- **Returns:** the Class object representing the element type
##### get(...) -> T
- **Signature:** `@MayReturnNull public T get(final int i, final int j)`
- **Summary:** Gets the element at the specified row and column.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** the element at position ( {@code i} , {@code j} )
- **Signature:** `@MayReturnNull public T get(final Point point)`
- **Summary:** Gets the element at the specified point.
- **Parameters:**
  - `point` (`Point`) — the point containing row and column indices
- **Returns:** the element at the specified point
##### set(...) -> void
- **Signature:** `public void set(final int i, final int j, final T val)`
- **Summary:** Sets the element at the specified row and column.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
  - `val` (`T`) — the new value to set
- **Signature:** `public void set(final Point point, final T val)`
- **Summary:** Sets the element at the specified point.
- **Parameters:**
  - `point` (`Point`) — the point containing row and column indices
  - `val` (`T`) — the new value to set
##### upOf(...) -> Nullable<T>
- **Signature:** `public Nullable<T> upOf(final int i, final int j)`
- **Summary:** Returns the element directly above the specified position, if it exists.
- **Contract:**
  - Returns the element directly above the specified position, if it exists.
  - If the specified position is in the first row (i == 0), returns an empty Nullable.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** a Nullable containing the element at position (rowIndex - 1, columnIndex), or empty if rowIndex == 0
##### downOf(...) -> Nullable<T>
- **Signature:** `public Nullable<T> downOf(final int i, final int j)`
- **Summary:** Returns the element directly below the specified position, if it exists.
- **Contract:**
  - Returns the element directly below the specified position, if it exists.
  - If the specified position is in the last row, returns an empty Nullable.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** a Nullable containing the element at position (rowIndex + 1, columnIndex), or empty if rowIndex == rowCount - 1
##### leftOf(...) -> Nullable<T>
- **Signature:** `public Nullable<T> leftOf(final int i, final int j)`
- **Summary:** Returns the element directly to the left of the specified position, if it exists.
- **Contract:**
  - Returns the element directly to the left of the specified position, if it exists.
  - If the specified position is in the first column (j == 0), returns an empty Nullable.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** a Nullable containing the element at position (rowIndex, columnIndex - 1), or empty if columnIndex == 0
##### rightOf(...) -> Nullable<T>
- **Signature:** `public Nullable<T> rightOf(final int i, final int j)`
- **Summary:** Returns the element directly to the right of the specified position, if it exists.
- **Contract:**
  - Returns the element directly to the right of the specified position, if it exists.
  - If the specified position is in the last column, returns an empty Nullable.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** a Nullable containing the element at position (rowIndex, columnIndex + 1), or empty if columnIndex == columnCount - 1
##### row(...) -> T\[\]
- **Signature:** `public T[] row(final int rowIndex) throws IllegalArgumentException`
- **Summary:** Returns a reference to the internal array containing the specified row.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code Matrix<String> matrix = Matrix.of(new String\[\]\[\] {{"A", "B"}, {"C", "D"}}); String\[\] rowData = matrix.row(0); rowData\[0\] = "X"; // This modifies the matrix directly // Matrix is now: \[\["X", "B"\], \["C", "D"\]\] // Use clone() if you need an independent copy String\[\] rowCopy = matrix.row(1).clone(); rowCopy\[0\] = "Y"; // Does not affect the matrix } </pre>
- **Parameters:**
  - `rowIndex` (`int`) — the row index to retrieve (0-based)
- **Returns:** the internal array containing the row elements (not a copy - modifications will affect the matrix)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex is negative or greater than or equal to the number of rows
##### column(...) -> T\[\]
- **Signature:** `public T[] column(final int columnIndex) throws IllegalArgumentException`
- **Summary:** Returns a copy of the specified column as an array.
- **Parameters:**
  - `columnIndex` (`int`) — the column index to retrieve (0-based)
- **Returns:** a new array containing a copy of the column elements
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex is negative or greater than or equal to the number of columns
##### setRow(...) -> void
- **Signature:** `public void setRow(final int rowIndex, final T[] row) throws IllegalArgumentException`
- **Summary:** Replaces an entire row with values from the given array.
- **Contract:**
  - The array must have the same length as the number of columns in this matrix.
- **Parameters:**
  - `rowIndex` (`int`) — the row index to replace (0-based)
  - `row` (`T[]`) — the new row data (must have exactly {@code columnCount} elements)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex is out of bounds or row length does not match column count
##### setColumn(...) -> void
- **Signature:** `public void setColumn(final int columnIndex, final T[] column) throws IllegalArgumentException`
- **Summary:** Replaces an entire column with values from the given array.
- **Contract:**
  - The array must have the same length as the number of rows in this matrix.
- **Parameters:**
  - `columnIndex` (`int`) — the column index to replace (0-based)
  - `column` (`T[]`) — the new column data (must have exactly {@code rows} elements)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex is out of bounds or column length does not match row count
##### updateRow(...) -> void
- **Signature:** `public <E extends Exception> void updateRow(final int rowIndex, final Throwables.UnaryOperator<T, E> operator) throws E`
- **Summary:** Updates all elements in the specified row by applying the given operator.
- **Parameters:**
  - `rowIndex` (`int`) — the row index to update (0-based)
  - `operator` (`Throwables.UnaryOperator<T, E>`) — the operator to apply to each element (must not be null)
- **Throws:**
  - `E` — if the operator throws an exception
##### updateColumn(...) -> void
- **Signature:** `public <E extends Exception> void updateColumn(final int columnIndex, final Throwables.UnaryOperator<T, E> operator) throws E`
- **Summary:** Updates all elements in the specified column by applying the given operator.
- **Parameters:**
  - `columnIndex` (`int`) — the column index to update (0-based)
  - `operator` (`Throwables.UnaryOperator<T, E>`) — the operator to apply to each element (must not be null)
- **Throws:**
  - `E` — if the operator throws an exception
##### getLU2RD(...) -> T\[\]
- **Signature:** `public T[] getLU2RD() throws IllegalStateException`
- **Summary:** Gets the main diagonal elements (left-up to right-down).
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a new array containing the diagonal elements from top-left to bottom-right
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columnCount)
##### setLU2RD(...) -> void
- **Signature:** `public void setLU2RD(final T[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the main diagonal elements (left-up to right-down).
- **Contract:**
  - The matrix must be square (same number of rows and columns).
  - The diagonal array must have exactly as many elements as the matrix dimension.
- **Parameters:**
  - `diagonal` (`T[]`) — the new diagonal values (must not be null and must have exactly {@code rows} elements)
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columnCount)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal to rows
##### updateLU2RD(...) -> void
- **Signature:** `public <E extends Exception> void updateLU2RD(final Throwables.UnaryOperator<T, E> operator) throws E`
- **Summary:** Updates the main diagonal elements (left-up to right-down) by applying the given operator.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - `operator` (`Throwables.UnaryOperator<T, E>`) — the operator to apply to each diagonal element (must not be null)
- **Throws:**
  - `E` — if the operator throws an exception
##### getRU2LD(...) -> T\[\]
- **Signature:** `public T[] getRU2LD() throws IllegalStateException`
- **Summary:** Gets the anti-diagonal elements (right-up to left-down).
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a new array containing the anti-diagonal elements from top-right to bottom-left
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columnCount)
##### setRU2LD(...) -> void
- **Signature:** `public void setRU2LD(final T[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the anti-diagonal elements (right-up to left-down).
- **Contract:**
  - The matrix must be square (same number of rows and columns).
  - The diagonal array must have exactly as many elements as the matrix dimension.
- **Parameters:**
  - `diagonal` (`T[]`) — the new anti-diagonal values (must not be null and must have exactly {@code rows} elements)
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columnCount)
  - `java.lang.IllegalArgumentException` — if diagonal array does not have exactly {@code rows} elements
##### updateRU2LD(...) -> void
- **Signature:** `public <E extends Exception> void updateRU2LD(final Throwables.UnaryOperator<T, E> operator) throws E`
- **Summary:** Updates the anti-diagonal elements (right-up to left-down) by applying the given operator.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - `operator` (`Throwables.UnaryOperator<T, E>`) — the operator to apply to each anti-diagonal element (must not be null)
- **Throws:**
  - `E` — if the operator throws an exception
##### updateAll(...) -> void
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.UnaryOperator<T, E> operator) throws E`
- **Summary:** Updates all elements in the matrix by applying the given operator.
- **Parameters:**
  - `operator` (`Throwables.UnaryOperator<T, E>`) — the operator to apply to each element (must not be null)
- **Throws:**
  - `E` — if the operator throws an exception
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.IntBiFunction<? extends T, E> operator) throws E`
- **Summary:** Updates all elements in the matrix based on their position.
- **Parameters:**
  - `operator` (`Throwables.IntBiFunction<? extends T, E>`) — the operator that takes row and column indices and returns the new value (must not be null)
- **Throws:**
  - `E` — if the operator throws an exception
##### replaceIf(...) -> void
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.Predicate<? super T, E> predicate, final T newValue) throws E`
- **Summary:** Replaces all elements that match the predicate with the new value.
- **Parameters:**
  - `predicate` (`Throwables.Predicate<? super T, E>`) — the condition to test each element (must not be null)
  - `newValue` (`T`) — the value to use as replacement (can be null)
- **Throws:**
  - `E` — if the predicate throws an exception
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.IntBiPredicate<E> predicate, final T newValue) throws E`
- **Summary:** Replaces elements based on their position using a predicate.
- **Parameters:**
  - `predicate` (`Throwables.IntBiPredicate<E>`) — the condition based on position (must not be null)
  - `newValue` (`T`) — the value to use as replacement (can be null)
- **Throws:**
  - `E` — if the predicate throws an exception
##### map(...) -> Matrix<T>
- **Signature:** `public <E extends Exception> Matrix<T> map(final Throwables.UnaryOperator<T, E> mapper) throws E`
- **Summary:** Creates a new matrix by applying a transformation function to each element.
- **Parameters:**
  - `mapper` (`Throwables.UnaryOperator<T, E>`) — the transformation function
- **Returns:** a new matrix with transformed elements
- **Throws:**
  - `E` — if the function throws an exception
- **Signature:** `public <R, E extends Exception> Matrix<R> map(final Throwables.Function<? super T, R, E> mapper, final Class<R> targetElementType) throws E`
- **Summary:** Creates a new matrix by applying a transformation function to each element.
- **Contract:**
  - The target element type must be explicitly specified.
- **Parameters:**
  - `mapper` (`Throwables.Function<? super T, R, E>`) — the transformation function
  - `targetElementType` (`Class<R>`) — the class of the result element type
- **Returns:** a new matrix with transformed elements
- **Throws:**
  - `E` — if the function throws an exception
##### mapToBoolean(...) -> BooleanMatrix
- **Signature:** `public <E extends Exception> BooleanMatrix mapToBoolean(final Throwables.ToBooleanFunction<? super T, E> mapper) throws E`
- **Summary:** Creates a boolean matrix by applying a boolean-valued function to each element.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Check for null values BooleanMatrix nullMask = matrix.mapToBoolean(Objects::isNull); // Check if numbers are positive BooleanMatrix positive = numberMatrix.mapToBoolean(x -> x > 0); // Check string length BooleanMatrix longStrings = stringMatrix.mapToBoolean(s -> s.length() > 10); } </pre>
- **Parameters:**
  - `mapper` (`Throwables.ToBooleanFunction<? super T, E>`) — the function that returns a boolean for each element
- **Returns:** a new BooleanMatrix
- **Throws:**
  - `E` — if the function throws an exception
##### mapToByte(...) -> ByteMatrix
- **Signature:** `public <E extends Exception> ByteMatrix mapToByte(final Throwables.ToByteFunction<? super T, E> mapper) throws E`
- **Summary:** Creates a byte matrix by applying a byte-valued function to each element.
- **Parameters:**
  - `mapper` (`Throwables.ToByteFunction<? super T, E>`) — the function that returns a byte for each element
- **Returns:** a new ByteMatrix
- **Throws:**
  - `E` — if the function throws an exception
##### mapToChar(...) -> CharMatrix
- **Signature:** `public <E extends Exception> CharMatrix mapToChar(final Throwables.ToCharFunction<? super T, E> mapper) throws E`
- **Summary:** Creates a char matrix by applying a char-valued function to each element.
- **Parameters:**
  - `mapper` (`Throwables.ToCharFunction<? super T, E>`) — the function that returns a char for each element
- **Returns:** a new CharMatrix
- **Throws:**
  - `E` — if the function throws an exception
##### mapToShort(...) -> ShortMatrix
- **Signature:** `public <E extends Exception> ShortMatrix mapToShort(final Throwables.ToShortFunction<? super T, E> mapper) throws E`
- **Summary:** Creates a short matrix by applying a short-valued function to each element.
- **Parameters:**
  - `mapper` (`Throwables.ToShortFunction<? super T, E>`) — the function that returns a short for each element
- **Returns:** a new ShortMatrix
- **Throws:**
  - `E` — if the function throws an exception
##### mapToInt(...) -> IntMatrix
- **Signature:** `public <E extends Exception> IntMatrix mapToInt(final Throwables.ToIntFunction<? super T, E> mapper) throws E`
- **Summary:** Creates an int matrix by applying an int-valued function to each element.
- **Parameters:**
  - `mapper` (`Throwables.ToIntFunction<? super T, E>`) — the function that returns an int for each element
- **Returns:** a new IntMatrix
- **Throws:**
  - `E` — if the function throws an exception
##### mapToLong(...) -> LongMatrix
- **Signature:** `public <E extends Exception> LongMatrix mapToLong(final Throwables.ToLongFunction<? super T, E> mapper) throws E`
- **Summary:** Creates a long matrix by applying a long-valued function to each element.
- **Parameters:**
  - `mapper` (`Throwables.ToLongFunction<? super T, E>`) — the function that returns a long for each element
- **Returns:** a new LongMatrix
- **Throws:**
  - `E` — if the function throws an exception
##### mapToFloat(...) -> FloatMatrix
- **Signature:** `public <E extends Exception> FloatMatrix mapToFloat(final Throwables.ToFloatFunction<? super T, E> mapper) throws E`
- **Summary:** Creates a float matrix by applying a float-valued function to each element.
- **Parameters:**
  - `mapper` (`Throwables.ToFloatFunction<? super T, E>`) — the function that returns a float for each element
- **Returns:** a new FloatMatrix
- **Throws:**
  - `E` — if the function throws an exception
##### mapToDouble(...) -> DoubleMatrix
- **Signature:** `public <E extends Exception> DoubleMatrix mapToDouble(final Throwables.ToDoubleFunction<? super T, E> mapper) throws E`
- **Summary:** Creates a double matrix by applying a double-valued function to each element.
- **Parameters:**
  - `mapper` (`Throwables.ToDoubleFunction<? super T, E>`) — the function that returns a double for each element
- **Returns:** a new DoubleMatrix
- **Throws:**
  - `E` — if the function throws an exception
##### fill(...) -> void
- **Signature:** `public void fill(final T val)`
- **Summary:** Fills all elements in the matrix with the specified value.
- **Parameters:**
  - `val` (`T`) — the value to fill the matrix with (can be null)
- **Signature:** `public void fill(final T[][] b)`
- **Summary:** Fills the matrix with values from another two-dimensional array.
- **Contract:**
  - If the source array is larger than this matrix, extra data is ignored.
  - If the source array is smaller than this matrix, the remaining cells are unchanged.
- **Parameters:**
  - `b` (`T[][]`) — the source two-dimensional array to copy values from (must not be null)
- **Signature:** `public void fill(final int fromRowIndex, final int fromColumnIndex, final T[][] b) throws IllegalArgumentException`
- **Summary:** Fills the matrix with values from another two-dimensional array starting at the specified position.
- **Contract:**
  - If the source data extends beyond the matrix bounds, it is truncated.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (0-based, must be between 0 and rows inclusive)
  - `fromColumnIndex` (`int`) — the starting column index (0-based, must be between 0 and columnCount inclusive)
  - `b` (`T[][]`) — the source two-dimensional array to copy values from (must not be null)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the starting indices are negative or exceed matrix dimensions
##### copy(...) -> Matrix<T>
- **Signature:** `@Override public Matrix<T> copy()`
- **Summary:** Creates a copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is a copy of this matrix with the same dimensions and values
- **Signature:** `@Override public Matrix<T> copy(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a row range from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a new matrix containing the specified rows with dimensions (toRowIndex - fromRowIndex) × columnCount
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rows, or fromRowIndex &gt; toRowIndex
- **Signature:** `@Override public Matrix<T> copy(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a rectangular sub-matrix defined by row and column ranges.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a new matrix containing the specified region with dimensions (toRowIndex - fromRowIndex) × (toColumnIndex - fromColumnIndex)
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is out of bounds, fromRowIndex &gt; toRowIndex, or fromColumnIndex &gt; toColumnIndex
##### extend(...) -> Matrix<T>
- **Signature:** `public Matrix<T> extend(final int newRowCount, final int newColumnCount)`
- **Summary:** Creates a new matrix with the specified dimensions by extending or truncating this matrix.
- **Contract:**
  - If the new dimensions are larger, new cells are filled with null values.
  - If the new dimensions are smaller, the matrix is truncated.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix
  - `newColumnCount` (`int`) — the number of columns in the new matrix
- **Returns:** a new matrix with the specified dimensions
- **Signature:** `public Matrix<T> extend(final int newRowCount, final int newColumnCount, final T defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix with the specified dimensions by extending or truncating this matrix.
- **Contract:**
  - If the new dimensions are larger, new cells are filled with the specified default value.
  - If the new dimensions are smaller, the matrix is truncated.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix
  - `newColumnCount` (`int`) — the number of columns in the new matrix
  - `defaultValueForNewCell` (`T`) — the value to fill new cells with (can be null)
- **Returns:** a new matrix with the specified dimensions
- **Throws:**
  - `java.lang.IllegalArgumentException` — if newRowCount or newColumnCount is negative
- **Signature:** `public Matrix<T> extend(final int toUp, final int toDown, final int toLeft, final int toRight)`
- **Summary:** Extends the matrix by adding rows and columns in all directions.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add at the top (must be non-negative)
  - `toDown` (`int`) — number of rows to add at the bottom (must be non-negative)
  - `toLeft` (`int`) — number of columns to add on the left (must be non-negative)
  - `toRight` (`int`) — number of columns to add on the right (must be non-negative)
- **Returns:** a new extended matrix with dimensions (toUp + rows + toDown) x (toLeft + columnCount + toRight)
- **Signature:** `public Matrix<T> extend(final int toUp, final int toDown, final int toLeft, final int toRight, final T defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Extends the matrix by adding rows and columns in all directions.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add at the top (must be non-negative)
  - `toDown` (`int`) — number of rows to add at the bottom (must be non-negative)
  - `toLeft` (`int`) — number of columns to add on the left (must be non-negative)
  - `toRight` (`int`) — number of columns to add on the right (must be non-negative)
  - `defaultValueForNewCell` (`T`) — the value to fill new cells with (can be null)
- **Returns:** a new extended matrix with dimensions (toUp + rows + toDown) x (toLeft + columnCount + toRight)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any extension parameter is negative
##### reverseH(...) -> void
- **Signature:** `public void reverseH()`
- **Summary:** Reverses the order of elements in each row (horizontal flip).
- **Parameters:**
  - (none)
- **See also:** #flipH()
##### reverseV(...) -> void
- **Signature:** `public void reverseV()`
- **Summary:** Reverses the order of rows in the matrix (vertical flip).
- **Parameters:**
  - (none)
- **See also:** #flipV()
##### flipH(...) -> Matrix<T>
- **Signature:** `public Matrix<T> flipH()`
- **Summary:** Creates a new matrix that is horizontally flipped (each row reversed).
- **Parameters:**
  - (none)
- **Returns:** a new horizontally flipped matrix
- **See also:** #flipV(), IntMatrix#flipH(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1,</a>
##### flipV(...) -> Matrix<T>
- **Signature:** `public Matrix<T> flipV()`
- **Summary:** Creates a new matrix that is vertically flipped (each column reversed).
- **Parameters:**
  - (none)
- **Returns:** a new vertically flipped matrix
- **See also:** #flipH(), IntMatrix#flipV(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1,</a>
##### rotate90(...) -> Matrix<T>
- **Signature:** `@Override public Matrix<T> rotate90()`
- **Summary:** Rotates this matrix 90 degrees clockwise.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 90 degrees clockwise with dimensions columnCount × rows
##### rotate180(...) -> Matrix<T>
- **Signature:** `@Override public Matrix<T> rotate180()`
- **Summary:** Rotates this matrix 180 degrees.
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 180 degrees with the same dimensions (rows × columnCount)
##### rotate270(...) -> Matrix<T>
- **Signature:** `@Override public Matrix<T> rotate270()`
- **Summary:** Rotates this matrix 270 degrees clockwise (or 90 degrees counter-clockwise).
- **Parameters:**
  - (none)
- **Returns:** a new matrix rotated 270 degrees clockwise with dimensions columnCount × rows
##### transpose(...) -> Matrix<T>
- **Signature:** `@Override public Matrix<T> transpose()`
- **Summary:** Creates the transpose of this matrix by swapping rows and columns.
- **Parameters:**
  - (none)
- **Returns:** a new matrix that is the transpose of this matrix with dimensions columnCount × rows
##### reshape(...) -> Matrix<T>
- **Signature:** `@SuppressFBWarnings("ICAST_INTEGER_MULTIPLY_CAST_TO_LONG") @Override public Matrix<T> reshape(final int newRowCount, final int newColumnCount)`
- **Summary:** Reshapes the matrix to new dimensions while preserving element order.
- **Contract:**
  - If the new shape has fewer total elements, extra elements from the original matrix are truncated.
  - If the new shape has more total elements, the additional positions are filled with {@code null} .
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the reshaped matrix (must be non-negative)
  - `newColumnCount` (`int`) — the number of columns in the reshaped matrix (must be non-negative)
- **Returns:** a new matrix with the specified dimensions (newRowCount × newColumnCount)
##### repelem(...) -> Matrix<T>
- **Signature:** `@Override public Matrix<T> repelem(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats each element in the matrix by the specified number of times in both directions.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat each element in the row direction (must be &gt; = 1)
  - `colRepeats` (`int`) — number of times to repeat each element in the column direction (must be &gt; = 1)
- **Returns:** a new matrix with repeated elements, dimensions (rows × rowRepeats) × (columnCount × colRepeats)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats &lt; 1 or colRepeats &lt; 1
- **See also:** <a href="https://www.mathworks.com/help/matlab/ref/repelem.html">,MATLAB repelem,</a>
##### repmat(...) -> Matrix<T>
- **Signature:** `@Override public Matrix<T> repmat(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats the entire matrix as a tile pattern by the specified number of times.
- **Parameters:**
  - `rowRepeats` (`int`) — number of times to repeat the matrix in the row direction (must be &gt; = 1)
  - `colRepeats` (`int`) — number of times to repeat the matrix in the column direction (must be &gt; = 1)
- **Returns:** a new matrix with the original matrix repeated, dimensions (rows × rowRepeats) × (columnCount × colRepeats)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowRepeats &lt; 1 or colRepeats &lt; 1
- **See also:** <a href="https://www.mathworks.com/help/matlab/ref/repmat.html">,MATLAB repmat,</a>
##### flatten(...) -> List<T>
- **Signature:** `@Override public List<T> flatten()`
- **Summary:** Flattens the matrix into a one-dimensional list by reading elements row by row.
- **Parameters:**
  - (none)
- **Returns:** a new list containing all elements in row-major order with size equal to count
##### flatOp(...) -> void
- **Signature:** `@Override public <E extends Exception> void flatOp(final Throwables.Consumer<? super T[], E> op) throws E`
- **Summary:** Applies an operation to each row array of the matrix by passing the row array directly to the operation.
- **Parameters:**
  - `op` (`Throwables.Consumer<? super T[], E>`) — the operation to apply to each internal row array
- **Throws:**
  - `E` — if the operation throws an exception
- **See also:** ff#flatOp(Object\[\]\[\], Throwables.Consumer)
##### vstack(...) -> Matrix<T>
- **Signature:** `public Matrix<T> vstack(final Matrix<? extends T> other) throws IllegalArgumentException`
- **Summary:** Vertically stacks this matrix with another matrix.
- **Contract:**
  - The matrices must have the same number of columns.
- **Parameters:**
  - `other` (`Matrix<? extends T>`) — the matrix to stack below this matrix (must not be null)
- **Returns:** a new vertically stacked matrix with dimensions (this.rowCount + other.rowCount) × columnCount
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different column counts
- **See also:** #hstack(Matrix), IntMatrix#vstack(IntMatrix)
##### hstack(...) -> Matrix<T>
- **Signature:** `public Matrix<T> hstack(final Matrix<? extends T> other) throws IllegalArgumentException`
- **Summary:** Horizontally stacks this matrix with another matrix.
- **Contract:**
  - The matrices must have the same number of rows.
- **Parameters:**
  - `other` (`Matrix<? extends T>`) — the matrix to stack to the right of this matrix (must not be null)
- **Returns:** a new horizontally stacked matrix with dimensions rowCount × (this.columnCount + other.columnCount)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different row counts
- **See also:** #vstack(Matrix), IntMatrix#hstack(IntMatrix)
##### zipWith(...) -> Matrix<T>
- **Signature:** `public <B, E extends Exception> Matrix<T> zipWith(final Matrix<B> matrixB, final Throwables.BiFunction<? super T, ? super B, T, E> zipFunction) throws E`
- **Summary:** Combines this matrix with another matrix element-wise using the specified function.
- **Contract:**
  - Both matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`Matrix<B>`) — the other matrix to zip with (must have the same dimensions, must not be null)
  - `zipFunction` (`Throwables.BiFunction<? super T, ? super B, T, E>`) — the binary function to apply to corresponding elements (must not be null)
- **Returns:** a new matrix with the results of the zip function
- **Throws:**
  - `E` — if the zip function throws an exception
- **Signature:** `public <B, R, E extends Exception> Matrix<R> zipWith(final Matrix<B> matrixB, final Throwables.BiFunction<? super T, ? super B, R, E> zipFunction, final Class<R> targetElementType) throws IllegalArgumentException, E`
- **Summary:** Combines this matrix with another matrix element-wise using the specified function.
- **Contract:**
  - The matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`Matrix<B>`) — the other matrix to zip with (must have the same dimensions, must not be null)
  - `zipFunction` (`Throwables.BiFunction<? super T, ? super B, R, E>`) — the function to apply to corresponding elements (must not be null)
  - `targetElementType` (`Class<R>`) — the class of the result element type (must not be null)
- **Returns:** a new matrix with the results of the zip function
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same shape
  - `E` — if the zip function throws an exception
- **Signature:** `public <B, C, E extends Exception> Matrix<T> zipWith(final Matrix<B> matrixB, final Matrix<C> matrixC, final Throwables.TriFunction<? super T, ? super B, ? super C, T, E> zipFunction) throws E`
- **Summary:** Combines three matrices element-wise using the specified ternary function.
- **Contract:**
  - All matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`Matrix<B>`) — the second matrix to zip with (must have the same dimensions, must not be null)
  - `matrixC` (`Matrix<C>`) — the third matrix to zip with (must have the same dimensions, must not be null)
  - `zipFunction` (`Throwables.TriFunction<? super T, ? super B, ? super C, T, E>`) — the function to apply to corresponding elements (must not be null)
- **Returns:** a new matrix with the results of the zip function
- **Throws:**
  - `E` — if the zip function throws an exception
- **Signature:** `public <B, C, R, E extends Exception> Matrix<R> zipWith(final Matrix<B> matrixB, final Matrix<C> matrixC, final Throwables.TriFunction<? super T, ? super B, ? super C, R, E> zipFunction, final Class<R> targetElementType) throws IllegalArgumentException, E`
- **Summary:** Combines three matrices element-wise using the specified ternary function.
- **Contract:**
  - All matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`Matrix<B>`) — the second matrix to zip with (must have the same dimensions, must not be null)
  - `matrixC` (`Matrix<C>`) — the third matrix to zip with (must have the same dimensions, must not be null)
  - `zipFunction` (`Throwables.TriFunction<? super T, ? super B, ? super C, R, E>`) — the function to apply to corresponding elements (must not be null)
  - `targetElementType` (`Class<R>`) — the class of the result element type (must not be null)
- **Returns:** a new matrix with the results of the zip function
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same shape
  - `E` — if the zip function throws an exception
##### streamLU2RD(...) -> Stream<T>
- **Signature:** `@Override public Stream<T> streamLU2RD()`
- **Summary:** Creates a stream of elements on the diagonal from left-upper to right-down.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a stream of diagonal elements from top-left to bottom-right
##### streamRU2LD(...) -> Stream<T>
- **Signature:** `@Override public Stream<T> streamRU2LD()`
- **Summary:** Creates a stream of elements on the diagonal from right-upper to left-down.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a stream of diagonal elements from top-right to bottom-left
##### streamH(...) -> Stream<T>
- **Signature:** `@Override public Stream<T> streamH()`
- **Summary:** Creates a stream of all elements in row-major order (left to right, top to bottom).
- **Parameters:**
  - (none)
- **Returns:** a stream of all elements in row-major order
- **Signature:** `@Override public Stream<T> streamH(final int rowIndex)`
- **Summary:** Creates a stream of elements from a specific row.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to stream
- **Returns:** a stream of elements from the specified row
- **Signature:** `@Override public Stream<T> streamH(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of elements from a range of rows in row-major order.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a stream of elements from the specified row range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
##### streamV(...) -> Stream<T>
- **Signature:** `@Override @Beta public Stream<T> streamV()`
- **Summary:** Creates a stream of all elements in column-major order (top to bottom, left to right).
- **Parameters:**
  - (none)
- **Returns:** a stream of all elements in column-major order
- **Signature:** `@Override public Stream<T> streamV(final int columnIndex)`
- **Summary:** Creates a stream of elements from a specific column.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to stream
- **Returns:** a stream of elements from the specified column
- **Signature:** `@Beta @Override public Stream<T> streamV(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of elements from a range of columns in column-major order.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a stream of elements from the specified column range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
##### streamR(...) -> Stream<Stream<T>>
- **Signature:** `@Override public Stream<Stream<T>> streamR()`
- **Summary:** Creates a stream of streams, where each inner stream represents a row.
- **Parameters:**
  - (none)
- **Returns:** a stream of row streams
- **Signature:** `@Override public Stream<Stream<T>> streamR(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of streams for a range of rows.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a stream of row streams for the specified range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
##### streamC(...) -> Stream<Stream<T>>
- **Signature:** `@Override @Beta public Stream<Stream<T>> streamC()`
- **Summary:** Creates a stream of streams, where each inner stream represents a column.
- **Parameters:**
  - (none)
- **Returns:** a stream of column streams
- **Signature:** `@Override @Beta public Stream<Stream<T>> streamC(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of streams for a range of columns.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a stream of column streams for the specified range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.Consumer<? super T, E> action) throws E`
- **Summary:** Applies the given action to each element in the matrix.
- **Parameters:**
  - `action` (`Throwables.Consumer<? super T, E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the action throws an exception
- **Signature:** `public <E extends Exception> void forEach(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.Consumer<? super T, E> action) throws IndexOutOfBoundsException, E`
- **Summary:** Applies the given action to each element in a specified sub-matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
  - `action` (`Throwables.Consumer<? super T, E>`) — the action to perform on each element
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if indices are out of bounds
  - `E` — if the action throws an exception
##### toDatasetH(...) -> Dataset
- **Signature:** `@Beta public Dataset toDatasetH(final Collection<String> columnNames) throws IllegalArgumentException`
- **Summary:** Converts this matrix to a Dataset with horizontally organized data.
- **Contract:**
  - <p> The column names are used in the order they appear in the collection, and must match the number of columns in the matrix exactly.
- **Parameters:**
  - `columnNames` (`Collection<String>`) — the names to assign to each column in the resulting Dataset
- **Returns:** a Dataset containing the matrix data with the specified column names
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the size of columnNames doesn't match the column count
- **See also:** Dataset
##### toDatasetV(...) -> Dataset
- **Signature:** `@Beta public Dataset toDatasetV(final Collection<String> columnNames) throws IllegalArgumentException`
- **Summary:** Converts this matrix to a Dataset with vertically organized data.
- **Contract:**
  - <p> The column names are used in the order they appear in the collection, and must match the number of rows in the matrix exactly.
- **Parameters:**
  - `columnNames` (`Collection<String>`) — the collection of column names to use for the Dataset
- **Returns:** a Dataset containing the matrix data organized vertically
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the number of column names doesn't match the number of rows in the matrix
- **See also:** Dataset, RowDataset
##### println(...) -> String
- **Signature:** `@Override public String println()`
- **Summary:** Prints the matrix to standard output in a formatted, human-readable manner and returns the output string.
- **Parameters:**
  - (none)
- **Returns:** the formatted string representation of the matrix that was printed to standard output
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this matrix.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this matrix
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this matrix to the specified object for equality.
- **Contract:**
  - Returns {@code true} if the given object is also a Matrix with the same dimensions and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the objects are equal, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this matrix

### Class Matrixes (com.landawn.abacus.util.Matrixes)
Utility class providing static methods for matrix operations, parallel processing control, and matrix manipulation functions.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### getParallelEnabled(...) -> ParallelEnabled
- **Signature:** `public static ParallelEnabled getParallelEnabled()`
- **Summary:** Returns the current parallel processing setting for the current thread.
- **Contract:**
  - </p> <p> The returned value indicates how matrix operations should decide whether to use parallel processing: </p> <ul> <li> {@link ParallelEnabled#YES} - Forces parallel execution regardless of matrix size </li> <li> {@link ParallelEnabled#NO} - Forces sequential execution regardless of matrix size </li> <li> {@link ParallelEnabled#DEFAULT} - Automatically decides based on matrix size (threshold: 8192 elements) </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code ParallelEnabled current = Matrixes.getParallelEnabled(); // Check current setting before changing it if (current == ParallelEnabled.DEFAULT) { Matrixes.setParallelEnabled(ParallelEnabled.YES); } } </pre>
- **Parameters:**
  - (none)
- **Returns:** the current {@link ParallelEnabled} setting for this thread, never {@code null}
- **See also:** #setParallelEnabled(ParallelEnabled), ParallelEnabled
##### setParallelEnabled(...) -> void
- **Signature:** `public static void setParallelEnabled(final ParallelEnabled flag) throws IllegalArgumentException`
- **Summary:** Sets the parallel processing behavior for matrix operations in the current thread.
- **Contract:**
  - Use this when you know operations will benefit from parallelization.
- **Parameters:**
  - `flag` (`ParallelEnabled`) — the {@link ParallelEnabled} setting to apply to the current thread, must not be {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code flag} is {@code null}
- **See also:** #getParallelEnabled(), ParallelEnabled
##### isParallelable(...) -> boolean
- **Signature:** `public static boolean isParallelable(final AbstractMatrix<?, ?, ?, ?, ?> x)`
- **Summary:** Determines whether the given matrix should be processed using parallel execution.
- **Contract:**
  - Determines whether the given matrix should be processed using parallel execution.
  - <p> This method evaluates whether parallel processing should be used for operations on the specified matrix based on its total element count.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code IntMatrix matrix = IntMatrix.of(new int\[1000\]\[1000\]); if (Matrixes.isParallelable(matrix)) { // Matrix is large enough for parallel processing } } </pre>
- **Parameters:**
  - `x` (`AbstractMatrix<?, ?, ?, ?, ?>`) — the matrix to evaluate for parallelization, must not be {@code null}
- **Returns:** {@code true} if parallel processing should be used for this matrix; {@code false} for sequential processing
- **See also:** #isParallelable(AbstractMatrix, long), #setParallelEnabled(ParallelEnabled)
- **Signature:** `public static boolean isParallelable(@SuppressWarnings("unused") final AbstractMatrix<?, ?, ?, ?, ?> x, final long count)`
- **Summary:** Determines whether a matrix operation should be processed using parallel execution based on the element count and current parallel settings.
- **Contract:**
  - Determines whether a matrix operation should be processed using parallel execution based on the element count and current parallel settings.
  - <p> This method makes the parallelization decision using a multifactor evaluation: </p> <ol> <li> <b> Runtime Support: </b> Parallel streams must be available in the runtime environment.
  - If not supported, always returns {@code false} .
  - </li> <li> <b> Thread Setting: </b> Checks the current thread's {@link ParallelEnabled} setting: <ul> <li> {@link ParallelEnabled#YES} - Always returns {@code true} (if runtime supports it) </li> <li> {@link ParallelEnabled#NO} - Always returns {@code false} </li> <li> {@link ParallelEnabled#DEFAULT} - Decides based on element count </li> </ul> </li> <li> <b> Element Count: </b> When using {@code DEFAULT} setting, returns {@code true} only if {@code count >= 8192} .
  - </li> </ol> <p> <b> Usage Examples: </b> </p> <pre> {@code IntMatrix matrix = IntMatrix.of(new int\[100\]\[100\]); boolean shouldParallelize = Matrixes.isParallelable(matrix, 5000); // Returns true only if settings allow and count >= 8192 } </pre>
- **Parameters:**
  - `x` (`@SuppressWarnings(value = "unused") AbstractMatrix<?, ?, ?, ?, ?>`) — the matrix being evaluated (reserved for future extensibility, currently not used in the decision logic)
  - `count` (`long`) — the number of elements to process; typically the total element count or a subset being operated on
- **Returns:** {@code true} if parallel processing should be used; {@code false} for sequential processing
- **See also:** #setParallelEnabled(ParallelEnabled), ParallelEnabled
##### isSameShape(...) -> boolean
- **Signature:** `public static <X extends AbstractMatrix<?, ?, ?, ?, ?>> boolean isSameShape(final X a, final X b)`
- **Summary:** Checks if two matrices have the same shape (identical dimensions).
- **Contract:**
  - Checks if two matrices have the same shape (identical dimensions).
  - <p> Two matrices are considered to have the same shape if and only if they have the same number of rows AND the same number of columns.
- **Parameters:**
  - `a` (`X`) — the first matrix to compare, must not be {@code null}
  - `b` (`X`) — the second matrix to compare, must not be {@code null}
- **Returns:** {@code true} if both matrices have the same number of rows and columns; {@code false} otherwise
- **Signature:** `public static <X extends AbstractMatrix<?, ?, ?, ?, ?>> boolean isSameShape(final X a, final X b, final X c)`
- **Summary:** Checks if three matrices have the same shape (identical dimensions).
- **Contract:**
  - Checks if three matrices have the same shape (identical dimensions).
  - <p> Three matrices are considered to have the same shape if they all have the same number of rows AND the same number of columns.
- **Parameters:**
  - `a` (`X`) — the first matrix to compare, must not be {@code null}
  - `b` (`X`) — the second matrix to compare, must not be {@code null}
  - `c` (`X`) — the third matrix to compare, must not be {@code null}
- **Returns:** {@code true} if all three matrices have the same number of rows and columns; {@code false} otherwise
- **Signature:** `public static <X extends AbstractMatrix<?, ?, ?, ?, ?>> boolean isSameShape(final Collection<? extends X> matrices)`
- **Summary:** Checks if all matrices in a collection have the same shape (identical dimensions).
- **Contract:**
  - Checks if all matrices in a collection have the same shape (identical dimensions).
  - </p> <p> Special cases: </p> <ul> <li> Empty collection: Returns {@code true} (vacuous truth) </li> <li> Single matrix: Returns {@code true} (trivially same shape) </li> <li> Multiple matrices: Returns {@code true} only if all have identical dimensions </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code List<IntMatrix> matrices = java.util.Arrays.asList(m1, m2, m3, m4); if (Matrixes.isSameShape(matrices)) { // All matrices have the same dimensions } } </pre>
- **Parameters:**
  - `matrices` (`Collection<? extends X>`) — the collection of matrices to check, may be {@code null} or empty
- **Returns:** {@code true} if all matrices have the same number of rows and columns, or if the collection is {@code null} , empty, or contains only one matrix; {@code false} if any matrix has different dimensions
##### newArray(...) -> T\[\]\[\]
- **Signature:** `public static <T> T[][] newArray(final int rowCount, final int columnCount, final Class<T> targetElementType)`
- **Summary:** Creates a new two-dimensional array with the specified dimensions and element type.
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the two-dimensional array, must be non-negative
  - `columnCount` (`int`) — the number of columns in each row, must be non-negative
  - `targetElementType` (`Class<T>`) — the class of the element type; primitive types will be auto-wrapped, must not be {@code null}
- **Returns:** a new two-dimensional array of type {@code T\[\]\[\]} with the specified dimensions, never {@code null}
- **Performance:** <p> This utility method constructs a properly typed two-dimensional array at runtime, handling the complexity of creating generic arrays in Java.
##### run(...) -> void
- **Signature:** `public static <E extends Exception> void run(final Throwables.Runnable<E> cmd, final ParallelEnabled parallelEnabled) throws E`
- **Summary:** Executes the specified command with a temporary parallel processing setting, then restores the original setting.
- **Contract:**
  - The original {@link ParallelEnabled} setting is always restored, even if the command throws an exception.
  - </p> <p> This is particularly useful when you need to force parallel or sequential execution for a specific block of code without manually managing the setting changes.
- **Parameters:**
  - `cmd` (`Throwables.Runnable<E>`) — the command to execute, must not be {@code null}
  - `parallelEnabled` (`ParallelEnabled`) — the temporary {@link ParallelEnabled} setting to use during command execution
- **Throws:**
  - `E` — if the command throws an exception during execution
- **See also:** #setParallelEnabled(ParallelEnabled), #getParallelEnabled()
- **Signature:** `public static <E extends Exception> void run(final int rowCount, final int columnCount, final Throwables.IntBiConsumer<E> cmd, final boolean inParallel) throws E`
- **Summary:** Executes a command for each position in a matrix grid defined by rows and columns.
- **Parameters:**
  - `rowCount` (`int`) — the number of rows to iterate over, must be non-negative
  - `columnCount` (`int`) — the number of columns to iterate over, must be non-negative
  - `cmd` (`Throwables.IntBiConsumer<E>`) — the command to execute for each position (i, j), receives row index and column index, must not be {@code null}
  - `inParallel` (`boolean`) — {@code true} to execute in parallel; {@code false} for sequential execution
- **Throws:**
  - `E` — if the command throws an exception during execution
- **See also:** #run(int, int, int, int, Throwables.IntBiConsumer, boolean)
- **Signature:** `public static <E extends Exception> void run(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.IntBiConsumer<E> cmd, final boolean inParallel) throws IndexOutOfBoundsException, E`
- **Summary:** Executes a command for each position in a specified subregion of a matrix grid.
- **Contract:**
  - </p> <p> Iteration strategy: </p> <ul> <li> If there are fewer or equal rows than columns, iterates by rows first (row-major order) </li> <li> If there are more rows than columns, iterates by columns first (column-major order) </li> <li> When parallel execution is enabled, the outer loop is parallelized while the inner loop remains sequential </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process a subregion of a matrix int\[\]\[\] result = new int\[10\]\[10\]; Matrixes.run(2, 5, 3, 8, (i, j) -> result\[i\]\[j\] = i + j, false); } </pre>
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive), must be non-negative
  - `toRowIndex` (`int`) — the ending row index (exclusive), must be greater than or equal to fromRowIndex
  - `fromColumnIndex` (`int`) — the starting column index (inclusive), must be non-negative
  - `toColumnIndex` (`int`) — the ending column index (exclusive), must be greater than or equal to fromColumnIndex
  - `cmd` (`Throwables.IntBiConsumer<E>`) — the command to execute for each position (i, j), receives row index and column index, must not be {@code null}
  - `inParallel` (`boolean`) — {@code true} to execute in parallel; {@code false} for sequential execution
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is negative or if toRowIndex is less than fromRowIndex or toColumnIndex is less than fromColumnIndex
  - `E` — if the command throws an exception during execution
##### call(...) -> Stream<T>
- **Signature:** `public static <T> Stream<T> call(final int rowCount, final int columnCount, final Throwables.IntBiFunction<? extends T, ? extends Exception> cmd, final boolean inParallel)`
- **Summary:** Executes a function for each position in a matrix grid and returns the results as a stream.
- **Parameters:**
  - `rowCount` (`int`) — the number of rows to iterate over, must be non-negative
  - `columnCount` (`int`) — the number of columns to iterate over, must be non-negative
  - `cmd` (`Throwables.IntBiFunction<? extends T, ? extends Exception>`) — the function to apply at each position (i, j), receives row index and column index, must not be {@code null}
  - `inParallel` (`boolean`) — {@code true} to execute in parallel; {@code false} for sequential execution
- **Returns:** a {@link Stream} of results from applying the function at each position, never {@code null}
- **See also:** #call(int, int, int, int, Throwables.IntBiFunction, boolean)
- **Signature:** `@SuppressWarnings("resource") public static <T> Stream<T> call(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.IntBiFunction<? extends T, ? extends Exception> cmd, final boolean inParallel) throws IndexOutOfBoundsException`
- **Summary:** Executes a function for each position in a specified subregion of a matrix grid and returns the results as a stream.
- **Contract:**
  - </p> <p> The order of elements in the stream depends on whether there are more rows or columns: </p> <ul> <li> If rows is less than or equal to columns: Elements are ordered by rows first (row-major order) </li> <li> If rows is greater than columns: Elements are ordered by columns first (column-major order) </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code Stream<String> coords = Matrixes.call(1, 4, 2, 5, (i, j) -> i + "," + j, false); // Generates coordinates for subregion } </pre>
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive), must be non-negative
  - `toRowIndex` (`int`) — the ending row index (exclusive), must be greater than or equal to fromRowIndex
  - `fromColumnIndex` (`int`) — the starting column index (inclusive), must be non-negative
  - `toColumnIndex` (`int`) — the ending column index (exclusive), must be greater than or equal to fromColumnIndex
  - `cmd` (`Throwables.IntBiFunction<? extends T, ? extends Exception>`) — the function to apply at each position (i, j), receives row index and column index, must not be {@code null}
  - `inParallel` (`boolean`) — {@code true} to execute in parallel; {@code false} for sequential execution
- **Returns:** a {@link Stream} of results from applying the function at each position, never {@code null}
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is negative or if toRowIndex is less than fromRowIndex or toColumnIndex is less than fromColumnIndex
##### callToInt(...) -> IntStream
- **Signature:** `public static IntStream callToInt(final int rowCount, final int columnCount, final Throwables.IntBinaryOperator<? extends Exception> cmd, final boolean inParallel)`
- **Summary:** Executes a function that returns {@code int} values for each position in a matrix grid and returns the results as an {@link IntStream} .
- **Parameters:**
  - `rowCount` (`int`) — the number of rows to iterate over, must be non-negative
  - `columnCount` (`int`) — the number of columns to iterate over, must be non-negative
  - `cmd` (`Throwables.IntBinaryOperator<? extends Exception>`) — the function to apply at each position (i, j), receives row index and column index, must not be {@code null}
  - `inParallel` (`boolean`) — {@code true} to execute in parallel; {@code false} for sequential execution
- **Returns:** an {@link IntStream} of results from applying the function at each position, never {@code null}
- **See also:** #callToInt(int, int, int, int, Throwables.IntBinaryOperator, boolean)
- **Signature:** `@SuppressWarnings("resource") public static IntStream callToInt(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.IntBinaryOperator<? extends Exception> cmd, final boolean inParallel) throws IndexOutOfBoundsException`
- **Summary:** Executes a function that returns {@code int} values for each position in a specified subregion of a matrix grid and returns the results as an {@link IntStream} .
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive), must be non-negative
  - `toRowIndex` (`int`) — the ending row index (exclusive), must be greater than or equal to fromRowIndex
  - `fromColumnIndex` (`int`) — the starting column index (inclusive), must be non-negative
  - `toColumnIndex` (`int`) — the ending column index (exclusive), must be greater than or equal to fromColumnIndex
  - `cmd` (`Throwables.IntBinaryOperator<? extends Exception>`) — the function to apply at each position (i, j), receives row index and column index, must not be {@code null}
  - `inParallel` (`boolean`) — {@code true} to execute in parallel; {@code false} for sequential execution
- **Returns:** an {@link IntStream} of results from applying the function at each position, never {@code null}
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is negative or if toRowIndex is less than fromRowIndex or toColumnIndex is less than fromColumnIndex
##### multiply(...) -> void
- **Signature:** `public static <X extends AbstractMatrix<?, ?, ?, ?, ?>> void multiply(final X a, final X b, final Throwables.IntTriConsumer<RuntimeException> action) throws IllegalArgumentException`
- **Summary:** Performs matrix multiplication iteration using a custom accumulator function.
- **Contract:**
  - It does NOT perform the actual multiplication arithmetic - that must be implemented in the command function.
  - </p> <p> For standard matrix multiplication C = A × B, the command would typically accumulate: {@code C\[i\]\[j\] += A\[i\]\[k\] * B\[k\]\[j\]} </p> <p> Index meanings: </p> <ul> <li> {@code i} - Row index in matrix A (and result matrix C) </li> <li> {@code j} - Column index in matrix B (and result matrix C) </li> <li> {@code k} - Common dimension (columns in A, rows in B) </li> </ul> <p> The matrices must satisfy the multiplication constraint: {@code a.columnCount == b.rowCount} .
- **Parameters:**
  - `a` (`X`) — the first matrix (left operand), must not be {@code null}
  - `b` (`X`) — the second matrix (right operand), must not be {@code null}
  - `action` (`Throwables.IntTriConsumer<RuntimeException>`) — the accumulator function called for each (i, j, k) triple in the multiplication, must not be {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code a} or {@code b} is {@code null} , if matrix dimensions are incompatible ( {@code a.columnCount != b.rowCount} ), or if {@code action} is {@code null}
- **See also:** #multiply(AbstractMatrix, AbstractMatrix, Throwables.IntTriConsumer, boolean)
- **Signature:** `public static <X extends AbstractMatrix<?, ?, ?, ?, ?>> void multiply(final X a, final X b, final Throwables.IntTriConsumer<RuntimeException> action, // NOSONAR final boolean inParallel) throws IllegalArgumentException`
- **Summary:** Performs matrix multiplication iteration using a custom accumulator function with explicit control over parallel execution.
- **Contract:**
  - </p> <p> When parallel execution is enabled, the outermost loop is parallelized while inner loops remain sequential for better performance.
- **Parameters:**
  - `a` (`X`) — the first matrix (left operand), must not be {@code null}
  - `b` (`X`) — the second matrix (right operand), must not be {@code null}
  - `action` (`Throwables.IntTriConsumer<RuntimeException>`) — the accumulator function called for each (i, j, k) triple in the multiplication, must not be {@code null}
  - `inParallel` (`boolean`) — {@code true} to force parallel execution; {@code false} for sequential execution
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code a} or {@code b} is {@code null} , if matrix dimensions are incompatible ( {@code a.columnCount != b.rowCount} ), or if {@code action} is {@code null}
- **See also:** #multiply(AbstractMatrix, AbstractMatrix, Throwables.IntTriConsumer)
##### zip(...) -> ByteMatrix
- **Signature:** `public static <E extends Exception> ByteMatrix zip(final ByteMatrix a, final ByteMatrix b, final Throwables.ByteBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines two {@link ByteMatrix} objects element-wise using a binary operator.
- **Contract:**
  - </p> <p> Both matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`ByteMatrix`) — the first matrix, must not be {@code null}
  - `b` (`ByteMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.ByteBinaryOperator<E>`) — the binary operator to combine corresponding elements from both matrices, must not be {@code null}
- **Returns:** a new {@link ByteMatrix} containing the results of applying the function to each pair of elements, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(ByteMatrix, ByteMatrix, ByteMatrix, Throwables.ByteTernaryOperator), #zip(Collection, Throwables.ByteBinaryOperator), ByteMatrix#zipWith(ByteMatrix, Throwables.ByteBinaryOperator)
- **Signature:** `public static <E extends Exception> ByteMatrix zip(final ByteMatrix a, final ByteMatrix b, final ByteMatrix c, final Throwables.ByteTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines three {@link ByteMatrix} objects element-wise using a ternary operator.
- **Contract:**
  - </p> <p> All three matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`ByteMatrix`) — the first matrix, must not be {@code null}
  - `b` (`ByteMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `c` (`ByteMatrix`) — the third matrix, must not be {@code null} and must have the same shape as {@code a} and {@code b}
  - `zipFunction` (`Throwables.ByteTernaryOperator<E>`) — the ternary operator to combine corresponding elements from all three matrices, must not be {@code null}
- **Returns:** a new {@link ByteMatrix} containing the results of applying the function to each triple of elements, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(ByteMatrix, ByteMatrix, Throwables.ByteBinaryOperator), #zip(Collection, Throwables.ByteBinaryOperator), ByteMatrix#zipWith(ByteMatrix, ByteMatrix, Throwables.ByteTernaryOperator)
- **Signature:** `public static <E extends Exception> ByteMatrix zip(final Collection<ByteMatrix> c, final Throwables.ByteBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link ByteMatrix} objects element-wise using a binary operator applied sequentially.
- **Contract:**
  - } </pre> <p> All matrices in the collection must have identical dimensions.
- **Parameters:**
  - `c` (`Collection<ByteMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.ByteBinaryOperator<E>`) — the binary operator to combine elements sequentially, must not be {@code null}
- **Returns:** a new {@link ByteMatrix} containing the combined results, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if {@code zipFunction} is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(ByteMatrix, ByteMatrix, Throwables.ByteBinaryOperator), #zip(ByteMatrix, ByteMatrix, ByteMatrix, Throwables.ByteTernaryOperator), #zip(Collection, Throwables.ByteNFunction, Class)
- **Signature:** `public static <R, E extends Exception> Matrix<R> zip(final Collection<ByteMatrix> c, final Throwables.ByteNFunction<? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines multiple {@link ByteMatrix} objects element-wise using a function that operates on byte arrays.
- **Parameters:**
  - `c` (`Collection<ByteMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.ByteNFunction<? extends R, E>`) — the function that takes an array of bytes (one from each matrix) and returns a result of type R, must not be {@code null}
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Collection, Throwables.ByteNFunction, boolean, Class), #zip(Collection, Throwables.ByteBinaryOperator)
- **Signature:** `public static <R, E extends Exception> Matrix<R> zip(final Collection<ByteMatrix> c, final Throwables.ByteNFunction<? extends R, E> zipFunction, final boolean shareIntermediateArray, final Class<R> targetElementType) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link ByteMatrix} objects element-wise using a function that operates on byte arrays, with control over intermediate array sharing.
- **Contract:**
  - The {@code shareIntermediateArray} parameter controls memory optimization: </p> <ul> <li> {@code true} and sequential execution: Reuses the same intermediate array for all positions, reducing memory allocations but requiring the zip function to not retain references to the array </li> <li> {@code false} or parallel execution: Creates a new array for each position, safer but uses more memory </li> </ul> <p> <b> Warning: </b> When {@code shareIntermediateArray} is {@code true} , the zip function must NOT store references to the array, as it will be mutated for subsequent positions.
  - Only use this optimization if the function immediately processes and discards the array.
- **Parameters:**
  - `c` (`Collection<ByteMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.ByteNFunction<? extends R, E>`) — the function that takes an array of bytes (one from each matrix) and returns a result of type R, must not be {@code null}
  - `shareIntermediateArray` (`boolean`) — {@code true} to reuse the intermediate array (sequential execution only); {@code false} to create new arrays for each position
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if any argument is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Collection, Throwables.ByteNFunction, Class), #zip(Collection, Throwables.ByteBinaryOperator)
- **Signature:** `public static <E extends Exception> IntMatrix zip(final IntMatrix a, final IntMatrix b, final Throwables.IntBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines two {@link IntMatrix} objects element-wise using a binary operator.
- **Contract:**
  - </p> <p> Both matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`IntMatrix`) — the first matrix, must not be {@code null}
  - `b` (`IntMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.IntBinaryOperator<E>`) — the binary operator to combine corresponding elements from both matrices, must not be {@code null}
- **Returns:** a new {@link IntMatrix} containing the results of applying the function to each pair of elements, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(IntMatrix, IntMatrix, IntMatrix, Throwables.IntTernaryOperator), #zip(Collection, Throwables.IntBinaryOperator), IntMatrix#zipWith(IntMatrix, Throwables.IntBinaryOperator)
- **Signature:** `public static <E extends Exception> IntMatrix zip(final IntMatrix a, final IntMatrix b, final IntMatrix c, final Throwables.IntTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines three {@link IntMatrix} objects element-wise using a ternary operator.
- **Contract:**
  - </p> <p> All three matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`IntMatrix`) — the first matrix, must not be {@code null}
  - `b` (`IntMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `c` (`IntMatrix`) — the third matrix, must not be {@code null} and must have the same shape as {@code a} and {@code b}
  - `zipFunction` (`Throwables.IntTernaryOperator<E>`) — the ternary operator to combine corresponding elements from all three matrices, must not be {@code null}
- **Returns:** a new {@link IntMatrix} containing the results of applying the function to each triple of elements, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(IntMatrix, IntMatrix, Throwables.IntBinaryOperator), #zip(Collection, Throwables.IntBinaryOperator), IntMatrix#zipWith(IntMatrix, IntMatrix, Throwables.IntTernaryOperator)
- **Signature:** `public static <E extends Exception> IntMatrix zip(final Collection<IntMatrix> c, final Throwables.IntBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link IntMatrix} objects element-wise using a binary operator applied sequentially.
- **Contract:**
  - } </pre> <p> All matrices in the collection must have identical dimensions.
- **Parameters:**
  - `c` (`Collection<IntMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.IntBinaryOperator<E>`) — the binary operator to combine elements sequentially, must not be {@code null}
- **Returns:** a new {@link IntMatrix} containing the combined results, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if {@code zipFunction} is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(IntMatrix, IntMatrix, Throwables.IntBinaryOperator), #zip(IntMatrix, IntMatrix, IntMatrix, Throwables.IntTernaryOperator), #zip(Collection, Throwables.IntNFunction, Class)
- **Signature:** `public static <R, E extends Exception> Matrix<R> zip(final Collection<IntMatrix> c, final Throwables.IntNFunction<? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines multiple {@link IntMatrix} objects element-wise using a function that operates on integer arrays.
- **Contract:**
  - </p> <p> All matrices in the collection must have identical dimensions.
- **Parameters:**
  - `c` (`Collection<IntMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.IntNFunction<? extends R, E>`) — the function that takes an array of integers (one from each matrix) and returns a result of type R, must not be {@code null}
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Collection, Throwables.IntNFunction, boolean, Class)
- **Signature:** `public static <R, E extends Exception> Matrix<R> zip(final Collection<IntMatrix> c, final Throwables.IntNFunction<? extends R, E> zipFunction, final boolean shareIntermediateArray, final Class<R> targetElementType) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link IntMatrix} objects element-wise using a function that operates on integer arrays, with control over intermediate array sharing.
- **Contract:**
  - The {@code shareIntermediateArray} parameter controls memory optimization: </p> <ul> <li> {@code true} and sequential execution: Reuses the same intermediate array for all positions, reducing memory allocations but requiring the zip function to not retain references to the array </li> <li> {@code false} or parallel execution: Creates a new array for each position, safer but uses more memory </li> </ul> <p> <b> Warning: </b> When {@code shareIntermediateArray} is {@code true} , the zip function must NOT store references to the array, as it will be mutated for subsequent positions.
  - Only use this optimization if the function immediately processes and discards the array.
  - </p> <p> All matrices in the collection must have identical dimensions.
- **Parameters:**
  - `c` (`Collection<IntMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.IntNFunction<? extends R, E>`) — the function that takes an array of integers (one from each matrix) and returns a result of type R, must not be {@code null}
  - `shareIntermediateArray` (`boolean`) — {@code true} to reuse the intermediate array (sequential execution only); {@code false} to create new arrays for each position
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if any argument is {@code null}
  - `E` — if the zip function throws an exception during execution
- **Signature:** `public static <E extends Exception> LongMatrix zip(final LongMatrix a, final LongMatrix b, final Throwables.LongBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines two {@link LongMatrix} objects element-wise using a binary operator.
- **Contract:**
  - </p> <p> Both matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`LongMatrix`) — the first matrix, must not be {@code null}
  - `b` (`LongMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.LongBinaryOperator<E>`) — the binary operator to combine corresponding elements from both matrices, must not be {@code null}
- **Returns:** a new {@link LongMatrix} containing the results of applying the function to each pair of elements, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(LongMatrix, LongMatrix, LongMatrix, Throwables.LongTernaryOperator), #zip(Collection, Throwables.LongBinaryOperator), LongMatrix#zipWith(LongMatrix, Throwables.LongBinaryOperator)
- **Signature:** `public static <E extends Exception> LongMatrix zip(final LongMatrix a, final LongMatrix b, final LongMatrix c, final Throwables.LongTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines three {@link LongMatrix} objects element-wise using a ternary operator.
- **Contract:**
  - All three matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`LongMatrix`) — the first matrix, must not be {@code null}
  - `b` (`LongMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `c` (`LongMatrix`) — the third matrix, must not be {@code null} and must have the same shape as {@code a} and {@code b}
  - `zipFunction` (`Throwables.LongTernaryOperator<E>`) — the ternary operator to combine corresponding elements from all three matrices, must not be {@code null}
- **Returns:** a new {@link LongMatrix} containing the results of applying the function to each triple of elements, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(LongMatrix, LongMatrix, Throwables.LongBinaryOperator), #zip(Collection, Throwables.LongBinaryOperator), LongMatrix#zipWith(LongMatrix, LongMatrix, Throwables.LongTernaryOperator)
- **Signature:** `public static <E extends Exception> LongMatrix zip(final Collection<LongMatrix> c, final Throwables.LongBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link LongMatrix} objects element-wise using a binary operator applied sequentially.
- **Contract:**
  - All matrices in the collection must have identical dimensions.
- **Parameters:**
  - `c` (`Collection<LongMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.LongBinaryOperator<E>`) — the binary operator to combine elements sequentially, must not be {@code null}
- **Returns:** a new {@link LongMatrix} containing the combined results, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if {@code zipFunction} is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(LongMatrix, LongMatrix, Throwables.LongBinaryOperator), #zip(LongMatrix, LongMatrix, LongMatrix, Throwables.LongTernaryOperator), #zip(Collection, Throwables.LongNFunction, Class)
- **Signature:** `public static <R, E extends Exception> Matrix<R> zip(final Collection<LongMatrix> c, final Throwables.LongNFunction<? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines multiple {@link LongMatrix} objects element-wise using a function that operates on long arrays.
- **Parameters:**
  - `c` (`Collection<LongMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.LongNFunction<? extends R, E>`) — the function that takes an array of longs (one from each matrix) and returns a result of type R, must not be {@code null}
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Collection, Throwables.LongNFunction, boolean, Class), #zip(Collection, Throwables.LongBinaryOperator)
- **Signature:** `public static <R, E extends Exception> Matrix<R> zip(final Collection<LongMatrix> c, final Throwables.LongNFunction<? extends R, E> zipFunction, final boolean shareIntermediateArray, final Class<R> targetElementType) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link LongMatrix} objects element-wise using a function that operates on long arrays, with control over intermediate array sharing.
- **Contract:**
  - </p> <p> <b> Warning: </b> When {@code shareIntermediateArray} is {@code true} , the zip function must NOT store references to the array, as it will be mutated for subsequent positions.
  - Only use this optimization if the function immediately processes and discards the array.
  - </p> <p> All matrices in the collection must have identical dimensions.
- **Parameters:**
  - `c` (`Collection<LongMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.LongNFunction<? extends R, E>`) — the function that takes an array of longs (one from each matrix) and returns a result of type R, must not be {@code null}
  - `shareIntermediateArray` (`boolean`) — {@code true} to reuse the intermediate array (sequential execution only); {@code false} to create new arrays for each position
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if any argument is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Collection, Throwables.LongNFunction, Class), #zip(Collection, Throwables.LongBinaryOperator)
- **Signature:** `public static <E extends Exception> DoubleMatrix zip(final DoubleMatrix a, final DoubleMatrix b, final Throwables.DoubleBinaryOperator<E> zipFunction) throws E`
- **Summary:** Combines two {@link DoubleMatrix} objects element-wise using a binary operator.
- **Contract:**
  - </p> <p> Both matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`DoubleMatrix`) — the first matrix, must not be {@code null}
  - `b` (`DoubleMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.DoubleBinaryOperator<E>`) — the binary operator to combine corresponding elements from both matrices, must not be {@code null}
- **Returns:** a new {@link DoubleMatrix} containing the results of applying the function to each pair of elements, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(DoubleMatrix, DoubleMatrix, DoubleMatrix, Throwables.DoubleTernaryOperator), #zip(Collection, Throwables.DoubleBinaryOperator), DoubleMatrix#zipWith(DoubleMatrix, Throwables.DoubleBinaryOperator)
- **Signature:** `public static <E extends Exception> DoubleMatrix zip(final DoubleMatrix a, final DoubleMatrix b, final DoubleMatrix c, final Throwables.DoubleTernaryOperator<E> zipFunction) throws E`
- **Summary:** Combines three {@link DoubleMatrix} objects element-wise using a ternary operator.
- **Contract:**
  - All three matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`DoubleMatrix`) — the first matrix, must not be {@code null}
  - `b` (`DoubleMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `c` (`DoubleMatrix`) — the third matrix, must not be {@code null} and must have the same shape as {@code a} and {@code b}
  - `zipFunction` (`Throwables.DoubleTernaryOperator<E>`) — the ternary operator to combine corresponding elements from all three matrices, must not be {@code null}
- **Returns:** a new {@link DoubleMatrix} containing the results of applying the function to each triple of elements, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(DoubleMatrix, DoubleMatrix, Throwables.DoubleBinaryOperator), #zip(Collection, Throwables.DoubleBinaryOperator), DoubleMatrix#zipWith(DoubleMatrix, DoubleMatrix, Throwables.DoubleTernaryOperator)
- **Signature:** `public static <E extends Exception> DoubleMatrix zip(final Collection<DoubleMatrix> c, final Throwables.DoubleBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link DoubleMatrix} objects element-wise using a binary operator applied sequentially.
- **Contract:**
  - All matrices in the collection must have identical dimensions.
- **Parameters:**
  - `c` (`Collection<DoubleMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.DoubleBinaryOperator<E>`) — the binary operator to combine elements sequentially, must not be {@code null}
- **Returns:** a new {@link DoubleMatrix} containing the combined results, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if {@code zipFunction} is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(DoubleMatrix, DoubleMatrix, Throwables.DoubleBinaryOperator), #zip(DoubleMatrix, DoubleMatrix, DoubleMatrix, Throwables.DoubleTernaryOperator), #zip(Collection, Throwables.DoubleNFunction, Class)
- **Signature:** `public static <R, E extends Exception> Matrix<R> zip(final Collection<DoubleMatrix> c, final Throwables.DoubleNFunction<? extends R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines multiple {@link DoubleMatrix} objects element-wise using a function that operates on double arrays.
- **Parameters:**
  - `c` (`Collection<DoubleMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.DoubleNFunction<? extends R, E>`) — the function that takes an array of doubles (one from each matrix) and returns a result of type R, must not be {@code null}
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Collection, Throwables.DoubleNFunction, boolean, Class), #zip(Collection, Throwables.DoubleBinaryOperator)
- **Signature:** `public static <R, E extends Exception> Matrix<R> zip(final Collection<DoubleMatrix> c, final Throwables.DoubleNFunction<? extends R, E> zipFunction, final boolean shareIntermediateArray, final Class<R> targetElementType) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link DoubleMatrix} objects element-wise using a function that operates on double arrays, with control over intermediate array sharing.
- **Contract:**
  - </p> <p> <b> Warning: </b> When {@code shareIntermediateArray} is {@code true} , the zip function must NOT store references to the array, as it will be mutated for subsequent positions.
  - Only use this optimization if the function immediately processes and discards the array.
  - </p> <p> All matrices in the collection must have identical dimensions.
- **Parameters:**
  - `c` (`Collection<DoubleMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.DoubleNFunction<? extends R, E>`) — the function that takes an array of doubles (one from each matrix) and returns a result of type R, must not be {@code null}
  - `shareIntermediateArray` (`boolean`) — {@code true} to reuse the intermediate array (sequential execution only); {@code false} to create new arrays for each position
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if any argument is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Collection, Throwables.DoubleNFunction, Class), #zip(Collection, Throwables.DoubleBinaryOperator)
- **Signature:** `public static <A, B, E extends Exception> Matrix<A> zip(final Matrix<A> a, final Matrix<B> b, final Throwables.BiFunction<? super A, ? super B, A, E> zipFunction) throws E`
- **Summary:** Combines two generic {@link Matrix} objects element-wise using a binary function.
- **Contract:**
  - </p> <p> Both matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`Matrix<A>`) — the first matrix, must not be {@code null}
  - `b` (`Matrix<B>`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.BiFunction<? super A, ? super B, A, E>`) — the function to combine corresponding elements from both matrices, must not be {@code null}
- **Returns:** a new {@link Matrix} of type A containing the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Matrix, Matrix, Throwables.BiFunction, Class), #zip(Matrix, Matrix, Matrix, Throwables.TriFunction), Matrix#zipWith(Matrix, Throwables.BiFunction)
- **Signature:** `public static <A, B, R, E extends Exception> Matrix<R> zip(final Matrix<A> a, final Matrix<B> b, final Throwables.BiFunction<? super A, ? super B, R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines two generic {@link Matrix} objects element-wise using a binary function, producing a result matrix with a potentially different element type.
- **Contract:**
  - </p> <p> Both matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`Matrix<A>`) — the first matrix, must not be {@code null}
  - `b` (`Matrix<B>`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.BiFunction<? super A, ? super B, R, E>`) — the function to combine corresponding elements from both matrices, must not be {@code null}
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Matrix, Matrix, Throwables.BiFunction), #zip(Matrix, Matrix, Matrix, Throwables.TriFunction, Class), Matrix#zipWith(Matrix, Throwables.BiFunction, Class)
- **Signature:** `public static <A, B, C, E extends Exception> Matrix<A> zip(final Matrix<A> a, final Matrix<B> b, final Matrix<C> c, final Throwables.TriFunction<? super A, ? super B, ? super C, A, E> zipFunction) throws E`
- **Summary:** Combines three generic {@link Matrix} objects element-wise using a ternary function.
- **Contract:**
  - </p> <p> All three matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`Matrix<A>`) — the first matrix, must not be {@code null}
  - `b` (`Matrix<B>`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `c` (`Matrix<C>`) — the third matrix, must not be {@code null} and must have the same shape as {@code a} and {@code b}
  - `zipFunction` (`Throwables.TriFunction<? super A, ? super B, ? super C, A, E>`) — the function to combine corresponding elements from all three matrices, must not be {@code null}
- **Returns:** a new {@link Matrix} of type A containing the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Matrix, Matrix, Throwables.BiFunction), #zip(Matrix, Matrix, Matrix, Throwables.TriFunction, Class), Matrix#zipWith(Matrix, Matrix, Throwables.TriFunction)
- **Signature:** `public static <A, B, C, R, E extends Exception> Matrix<R> zip(final Matrix<A> a, final Matrix<B> b, final Matrix<C> c, final Throwables.TriFunction<? super A, ? super B, ? super C, R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines three generic {@link Matrix} objects element-wise using a ternary function, producing a result matrix with a potentially different element type.
- **Contract:**
  - </p> <p> All three matrices must have identical dimensions (same number of rows and columns).
- **Parameters:**
  - `a` (`Matrix<A>`) — the first matrix, must not be {@code null}
  - `b` (`Matrix<B>`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `c` (`Matrix<C>`) — the third matrix, must not be {@code null} and must have the same shape as {@code a} and {@code b}
  - `zipFunction` (`Throwables.TriFunction<? super A, ? super B, ? super C, R, E>`) — the function to combine corresponding elements from all three matrices, must not be {@code null}
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Matrix, Matrix, Throwables.BiFunction, Class), #zip(Matrix, Matrix, Matrix, Throwables.TriFunction), Matrix#zipWith(Matrix, Matrix, Throwables.TriFunction, Class)
- **Signature:** `public static <T, E extends Exception> Matrix<T> zip(final Collection<Matrix<T>> c, final Throwables.BinaryOperator<T, E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Combines multiple generic {@link Matrix} objects element-wise using a binary operator applied sequentially.
- **Contract:**
  - } </pre> <p> All matrices in the collection must have identical dimensions and element type.
- **Parameters:**
  - `c` (`Collection<Matrix<T>>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.BinaryOperator<T, E>`) — the binary operator to combine elements sequentially, must not be {@code null}
- **Returns:** a new {@link Matrix} of type T containing the combined results, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if {@code zipFunction} is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Matrix, Matrix, Throwables.BiFunction), #zip(Collection, Throwables.Function, Class)
- **Signature:** `public static <T, R, E extends Exception> Matrix<R> zip(final Collection<Matrix<T>> c, final Throwables.Function<? super T[], R, E> zipFunction, final Class<R> targetElementType) throws E`
- **Summary:** Combines multiple generic {@link Matrix} objects element-wise using a function that operates on arrays.
- **Contract:**
  - </p> <p> All matrices in the collection must have identical dimensions.
- **Parameters:**
  - `c` (`Collection<Matrix<T>>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.Function<? super T[], R, E>`) — the function that takes an array of values (one from each matrix) and returns a result of type R, must not be {@code null}
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Collection, Throwables.Function, boolean, Class), #zip(Collection, Throwables.BinaryOperator)
- **Signature:** `public static <T, R, E extends Exception> Matrix<R> zip(final Collection<Matrix<T>> c, final Throwables.Function<? super T[], R, E> zipFunction, final boolean shareIntermediateArray, final Class<R> targetElementType) throws IllegalArgumentException, E`
- **Summary:** Combines multiple generic {@link Matrix} objects element-wise using a function that operates on arrays, with control over intermediate array sharing.
- **Contract:**
  - </p> <p> The {@code shareIntermediateArray} parameter controls memory optimization: </p> <ul> <li> {@code true} and sequential execution: Reuses the same intermediate array for all positions, reducing memory allocations but requiring the zip function to not retain references to the array </li> <li> {@code false} or parallel execution: Creates a new array for each position, safer but uses more memory </li> </ul> <p> <b> Warning: </b> When {@code shareIntermediateArray} is {@code true} , the zip function must NOT store references to the array, as it will be mutated for subsequent positions.
  - Only use this optimization if the function immediately processes and discards the array.
- **Parameters:**
  - `c` (`Collection<Matrix<T>>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.Function<? super T[], R, E>`) — the function that takes an array of values (one from each matrix) and returns a result of type R, must not be {@code null}
  - `shareIntermediateArray` (`boolean`) — {@code true} to reuse the intermediate array (sequential execution only); {@code false} to create new arrays for each position
  - `targetElementType` (`Class<R>`) — the class of the result element type, must not be {@code null}
- **Returns:** a new {@link Matrix} of type R containing the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if any argument is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zip(Collection, Throwables.Function, Class), #zip(Collection, Throwables.BinaryOperator)
##### zipToInt(...) -> IntMatrix
- **Signature:** `public static <E extends Exception> IntMatrix zipToInt(final ByteMatrix a, final ByteMatrix b, final Throwables.ByteBiFunction<Integer, E> zipFunction) throws E`
- **Summary:** Combines two {@link ByteMatrix} objects element-wise using a function that returns {@code Integer} values, producing an {@link IntMatrix} .
- **Contract:**
  - </p> <p> Both matrices must have identical dimensions.
- **Parameters:**
  - `a` (`ByteMatrix`) — the first matrix, must not be {@code null}
  - `b` (`ByteMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.ByteBiFunction<Integer, E>`) — the function to combine corresponding elements, takes two bytes and returns an Integer, must not be {@code null}
- **Returns:** a new {@link IntMatrix} with the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zipToInt(ByteMatrix, ByteMatrix, ByteMatrix, Throwables.ByteTriFunction), #zipToInt(Collection, Throwables.ByteNFunction)
- **Signature:** `public static <E extends Exception> IntMatrix zipToInt(final ByteMatrix a, final ByteMatrix b, final ByteMatrix c, final Throwables.ByteTriFunction<Integer, E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Combines three {@link ByteMatrix} objects element-wise using a function that returns {@code Integer} values, producing an {@link IntMatrix} .
- **Contract:**
  - </p> <p> All three matrices must have identical dimensions.
- **Parameters:**
  - `a` (`ByteMatrix`) — the first matrix, must not be {@code null}
  - `b` (`ByteMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `c` (`ByteMatrix`) — the third matrix, must not be {@code null} and must have the same shape as {@code a} and {@code b}
  - `zipFunction` (`Throwables.ByteTriFunction<Integer, E>`) — the function to combine corresponding elements, takes three bytes and returns an Integer, must not be {@code null}
- **Returns:** a new {@link IntMatrix} with the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different shapes or if any argument is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zipToInt(ByteMatrix, ByteMatrix, Throwables.ByteBiFunction), #zipToInt(Collection, Throwables.ByteNFunction)
- **Signature:** `public static <E extends Exception> IntMatrix zipToInt(final Collection<ByteMatrix> c, final Throwables.ByteNFunction<Integer, E> zipFunction) throws E`
- **Summary:** Combines multiple {@link ByteMatrix} objects element-wise using a function that returns {@code Integer} values, producing an {@link IntMatrix} .
- **Contract:**
  - </p> <p> All matrices in the collection must have identical dimensions.
- **Parameters:**
  - `c` (`Collection<ByteMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.ByteNFunction<Integer, E>`) — the function that takes an array of bytes and returns an Integer, must not be {@code null}
- **Returns:** a new {@link IntMatrix} with the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zipToInt(Collection, Throwables.ByteNFunction, boolean), #zipToInt(ByteMatrix, ByteMatrix, Throwables.ByteBiFunction)
- **Signature:** `public static <E extends Exception> IntMatrix zipToInt(final Collection<ByteMatrix> c, final Throwables.ByteNFunction<Integer, E> zipFunction, final boolean shareIntermediateArray) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link ByteMatrix} objects element-wise using a function that returns {@code Integer} values, with control over intermediate array sharing.
- **Contract:**
  - The {@code shareIntermediateArray} parameter controls memory optimization: </p> <ul> <li> {@code true} and sequential execution: Reuses the same intermediate array for all positions, reducing memory allocations but requiring the zip function to not retain references to the array </li> <li> {@code false} or parallel execution: Creates a new array for each position, safer but uses more memory </li> </ul> <p> <b> Warning: </b> When {@code shareIntermediateArray} is {@code true} , the zip function must NOT store references to the array, as it will be mutated for subsequent positions.
  - Only use this optimization if the function immediately processes and discards the array.
  - </p> <p> All matrices in the collection must have identical dimensions.
- **Parameters:**
  - `c` (`Collection<ByteMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.ByteNFunction<Integer, E>`) — the function that takes an array of bytes and returns an Integer, must not be {@code null}
  - `shareIntermediateArray` (`boolean`) — {@code true} to reuse the intermediate array (sequential execution only); {@code false} to create new arrays for each position
- **Returns:** a new {@link IntMatrix} with the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if {@code zipFunction} is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zipToInt(Collection, Throwables.ByteNFunction)
##### zipToLong(...) -> LongMatrix
- **Signature:** `public static <E extends Exception> LongMatrix zipToLong(final IntMatrix a, final IntMatrix b, final Throwables.IntBiFunction<Long, E> zipFunction) throws E`
- **Summary:** Combines two {@link IntMatrix} objects element-wise using a function that returns {@code Long} values, producing a {@link LongMatrix} .
- **Contract:**
  - </p> <p> Both matrices must have identical dimensions.
- **Parameters:**
  - `a` (`IntMatrix`) — the first matrix, must not be {@code null}
  - `b` (`IntMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.IntBiFunction<Long, E>`) — the function to combine corresponding elements, takes two ints and returns a Long, must not be {@code null}
- **Returns:** a new {@link LongMatrix} with the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **Signature:** `public static <E extends Exception> LongMatrix zipToLong(final IntMatrix a, final IntMatrix b, final IntMatrix c, final Throwables.IntTriFunction<Long, E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Combines three {@link IntMatrix} objects element-wise using a function that returns {@code Long} values, producing a {@link LongMatrix} .
- **Contract:**
  - </p> <p> All three matrices must have identical dimensions.
- **Parameters:**
  - `a` (`IntMatrix`) — the first matrix, must not be {@code null}
  - `b` (`IntMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `c` (`IntMatrix`) — the third matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.IntTriFunction<Long, E>`) — the function to combine corresponding elements, takes three ints and returns a Long, must not be {@code null}
- **Returns:** a new {@link LongMatrix} with the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different shapes or if any argument is {@code null}
  - `E` — if the zip function throws an exception during execution
- **Signature:** `public static <E extends Exception> LongMatrix zipToLong(final Collection<IntMatrix> c, final Throwables.IntNFunction<Long, E> zipFunction) throws E`
- **Summary:** Combines multiple {@link IntMatrix} objects element-wise using a function that returns {@code Long} values.
- **Parameters:**
  - `c` (`Collection<IntMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.IntNFunction<Long, E>`) — the function that takes an array of integers and returns a Long, must not be {@code null}
- **Returns:** a new {@link LongMatrix} with the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zipToLong(Collection, Throwables.IntNFunction, boolean)
- **Signature:** `public static <E extends Exception> LongMatrix zipToLong(final Collection<IntMatrix> c, final Throwables.IntNFunction<Long, E> zipFunction, final boolean shareIntermediateArray) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link IntMatrix} objects element-wise using a function that returns {@code Long} values, with control over intermediate array sharing.
- **Contract:**
  - </p> <p> <b> Warning: </b> When {@code shareIntermediateArray} is {@code true} , the zip function must NOT store references to the array, as it will be mutated for subsequent positions.
- **Parameters:**
  - `c` (`Collection<IntMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.IntNFunction<Long, E>`) — the function that takes an array of integers and returns a Long, must not be {@code null}
  - `shareIntermediateArray` (`boolean`) — {@code true} to reuse the intermediate array (sequential execution only); {@code false} to create new arrays for each position
- **Returns:** a new {@link LongMatrix} with the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if {@code zipFunction} is {@code null}
  - `E` — if the zip function throws an exception during execution
##### zipToDouble(...) -> DoubleMatrix
- **Signature:** `public static <E extends Exception> DoubleMatrix zipToDouble(final IntMatrix a, final IntMatrix b, final Throwables.IntBiFunction<Double, E> zipFunction) throws E`
- **Summary:** Combines two {@link IntMatrix} objects element-wise using a function that returns {@code Double} values, producing a {@link DoubleMatrix} .
- **Parameters:**
  - `a` (`IntMatrix`) — the first matrix, must not be {@code null}
  - `b` (`IntMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.IntBiFunction<Double, E>`) — the function to combine corresponding elements, takes two ints and returns a Double, must not be {@code null}
- **Returns:** a new {@link DoubleMatrix} with the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **Signature:** `public static <E extends Exception> DoubleMatrix zipToDouble(final IntMatrix a, final IntMatrix b, final IntMatrix c, final Throwables.IntTriFunction<Double, E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Combines three {@link IntMatrix} objects element-wise using a function that returns {@code Double} values, producing a {@link DoubleMatrix} .
- **Parameters:**
  - `a` (`IntMatrix`) — the first matrix, must not be {@code null}
  - `b` (`IntMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `c` (`IntMatrix`) — the third matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.IntTriFunction<Double, E>`) — the function to combine corresponding elements, takes three ints and returns a Double, must not be {@code null}
- **Returns:** a new {@link DoubleMatrix} with the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different shapes or if any argument is {@code null}
  - `E` — if the zip function throws an exception during execution
- **Signature:** `public static <E extends Exception> DoubleMatrix zipToDouble(final Collection<IntMatrix> c, final Throwables.IntNFunction<Double, E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link IntMatrix} objects element-wise using a function that returns {@code Double} values.
- **Parameters:**
  - `c` (`Collection<IntMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.IntNFunction<Double, E>`) — the function that takes an array of integers and returns a Double, must not be {@code null}
- **Returns:** a new {@link DoubleMatrix} with the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if {@code zipFunction} is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zipToDouble(Collection, Throwables.IntNFunction, boolean)
- **Signature:** `public static <E extends Exception> DoubleMatrix zipToDouble(final Collection<IntMatrix> c, final Throwables.IntNFunction<Double, E> zipFunction, final boolean shareIntermediateArray) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link IntMatrix} objects element-wise using a function that returns {@code Double} values, with control over intermediate array sharing.
- **Contract:**
  - </p> <p> <b> Warning: </b> When {@code shareIntermediateArray} is {@code true} , the zip function must NOT store references to the array.
- **Parameters:**
  - `c` (`Collection<IntMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.IntNFunction<Double, E>`) — the function that takes an array of integers and returns a Double, must not be {@code null}
  - `shareIntermediateArray` (`boolean`) — {@code true} to reuse the intermediate array (sequential execution only); {@code false} to create new arrays for each position
- **Returns:** a new {@link DoubleMatrix} with the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if {@code zipFunction} is {@code null}
  - `E` — if the zip function throws an exception during execution
- **Signature:** `public static <E extends Exception> DoubleMatrix zipToDouble(final LongMatrix a, final LongMatrix b, final Throwables.LongBiFunction<Double, E> zipFunction) throws E`
- **Summary:** Combines two {@link LongMatrix} objects element-wise using a function that returns {@code Double} values, producing a {@link DoubleMatrix} .
- **Parameters:**
  - `a` (`LongMatrix`) — the first matrix, must not be {@code null}
  - `b` (`LongMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `zipFunction` (`Throwables.LongBiFunction<Double, E>`) — the function to combine corresponding elements, takes two longs and returns a Double, must not be {@code null}
- **Returns:** a new {@link DoubleMatrix} with the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zipToDouble(LongMatrix, LongMatrix, LongMatrix, Throwables.LongTriFunction), #zipToDouble(Collection, Throwables.LongNFunction)
- **Signature:** `public static <E extends Exception> DoubleMatrix zipToDouble(final LongMatrix a, final LongMatrix b, final LongMatrix c, final Throwables.LongTriFunction<Double, E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Combines three {@link LongMatrix} objects element-wise using a function that returns {@code Double} values, producing a {@link DoubleMatrix} .
- **Parameters:**
  - `a` (`LongMatrix`) — the first matrix, must not be {@code null}
  - `b` (`LongMatrix`) — the second matrix, must not be {@code null} and must have the same shape as {@code a}
  - `c` (`LongMatrix`) — the third matrix, must not be {@code null} and must have the same shape as {@code a} and {@code b}
  - `zipFunction` (`Throwables.LongTriFunction<Double, E>`) — the function to combine corresponding elements, takes three longs and returns a Double, must not be {@code null}
- **Returns:** a new {@link DoubleMatrix} with the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices have different shapes or if any argument is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zipToDouble(LongMatrix, LongMatrix, Throwables.LongBiFunction), #zipToDouble(Collection, Throwables.LongNFunction)
- **Signature:** `public static <E extends Exception> DoubleMatrix zipToDouble(final Collection<LongMatrix> c, final Throwables.LongNFunction<Double, E> zipFunction) throws E`
- **Summary:** Combines multiple {@link LongMatrix} objects element-wise using a function that returns {@code Double} values.
- **Parameters:**
  - `c` (`Collection<LongMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.LongNFunction<Double, E>`) — the function that takes an array of longs and returns a Double, must not be {@code null}
- **Returns:** a new {@link DoubleMatrix} with the combined values, never {@code null}
- **Throws:**
  - `E` — if the zip function throws an exception during execution
- **See also:** #zipToDouble(Collection, Throwables.LongNFunction, boolean), #zipToDouble(LongMatrix, LongMatrix, Throwables.LongBiFunction)
- **Signature:** `public static <E extends Exception> DoubleMatrix zipToDouble(final Collection<LongMatrix> c, final Throwables.LongNFunction<Double, E> zipFunction, final boolean shareIntermediateArray) throws IllegalArgumentException, E`
- **Summary:** Combines multiple {@link LongMatrix} objects element-wise using a function that returns {@code Double} values, with control over intermediate array sharing.
- **Contract:**
  - </p> <p> <b> Warning: </b> When {@code shareIntermediateArray} is {@code true} , the zip function must NOT store references to the array.
- **Parameters:**
  - `c` (`Collection<LongMatrix>`) — the collection of matrices to combine, must not be {@code null} or empty
  - `zipFunction` (`Throwables.LongNFunction<Double, E>`) — the function that takes an array of longs and returns a Double, must not be {@code null}
  - `shareIntermediateArray` (`boolean`) — {@code true} to reuse the intermediate array (sequential execution only); {@code false} to create new arrays for each position
- **Returns:** a new {@link DoubleMatrix} with the combined values, never {@code null}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code c} is {@code null} , empty, if matrices have different shapes, or if {@code zipFunction} is {@code null}
  - `E` — if the zip function throws an exception during execution
- **See also:** #zipToDouble(Collection, Throwables.LongNFunction), #zipToDouble(LongMatrix, LongMatrix, Throwables.LongBiFunction)

#### Public Instance Methods
- (none)

### Enum ParallelEnabled (com.landawn.abacus.util.ParallelEnabled)
Enumeration that controls parallel processing behavior for matrix operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Class Points (com.landawn.abacus.util.Points)
Utility class containing point classes for two-dimensional and three-dimensional coordinate systems.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Class xy (com.landawn.abacus.util.Points.xy)
This class provides two-dimensional coordinate point implementations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Record ByteBytePoint (com.landawn.abacus.util.Points.xy.ByteBytePoint)
Represents an immutable two-dimensional point with byte coordinates and a byte value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ByteBytePoint
- **Signature:** `public static ByteBytePoint of(final byte x, final byte y, final byte v)`
- **Summary:** Creates a new ByteBytePoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`byte`) — the x-coordinate of the point, must be in the range \[-128, 127\]
  - `y` (`byte`) — the y-coordinate of the point, must be in the range \[-128, 127\]
  - `v` (`byte`) — the value associated with this point, must be in the range \[-128, 127\]
- **Returns:** a new ByteBytePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record ByteBytePoint(byte x, byte y, byte v) { /** * Creates a new ByteBytePoint with the specified coordinates and value. * This factory method provides a convenient way to construct two-dimensional points * with byte-range coordinates and values, optimized for memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point at coordinates (10, 20) with value 5 * Points.xy.ByteBytePoint point = Points.xy.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte value = point.v(); // 5 * * // Useful for memory-efficient grid representations * Points.xy.ByteBytePoint gridCell = Points.xy.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte v) { return new ByteBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * a full integer range for the associated value, such as counting or indexing operations. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and integer value * Points.xy.ByteIntPoint point = Points.xy.ByteIntPoint.of((byte) 5, (byte) 10, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * int value = point.v(); // 1000 * * // Useful for small grids with large counts or indices * Points.xy.ByteIntPoint cellWithCount = Points.xy.ByteIntPoint.of((byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final int v) { return new ByteIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * a full long integer range for the associated value, such as timestamps or large counts. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and long value * Points.xy.ByteLongPoint point = Points.xy.ByteLongPoint.of((byte) 3, (byte) 7, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * long value = point.v(); // 1000000000 * * // Useful for small grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.ByteLongPoint cellWithTime = Points.xy.ByteLongPoint.of((byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final long v) { return new ByteLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * floating-point precision for the associated value, such as probabilities, weights, or measurements. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and double value * Points.xy.ByteDoublePoint point = Points.xy.ByteDoublePoint.of((byte) 2, (byte) 4, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * double value = point.v(); // 3.14159 * * // Useful for small grids with probability or weight values * Points.xy.ByteDoublePoint cellWithProbability = Points.xy.ByteDoublePoint.of((byte) 1, (byte) 1, 0.75); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final double v) { return new ByteDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific coordinates. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and a String value * Points.xy.ByteObjPoint<String> point = Points.xy.ByteObjPoint.of((byte) 1, (byte) 2, "label"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * String value = point.v(); // "label" * * // Useful for small grids with complex metadata * record Metadata(String name, int priority) {} * Metadata meta = new Metadata("important", 10); * Points.xy.ByteObjPoint<Metadata> cellWithMeta = Points.xy.ByteObjPoint.of((byte) 0, (byte) 0, meta); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final T v) { return new ByteObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and byte value * Points.xy.IntBytePoint point = Points.xy.IntBytePoint.of(100, 200, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * byte value = point.v(); // 10 * * // Useful for large grids with small enumeration values * Points.xy.IntBytePoint cellType = Points.xy.IntBytePoint.of(1000, 2000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final byte v) { return new IntBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * both coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and integer value * Points.xy.IntIntPoint point = Points.xy.IntIntPoint.of(100, 200, 300); * int x = point.x(); // 100 * int y = point.y(); // 200 * int value = point.v(); // 300 * * // Common use case: grid cells with counts or indices * Points.xy.IntIntPoint gridCell = Points.xy.IntIntPoint.of(10, 20, 5000); * * // Use in pathfinding with cost values * Points.xy.IntIntPoint pathNode = Points.xy.IntIntPoint.of(5, 8, 15); // cost = 15 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int v) { return new IntIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and long value * Points.xy.IntLongPoint point = Points.xy.IntLongPoint.of(50, 75, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * long value = point.v(); // 10000000000 * * // Useful for grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.IntLongPoint cellWithTime = Points.xy.IntLongPoint.of(10, 20, timestamp); * * // Track large identifiers in a grid * Points.xy.IntLongPoint cellWithId = Points.xy.IntLongPoint.of(5, 8, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final long v) { return new IntLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer grid coordinates but requiring * floating-point precision for the associated value, such as weights, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and double value * Points.xy.IntDoublePoint point = Points.xy.IntDoublePoint.of(10, 20, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * double value = point.v(); // 3.14159 * * // Useful for grids with probability values * Points.xy.IntDoublePoint cellProbability = Points.xy.IntDoublePoint.of(5, 8, 0.85); * * // Distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20); * Points.xy.IntDoublePoint nodeWithDistance = Points.xy.IntDoublePoint.of(10, 20, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final double v) { return new IntDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer coordinates, making it suitable for complex grid-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and a String value * Points.xy.IntObjPoint<String> point = Points.xy.IntObjPoint.of(10, 20, "label"); * int x = point.x(); // 10 * int y = point.y(); // 20 * String value = point.v(); // "label" * * // Grid with custom objects * record Cell(String type, int priority, boolean active) {} * Cell cell = new Cell("wall", 5, true); * Points.xy.IntObjPoint<Cell> gridCell = Points.xy.IntObjPoint.of(5, 8, cell); * * // Store collections at grid positions * List<String> items = List.of("item1", "item2"); * Points.xy.IntObjPoint<List<String>> cellItems = Points.xy.IntObjPoint.of(3, 7, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final T v) { return new IntObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and byte value * Points.xy.LongBytePoint point = Points.xy.LongBytePoint.of(1000000L, 2000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * byte value = point.v(); // 5 * * // Useful for very large grids with small enumeration values * Points.xy.LongBytePoint cellType = Points.xy.LongBytePoint.of(999999999L, 888888888L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final byte v) { return new LongBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`byte`)
  - `y` (`byte`)
  - `v` (`byte`)

### Record ByteIntPoint (com.landawn.abacus.util.Points.xy.ByteIntPoint)
Represents an immutable two-dimensional point with byte coordinates and an integer value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ByteIntPoint
- **Signature:** `public static ByteIntPoint of(final byte x, final byte y, final int v)`
- **Summary:** Creates a new ByteIntPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with small-range coordinates but requiring a full integer range for the associated value, such as counting or indexing operations.
- **Parameters:**
  - `x` (`byte`) — the x-coordinate of the point, must be in the range \[-128, 127\]
  - `y` (`byte`) — the y-coordinate of the point, must be in the range \[-128, 127\]
  - `v` (`int`) — the integer value associated with this point
- **Returns:** a new ByteIntPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record ByteIntPoint(byte x, byte y, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * a full integer range for the associated value, such as counting or indexing operations. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and integer value * Points.xy.ByteIntPoint point = Points.xy.ByteIntPoint.of((byte) 5, (byte) 10, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * int value = point.v(); // 1000 * * // Useful for small grids with large counts or indices * Points.xy.ByteIntPoint cellWithCount = Points.xy.ByteIntPoint.of((byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final int v) { return new ByteIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * a full long integer range for the associated value, such as timestamps or large counts. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and long value * Points.xy.ByteLongPoint point = Points.xy.ByteLongPoint.of((byte) 3, (byte) 7, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * long value = point.v(); // 1000000000 * * // Useful for small grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.ByteLongPoint cellWithTime = Points.xy.ByteLongPoint.of((byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final long v) { return new ByteLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * floating-point precision for the associated value, such as probabilities, weights, or measurements. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and double value * Points.xy.ByteDoublePoint point = Points.xy.ByteDoublePoint.of((byte) 2, (byte) 4, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * double value = point.v(); // 3.14159 * * // Useful for small grids with probability or weight values * Points.xy.ByteDoublePoint cellWithProbability = Points.xy.ByteDoublePoint.of((byte) 1, (byte) 1, 0.75); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final double v) { return new ByteDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific coordinates. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and a String value * Points.xy.ByteObjPoint<String> point = Points.xy.ByteObjPoint.of((byte) 1, (byte) 2, "label"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * String value = point.v(); // "label" * * // Useful for small grids with complex metadata * record Metadata(String name, int priority) {} * Metadata meta = new Metadata("important", 10); * Points.xy.ByteObjPoint<Metadata> cellWithMeta = Points.xy.ByteObjPoint.of((byte) 0, (byte) 0, meta); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final T v) { return new ByteObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and byte value * Points.xy.IntBytePoint point = Points.xy.IntBytePoint.of(100, 200, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * byte value = point.v(); // 10 * * // Useful for large grids with small enumeration values * Points.xy.IntBytePoint cellType = Points.xy.IntBytePoint.of(1000, 2000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final byte v) { return new IntBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * both coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and integer value * Points.xy.IntIntPoint point = Points.xy.IntIntPoint.of(100, 200, 300); * int x = point.x(); // 100 * int y = point.y(); // 200 * int value = point.v(); // 300 * * // Common use case: grid cells with counts or indices * Points.xy.IntIntPoint gridCell = Points.xy.IntIntPoint.of(10, 20, 5000); * * // Use in pathfinding with cost values * Points.xy.IntIntPoint pathNode = Points.xy.IntIntPoint.of(5, 8, 15); // cost = 15 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int v) { return new IntIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and long value * Points.xy.IntLongPoint point = Points.xy.IntLongPoint.of(50, 75, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * long value = point.v(); // 10000000000 * * // Useful for grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.IntLongPoint cellWithTime = Points.xy.IntLongPoint.of(10, 20, timestamp); * * // Track large identifiers in a grid * Points.xy.IntLongPoint cellWithId = Points.xy.IntLongPoint.of(5, 8, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final long v) { return new IntLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer grid coordinates but requiring * floating-point precision for the associated value, such as weights, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and double value * Points.xy.IntDoublePoint point = Points.xy.IntDoublePoint.of(10, 20, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * double value = point.v(); // 3.14159 * * // Useful for grids with probability values * Points.xy.IntDoublePoint cellProbability = Points.xy.IntDoublePoint.of(5, 8, 0.85); * * // Distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20); * Points.xy.IntDoublePoint nodeWithDistance = Points.xy.IntDoublePoint.of(10, 20, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final double v) { return new IntDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer coordinates, making it suitable for complex grid-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and a String value * Points.xy.IntObjPoint<String> point = Points.xy.IntObjPoint.of(10, 20, "label"); * int x = point.x(); // 10 * int y = point.y(); // 20 * String value = point.v(); // "label" * * // Grid with custom objects * record Cell(String type, int priority, boolean active) {} * Cell cell = new Cell("wall", 5, true); * Points.xy.IntObjPoint<Cell> gridCell = Points.xy.IntObjPoint.of(5, 8, cell); * * // Store collections at grid positions * List<String> items = List.of("item1", "item2"); * Points.xy.IntObjPoint<List<String>> cellItems = Points.xy.IntObjPoint.of(3, 7, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final T v) { return new IntObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and byte value * Points.xy.LongBytePoint point = Points.xy.LongBytePoint.of(1000000L, 2000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * byte value = point.v(); // 5 * * // Useful for very large grids with small enumeration values * Points.xy.LongBytePoint cellType = Points.xy.LongBytePoint.of(999999999L, 888888888L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final byte v) { return new LongBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`byte`)
  - `y` (`byte`)
  - `v` (`int`)

### Record ByteLongPoint (com.landawn.abacus.util.Points.xy.ByteLongPoint)
Represents an immutable two-dimensional point with byte coordinates and a long value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ByteLongPoint
- **Signature:** `public static ByteLongPoint of(final byte x, final byte y, final long v)`
- **Summary:** Creates a new ByteLongPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with small-range coordinates but requiring a full long integer range for the associated value, such as timestamps or large counts.
- **Parameters:**
  - `x` (`byte`) — the x-coordinate of the point, must be in the range \[-128, 127\]
  - `y` (`byte`) — the y-coordinate of the point, must be in the range \[-128, 127\]
  - `v` (`long`) — the long value associated with this point
- **Returns:** a new ByteLongPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record ByteLongPoint(byte x, byte y, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * a full long integer range for the associated value, such as timestamps or large counts. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and long value * Points.xy.ByteLongPoint point = Points.xy.ByteLongPoint.of((byte) 3, (byte) 7, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * long value = point.v(); // 1000000000 * * // Useful for small grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.ByteLongPoint cellWithTime = Points.xy.ByteLongPoint.of((byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final long v) { return new ByteLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * floating-point precision for the associated value, such as probabilities, weights, or measurements. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and double value * Points.xy.ByteDoublePoint point = Points.xy.ByteDoublePoint.of((byte) 2, (byte) 4, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * double value = point.v(); // 3.14159 * * // Useful for small grids with probability or weight values * Points.xy.ByteDoublePoint cellWithProbability = Points.xy.ByteDoublePoint.of((byte) 1, (byte) 1, 0.75); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final double v) { return new ByteDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific coordinates. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and a String value * Points.xy.ByteObjPoint<String> point = Points.xy.ByteObjPoint.of((byte) 1, (byte) 2, "label"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * String value = point.v(); // "label" * * // Useful for small grids with complex metadata * record Metadata(String name, int priority) {} * Metadata meta = new Metadata("important", 10); * Points.xy.ByteObjPoint<Metadata> cellWithMeta = Points.xy.ByteObjPoint.of((byte) 0, (byte) 0, meta); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final T v) { return new ByteObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and byte value * Points.xy.IntBytePoint point = Points.xy.IntBytePoint.of(100, 200, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * byte value = point.v(); // 10 * * // Useful for large grids with small enumeration values * Points.xy.IntBytePoint cellType = Points.xy.IntBytePoint.of(1000, 2000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final byte v) { return new IntBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * both coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and integer value * Points.xy.IntIntPoint point = Points.xy.IntIntPoint.of(100, 200, 300); * int x = point.x(); // 100 * int y = point.y(); // 200 * int value = point.v(); // 300 * * // Common use case: grid cells with counts or indices * Points.xy.IntIntPoint gridCell = Points.xy.IntIntPoint.of(10, 20, 5000); * * // Use in pathfinding with cost values * Points.xy.IntIntPoint pathNode = Points.xy.IntIntPoint.of(5, 8, 15); // cost = 15 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int v) { return new IntIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and long value * Points.xy.IntLongPoint point = Points.xy.IntLongPoint.of(50, 75, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * long value = point.v(); // 10000000000 * * // Useful for grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.IntLongPoint cellWithTime = Points.xy.IntLongPoint.of(10, 20, timestamp); * * // Track large identifiers in a grid * Points.xy.IntLongPoint cellWithId = Points.xy.IntLongPoint.of(5, 8, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final long v) { return new IntLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer grid coordinates but requiring * floating-point precision for the associated value, such as weights, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and double value * Points.xy.IntDoublePoint point = Points.xy.IntDoublePoint.of(10, 20, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * double value = point.v(); // 3.14159 * * // Useful for grids with probability values * Points.xy.IntDoublePoint cellProbability = Points.xy.IntDoublePoint.of(5, 8, 0.85); * * // Distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20); * Points.xy.IntDoublePoint nodeWithDistance = Points.xy.IntDoublePoint.of(10, 20, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final double v) { return new IntDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer coordinates, making it suitable for complex grid-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and a String value * Points.xy.IntObjPoint<String> point = Points.xy.IntObjPoint.of(10, 20, "label"); * int x = point.x(); // 10 * int y = point.y(); // 20 * String value = point.v(); // "label" * * // Grid with custom objects * record Cell(String type, int priority, boolean active) {} * Cell cell = new Cell("wall", 5, true); * Points.xy.IntObjPoint<Cell> gridCell = Points.xy.IntObjPoint.of(5, 8, cell); * * // Store collections at grid positions * List<String> items = List.of("item1", "item2"); * Points.xy.IntObjPoint<List<String>> cellItems = Points.xy.IntObjPoint.of(3, 7, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final T v) { return new IntObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and byte value * Points.xy.LongBytePoint point = Points.xy.LongBytePoint.of(1000000L, 2000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * byte value = point.v(); // 5 * * // Useful for very large grids with small enumeration values * Points.xy.LongBytePoint cellType = Points.xy.LongBytePoint.of(999999999L, 888888888L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final byte v) { return new LongBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`byte`)
  - `y` (`byte`)
  - `v` (`long`)

### Record ByteDoublePoint (com.landawn.abacus.util.Points.xy.ByteDoublePoint)
Represents an immutable two-dimensional point with byte coordinates and a double-precision floating-point value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ByteDoublePoint
- **Signature:** `public static ByteDoublePoint of(final byte x, final byte y, final double v)`
- **Summary:** Creates a new ByteDoublePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with small-range coordinates but requiring floating-point precision for the associated value, such as probabilities, weights, or measurements.
- **Parameters:**
  - `x` (`byte`) — the x-coordinate of the point, must be in the range \[-128, 127\]
  - `y` (`byte`) — the y-coordinate of the point, must be in the range \[-128, 127\]
  - `v` (`double`) — the double value associated with this point
- **Returns:** a new ByteDoublePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record ByteDoublePoint(byte x, byte y, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * floating-point precision for the associated value, such as probabilities, weights, or measurements. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and double value * Points.xy.ByteDoublePoint point = Points.xy.ByteDoublePoint.of((byte) 2, (byte) 4, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * double value = point.v(); // 3.14159 * * // Useful for small grids with probability or weight values * Points.xy.ByteDoublePoint cellWithProbability = Points.xy.ByteDoublePoint.of((byte) 1, (byte) 1, 0.75); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final double v) { return new ByteDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific coordinates. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and a String value * Points.xy.ByteObjPoint<String> point = Points.xy.ByteObjPoint.of((byte) 1, (byte) 2, "label"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * String value = point.v(); // "label" * * // Useful for small grids with complex metadata * record Metadata(String name, int priority) {} * Metadata meta = new Metadata("important", 10); * Points.xy.ByteObjPoint<Metadata> cellWithMeta = Points.xy.ByteObjPoint.of((byte) 0, (byte) 0, meta); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final T v) { return new ByteObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and byte value * Points.xy.IntBytePoint point = Points.xy.IntBytePoint.of(100, 200, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * byte value = point.v(); // 10 * * // Useful for large grids with small enumeration values * Points.xy.IntBytePoint cellType = Points.xy.IntBytePoint.of(1000, 2000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final byte v) { return new IntBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * both coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and integer value * Points.xy.IntIntPoint point = Points.xy.IntIntPoint.of(100, 200, 300); * int x = point.x(); // 100 * int y = point.y(); // 200 * int value = point.v(); // 300 * * // Common use case: grid cells with counts or indices * Points.xy.IntIntPoint gridCell = Points.xy.IntIntPoint.of(10, 20, 5000); * * // Use in pathfinding with cost values * Points.xy.IntIntPoint pathNode = Points.xy.IntIntPoint.of(5, 8, 15); // cost = 15 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int v) { return new IntIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and long value * Points.xy.IntLongPoint point = Points.xy.IntLongPoint.of(50, 75, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * long value = point.v(); // 10000000000 * * // Useful for grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.IntLongPoint cellWithTime = Points.xy.IntLongPoint.of(10, 20, timestamp); * * // Track large identifiers in a grid * Points.xy.IntLongPoint cellWithId = Points.xy.IntLongPoint.of(5, 8, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final long v) { return new IntLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer grid coordinates but requiring * floating-point precision for the associated value, such as weights, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and double value * Points.xy.IntDoublePoint point = Points.xy.IntDoublePoint.of(10, 20, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * double value = point.v(); // 3.14159 * * // Useful for grids with probability values * Points.xy.IntDoublePoint cellProbability = Points.xy.IntDoublePoint.of(5, 8, 0.85); * * // Distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20); * Points.xy.IntDoublePoint nodeWithDistance = Points.xy.IntDoublePoint.of(10, 20, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final double v) { return new IntDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer coordinates, making it suitable for complex grid-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and a String value * Points.xy.IntObjPoint<String> point = Points.xy.IntObjPoint.of(10, 20, "label"); * int x = point.x(); // 10 * int y = point.y(); // 20 * String value = point.v(); // "label" * * // Grid with custom objects * record Cell(String type, int priority, boolean active) {} * Cell cell = new Cell("wall", 5, true); * Points.xy.IntObjPoint<Cell> gridCell = Points.xy.IntObjPoint.of(5, 8, cell); * * // Store collections at grid positions * List<String> items = List.of("item1", "item2"); * Points.xy.IntObjPoint<List<String>> cellItems = Points.xy.IntObjPoint.of(3, 7, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final T v) { return new IntObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and byte value * Points.xy.LongBytePoint point = Points.xy.LongBytePoint.of(1000000L, 2000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * byte value = point.v(); // 5 * * // Useful for very large grids with small enumeration values * Points.xy.LongBytePoint cellType = Points.xy.LongBytePoint.of(999999999L, 888888888L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final byte v) { return new LongBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`byte`)
  - `y` (`byte`)
  - `v` (`double`)

### Record ByteObjPoint (com.landawn.abacus.util.Points.xy.ByteObjPoint)
Represents an immutable two-dimensional point with byte coordinates and a generic object value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ByteObjPoint<T>
- **Signature:** `public static <T> ByteObjPoint<T> of(final byte x, final byte y, final T v)`
- **Summary:** Creates a new ByteObjPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with small-range coordinates but requiring any object type for the associated value, providing maximum flexibility for storing complex data structures at specific coordinates.
- **Parameters:**
  - `x` (`byte`) — the x-coordinate of the point, must be in the range \[-128, 127\]
  - `y` (`byte`) — the y-coordinate of the point, must be in the range \[-128, 127\]
  - `v` (`T`) — the object value associated with this point, may be {@code null}
- **Returns:** a new ByteObjPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record ByteObjPoint<T>(byte x, byte y, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific coordinates. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with byte coordinates and a String value * Points.xy.ByteObjPoint<String> point = Points.xy.ByteObjPoint.of((byte) 1, (byte) 2, "label"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * String value = point.v(); // "label" * * // Useful for small grids with complex metadata * record Metadata(String name, int priority) {} * Metadata meta = new Metadata("important", 10); * Points.xy.ByteObjPoint<Metadata> cellWithMeta = Points.xy.ByteObjPoint.of((byte) 0, (byte) 0, meta); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final T v) { return new ByteObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and byte value * Points.xy.IntBytePoint point = Points.xy.IntBytePoint.of(100, 200, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * byte value = point.v(); // 10 * * // Useful for large grids with small enumeration values * Points.xy.IntBytePoint cellType = Points.xy.IntBytePoint.of(1000, 2000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final byte v) { return new IntBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * both coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and integer value * Points.xy.IntIntPoint point = Points.xy.IntIntPoint.of(100, 200, 300); * int x = point.x(); // 100 * int y = point.y(); // 200 * int value = point.v(); // 300 * * // Common use case: grid cells with counts or indices * Points.xy.IntIntPoint gridCell = Points.xy.IntIntPoint.of(10, 20, 5000); * * // Use in pathfinding with cost values * Points.xy.IntIntPoint pathNode = Points.xy.IntIntPoint.of(5, 8, 15); // cost = 15 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int v) { return new IntIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and long value * Points.xy.IntLongPoint point = Points.xy.IntLongPoint.of(50, 75, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * long value = point.v(); // 10000000000 * * // Useful for grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.IntLongPoint cellWithTime = Points.xy.IntLongPoint.of(10, 20, timestamp); * * // Track large identifiers in a grid * Points.xy.IntLongPoint cellWithId = Points.xy.IntLongPoint.of(5, 8, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final long v) { return new IntLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer grid coordinates but requiring * floating-point precision for the associated value, such as weights, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and double value * Points.xy.IntDoublePoint point = Points.xy.IntDoublePoint.of(10, 20, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * double value = point.v(); // 3.14159 * * // Useful for grids with probability values * Points.xy.IntDoublePoint cellProbability = Points.xy.IntDoublePoint.of(5, 8, 0.85); * * // Distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20); * Points.xy.IntDoublePoint nodeWithDistance = Points.xy.IntDoublePoint.of(10, 20, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final double v) { return new IntDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer coordinates, making it suitable for complex grid-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and a String value * Points.xy.IntObjPoint<String> point = Points.xy.IntObjPoint.of(10, 20, "label"); * int x = point.x(); // 10 * int y = point.y(); // 20 * String value = point.v(); // "label" * * // Grid with custom objects * record Cell(String type, int priority, boolean active) {} * Cell cell = new Cell("wall", 5, true); * Points.xy.IntObjPoint<Cell> gridCell = Points.xy.IntObjPoint.of(5, 8, cell); * * // Store collections at grid positions * List<String> items = List.of("item1", "item2"); * Points.xy.IntObjPoint<List<String>> cellItems = Points.xy.IntObjPoint.of(3, 7, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final T v) { return new IntObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and byte value * Points.xy.LongBytePoint point = Points.xy.LongBytePoint.of(1000000L, 2000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * byte value = point.v(); // 5 * * // Useful for very large grids with small enumeration values * Points.xy.LongBytePoint cellType = Points.xy.LongBytePoint.of(999999999L, 888888888L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final byte v) { return new LongBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`byte`)
  - `y` (`byte`)
  - `v` (`T`)

### Record IntBytePoint (com.landawn.abacus.util.Points.xy.IntBytePoint)
Represents an immutable two-dimensional point with integer coordinates and a byte value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> IntBytePoint
- **Signature:** `public static IntBytePoint of(final int x, final int y, final byte v)`
- **Summary:** Creates a new IntBytePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with standard integer coordinates but the associated value fits within a byte range, providing memory efficiency for the value component.
- **Parameters:**
  - `x` (`int`) — the x-coordinate of the point
  - `y` (`int`) — the y-coordinate of the point
  - `v` (`byte`) — the byte value associated with this point, must be in the range \[-128, 127\]
- **Returns:** a new IntBytePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record IntBytePoint(int x, int y, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and byte value * Points.xy.IntBytePoint point = Points.xy.IntBytePoint.of(100, 200, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * byte value = point.v(); // 10 * * // Useful for large grids with small enumeration values * Points.xy.IntBytePoint cellType = Points.xy.IntBytePoint.of(1000, 2000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final byte v) { return new IntBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * both coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and integer value * Points.xy.IntIntPoint point = Points.xy.IntIntPoint.of(100, 200, 300); * int x = point.x(); // 100 * int y = point.y(); // 200 * int value = point.v(); // 300 * * // Common use case: grid cells with counts or indices * Points.xy.IntIntPoint gridCell = Points.xy.IntIntPoint.of(10, 20, 5000); * * // Use in pathfinding with cost values * Points.xy.IntIntPoint pathNode = Points.xy.IntIntPoint.of(5, 8, 15); // cost = 15 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int v) { return new IntIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and long value * Points.xy.IntLongPoint point = Points.xy.IntLongPoint.of(50, 75, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * long value = point.v(); // 10000000000 * * // Useful for grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.IntLongPoint cellWithTime = Points.xy.IntLongPoint.of(10, 20, timestamp); * * // Track large identifiers in a grid * Points.xy.IntLongPoint cellWithId = Points.xy.IntLongPoint.of(5, 8, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final long v) { return new IntLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer grid coordinates but requiring * floating-point precision for the associated value, such as weights, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and double value * Points.xy.IntDoublePoint point = Points.xy.IntDoublePoint.of(10, 20, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * double value = point.v(); // 3.14159 * * // Useful for grids with probability values * Points.xy.IntDoublePoint cellProbability = Points.xy.IntDoublePoint.of(5, 8, 0.85); * * // Distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20); * Points.xy.IntDoublePoint nodeWithDistance = Points.xy.IntDoublePoint.of(10, 20, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final double v) { return new IntDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer coordinates, making it suitable for complex grid-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and a String value * Points.xy.IntObjPoint<String> point = Points.xy.IntObjPoint.of(10, 20, "label"); * int x = point.x(); // 10 * int y = point.y(); // 20 * String value = point.v(); // "label" * * // Grid with custom objects * record Cell(String type, int priority, boolean active) {} * Cell cell = new Cell("wall", 5, true); * Points.xy.IntObjPoint<Cell> gridCell = Points.xy.IntObjPoint.of(5, 8, cell); * * // Store collections at grid positions * List<String> items = List.of("item1", "item2"); * Points.xy.IntObjPoint<List<String>> cellItems = Points.xy.IntObjPoint.of(3, 7, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final T v) { return new IntObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and byte value * Points.xy.LongBytePoint point = Points.xy.LongBytePoint.of(1000000L, 2000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * byte value = point.v(); // 5 * * // Useful for very large grids with small enumeration values * Points.xy.LongBytePoint cellType = Points.xy.LongBytePoint.of(999999999L, 888888888L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final byte v) { return new LongBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`int`)
  - `y` (`int`)
  - `v` (`byte`)

### Record IntIntPoint (com.landawn.abacus.util.Points.xy.IntIntPoint)
Represents an immutable two-dimensional point with integer coordinates and an integer value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> IntIntPoint
- **Signature:** `public static IntIntPoint of(final int x, final int y, final int v)`
- **Summary:** Creates a new IntIntPoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`int`) — the x-coordinate of the point
  - `y` (`int`) — the y-coordinate of the point
  - `v` (`int`) — the integer value associated with this point
- **Returns:** a new IntIntPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record IntIntPoint(int x, int y, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * both coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and integer value * Points.xy.IntIntPoint point = Points.xy.IntIntPoint.of(100, 200, 300); * int x = point.x(); // 100 * int y = point.y(); // 200 * int value = point.v(); // 300 * * // Common use case: grid cells with counts or indices * Points.xy.IntIntPoint gridCell = Points.xy.IntIntPoint.of(10, 20, 5000); * * // Use in pathfinding with cost values * Points.xy.IntIntPoint pathNode = Points.xy.IntIntPoint.of(5, 8, 15); // cost = 15 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int v) { return new IntIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and long value * Points.xy.IntLongPoint point = Points.xy.IntLongPoint.of(50, 75, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * long value = point.v(); // 10000000000 * * // Useful for grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.IntLongPoint cellWithTime = Points.xy.IntLongPoint.of(10, 20, timestamp); * * // Track large identifiers in a grid * Points.xy.IntLongPoint cellWithId = Points.xy.IntLongPoint.of(5, 8, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final long v) { return new IntLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer grid coordinates but requiring * floating-point precision for the associated value, such as weights, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and double value * Points.xy.IntDoublePoint point = Points.xy.IntDoublePoint.of(10, 20, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * double value = point.v(); // 3.14159 * * // Useful for grids with probability values * Points.xy.IntDoublePoint cellProbability = Points.xy.IntDoublePoint.of(5, 8, 0.85); * * // Distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20); * Points.xy.IntDoublePoint nodeWithDistance = Points.xy.IntDoublePoint.of(10, 20, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final double v) { return new IntDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer coordinates, making it suitable for complex grid-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and a String value * Points.xy.IntObjPoint<String> point = Points.xy.IntObjPoint.of(10, 20, "label"); * int x = point.x(); // 10 * int y = point.y(); // 20 * String value = point.v(); // "label" * * // Grid with custom objects * record Cell(String type, int priority, boolean active) {} * Cell cell = new Cell("wall", 5, true); * Points.xy.IntObjPoint<Cell> gridCell = Points.xy.IntObjPoint.of(5, 8, cell); * * // Store collections at grid positions * List<String> items = List.of("item1", "item2"); * Points.xy.IntObjPoint<List<String>> cellItems = Points.xy.IntObjPoint.of(3, 7, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final T v) { return new IntObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and byte value * Points.xy.LongBytePoint point = Points.xy.LongBytePoint.of(1000000L, 2000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * byte value = point.v(); // 5 * * // Useful for very large grids with small enumeration values * Points.xy.LongBytePoint cellType = Points.xy.LongBytePoint.of(999999999L, 888888888L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final byte v) { return new LongBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`int`)
  - `y` (`int`)
  - `v` (`int`)

### Record IntLongPoint (com.landawn.abacus.util.Points.xy.IntLongPoint)
Represents an immutable two-dimensional point with integer coordinates and a long value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> IntLongPoint
- **Signature:** `public static IntLongPoint of(final int x, final int y, final long v)`
- **Summary:** Creates a new IntLongPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with standard integer coordinates but requiring a long value for timestamps, large counts, or identifiers that exceed the integer range.
- **Parameters:**
  - `x` (`int`) — the x-coordinate of the point
  - `y` (`int`) — the y-coordinate of the point
  - `v` (`long`) — the long value associated with this point
- **Returns:** a new IntLongPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record IntLongPoint(int x, int y, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and long value * Points.xy.IntLongPoint point = Points.xy.IntLongPoint.of(50, 75, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * long value = point.v(); // 10000000000 * * // Useful for grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.IntLongPoint cellWithTime = Points.xy.IntLongPoint.of(10, 20, timestamp); * * // Track large identifiers in a grid * Points.xy.IntLongPoint cellWithId = Points.xy.IntLongPoint.of(5, 8, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final long v) { return new IntLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer grid coordinates but requiring * floating-point precision for the associated value, such as weights, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and double value * Points.xy.IntDoublePoint point = Points.xy.IntDoublePoint.of(10, 20, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * double value = point.v(); // 3.14159 * * // Useful for grids with probability values * Points.xy.IntDoublePoint cellProbability = Points.xy.IntDoublePoint.of(5, 8, 0.85); * * // Distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20); * Points.xy.IntDoublePoint nodeWithDistance = Points.xy.IntDoublePoint.of(10, 20, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final double v) { return new IntDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer coordinates, making it suitable for complex grid-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and a String value * Points.xy.IntObjPoint<String> point = Points.xy.IntObjPoint.of(10, 20, "label"); * int x = point.x(); // 10 * int y = point.y(); // 20 * String value = point.v(); // "label" * * // Grid with custom objects * record Cell(String type, int priority, boolean active) {} * Cell cell = new Cell("wall", 5, true); * Points.xy.IntObjPoint<Cell> gridCell = Points.xy.IntObjPoint.of(5, 8, cell); * * // Store collections at grid positions * List<String> items = List.of("item1", "item2"); * Points.xy.IntObjPoint<List<String>> cellItems = Points.xy.IntObjPoint.of(3, 7, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final T v) { return new IntObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and byte value * Points.xy.LongBytePoint point = Points.xy.LongBytePoint.of(1000000L, 2000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * byte value = point.v(); // 5 * * // Useful for very large grids with small enumeration values * Points.xy.LongBytePoint cellType = Points.xy.LongBytePoint.of(999999999L, 888888888L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final byte v) { return new LongBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`int`)
  - `y` (`int`)
  - `v` (`long`)

### Record IntDoublePoint (com.landawn.abacus.util.Points.xy.IntDoublePoint)
Represents an immutable two-dimensional point with integer coordinates and a double-precision floating-point value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> IntDoublePoint
- **Signature:** `public static IntDoublePoint of(final int x, final int y, final double v)`
- **Summary:** Creates a new IntDoublePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with standard integer grid coordinates but requiring floating-point precision for the associated value, such as weights, distances, or probabilities.
- **Parameters:**
  - `x` (`int`) — the x-coordinate of the point
  - `y` (`int`) — the y-coordinate of the point
  - `v` (`double`) — the double value associated with this point
- **Returns:** a new IntDoublePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record IntDoublePoint(int x, int y, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer grid coordinates but requiring * floating-point precision for the associated value, such as weights, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and double value * Points.xy.IntDoublePoint point = Points.xy.IntDoublePoint.of(10, 20, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * double value = point.v(); // 3.14159 * * // Useful for grids with probability values * Points.xy.IntDoublePoint cellProbability = Points.xy.IntDoublePoint.of(5, 8, 0.85); * * // Distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20); * Points.xy.IntDoublePoint nodeWithDistance = Points.xy.IntDoublePoint.of(10, 20, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final double v) { return new IntDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer coordinates, making it suitable for complex grid-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and a String value * Points.xy.IntObjPoint<String> point = Points.xy.IntObjPoint.of(10, 20, "label"); * int x = point.x(); // 10 * int y = point.y(); // 20 * String value = point.v(); // "label" * * // Grid with custom objects * record Cell(String type, int priority, boolean active) {} * Cell cell = new Cell("wall", 5, true); * Points.xy.IntObjPoint<Cell> gridCell = Points.xy.IntObjPoint.of(5, 8, cell); * * // Store collections at grid positions * List<String> items = List.of("item1", "item2"); * Points.xy.IntObjPoint<List<String>> cellItems = Points.xy.IntObjPoint.of(3, 7, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final T v) { return new IntObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and byte value * Points.xy.LongBytePoint point = Points.xy.LongBytePoint.of(1000000L, 2000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * byte value = point.v(); // 5 * * // Useful for very large grids with small enumeration values * Points.xy.LongBytePoint cellType = Points.xy.LongBytePoint.of(999999999L, 888888888L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final byte v) { return new LongBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`int`)
  - `y` (`int`)
  - `v` (`double`)

### Record IntObjPoint (com.landawn.abacus.util.Points.xy.IntObjPoint)
Represents an immutable two-dimensional point with integer coordinates and a generic object value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> IntObjPoint<T>
- **Signature:** `public static <T> IntObjPoint<T> of(final int x, final int y, final T v)`
- **Summary:** Creates a new IntObjPoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`int`) — the x-coordinate of the point
  - `y` (`int`) — the y-coordinate of the point
  - `v` (`T`) — the object value associated with this point, may be {@code null}
- **Returns:** a new IntObjPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record IntObjPoint<T>(int x, int y, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer coordinates, making it suitable for complex grid-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with integer coordinates and a String value * Points.xy.IntObjPoint<String> point = Points.xy.IntObjPoint.of(10, 20, "label"); * int x = point.x(); // 10 * int y = point.y(); // 20 * String value = point.v(); // "label" * * // Grid with custom objects * record Cell(String type, int priority, boolean active) {} * Cell cell = new Cell("wall", 5, true); * Points.xy.IntObjPoint<Cell> gridCell = Points.xy.IntObjPoint.of(5, 8, cell); * * // Store collections at grid positions * List<String> items = List.of("item1", "item2"); * Points.xy.IntObjPoint<List<String>> cellItems = Points.xy.IntObjPoint.of(3, 7, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final T v) { return new IntObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and byte value * Points.xy.LongBytePoint point = Points.xy.LongBytePoint.of(1000000L, 2000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * byte value = point.v(); // 5 * * // Useful for very large grids with small enumeration values * Points.xy.LongBytePoint cellType = Points.xy.LongBytePoint.of(999999999L, 888888888L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final byte v) { return new LongBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`int`)
  - `y` (`int`)
  - `v` (`T`)

### Record LongBytePoint (com.landawn.abacus.util.Points.xy.LongBytePoint)
Represents an immutable two-dimensional point with long coordinates and a byte value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> LongBytePoint
- **Signature:** `public static LongBytePoint of(final long x, final long y, final byte v)`
- **Summary:** Creates a new LongBytePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with very large coordinate spaces requiring long values but the associated value fits within a byte range, optimizing memory for the value component.
- **Parameters:**
  - `x` (`long`) — the x-coordinate of the point
  - `y` (`long`) — the y-coordinate of the point
  - `v` (`byte`) — the byte value associated with this point, must be in the range \[-128, 127\]
- **Returns:** a new LongBytePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record LongBytePoint(long x, long y, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and byte value * Points.xy.LongBytePoint point = Points.xy.LongBytePoint.of(1000000L, 2000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * byte value = point.v(); // 5 * * // Useful for very large grids with small enumeration values * Points.xy.LongBytePoint cellType = Points.xy.LongBytePoint.of(999999999L, 888888888L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final byte v) { return new LongBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`long`)
  - `y` (`long`)
  - `v` (`byte`)

### Record LongIntPoint (com.landawn.abacus.util.Points.xy.LongIntPoint)
Represents an immutable two-dimensional point with long coordinates and an integer value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> LongIntPoint
- **Signature:** `public static LongIntPoint of(final long x, final long y, final int v)`
- **Summary:** Creates a new LongIntPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with very large coordinate spaces requiring long values but the associated value fits within the integer range.
- **Parameters:**
  - `x` (`long`) — the x-coordinate of the point
  - `y` (`long`) — the y-coordinate of the point
  - `v` (`int`) — the integer value associated with this point
- **Returns:** a new LongIntPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record LongIntPoint(long x, long y, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and integer value * Points.xy.LongIntPoint point = Points.xy.LongIntPoint.of(1000000L, 2000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * int value = point.v(); // 500 * * // Useful for very large grids with counts or indices * Points.xy.LongIntPoint cellCount = Points.xy.LongIntPoint.of(999999999L, 888888888L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final int v) { return new LongIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`long`)
  - `y` (`long`)
  - `v` (`int`)

### Record LongLongPoint (com.landawn.abacus.util.Points.xy.LongLongPoint)
Represents an immutable two-dimensional point with long coordinates and a long value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> LongLongPoint
- **Signature:** `public static LongLongPoint of(final long x, final long y, final long v)`
- **Summary:** Creates a new LongLongPoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`long`) — the x-coordinate of the point
  - `y` (`long`) — the y-coordinate of the point
  - `v` (`long`) — the long value associated with this point
- **Returns:** a new LongLongPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record LongLongPoint(long x, long y, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and long value * Points.xy.LongLongPoint point = Points.xy.LongLongPoint.of(1000000L, 2000000L, 3000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long value = point.v(); // 3000000000 * * // Useful for very large grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.LongLongPoint cellTime = Points.xy.LongLongPoint.of(999999999L, 888888888L, timestamp); * * // Large coordinate space with large identifiers * Points.xy.LongLongPoint cellId = Points.xy.LongLongPoint.of(1L << 40, 1L << 41, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long v) { return new LongLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`long`)
  - `y` (`long`)
  - `v` (`long`)

### Record LongDoublePoint (com.landawn.abacus.util.Points.xy.LongDoublePoint)
Represents an immutable two-dimensional point with long coordinates and a double-precision floating-point value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> LongDoublePoint
- **Signature:** `public static LongDoublePoint of(final long x, final long y, final double v)`
- **Summary:** Creates a new LongDoublePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with very large coordinate spaces requiring long values but needing floating-point precision for the associated value.
- **Parameters:**
  - `x` (`long`) — the x-coordinate of the point
  - `y` (`long`) — the y-coordinate of the point
  - `v` (`double`) — the double value associated with this point
- **Returns:** a new LongDoublePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record LongDoublePoint(long x, long y, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and double value * Points.xy.LongDoublePoint point = Points.xy.LongDoublePoint.of(1000000L, 2000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * double value = point.v(); // 3.14159 * * // Useful for very large grids with probability or weight values * Points.xy.LongDoublePoint cellWeight = Points.xy.LongDoublePoint.of(999999999L, 888888888L, 0.85); * * // Large coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0); * Points.xy.LongDoublePoint cellDistance = Points.xy.LongDoublePoint.of(1000000L, 2000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final double v) { return new LongDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`long`)
  - `y` (`long`)
  - `v` (`double`)

### Record LongObjPoint (com.landawn.abacus.util.Points.xy.LongObjPoint)
Represents an immutable two-dimensional point with long coordinates and a generic object value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> LongObjPoint<T>
- **Signature:** `public static <T> LongObjPoint<T> of(final long x, final long y, final T v)`
- **Summary:** Creates a new LongObjPoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`long`) — the x-coordinate of the point
  - `y` (`long`) — the y-coordinate of the point
  - `v` (`T`) — the object value associated with this point, may be {@code null}
- **Returns:** a new LongObjPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record LongObjPoint<T>(long x, long y, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with long coordinates and a String value * Points.xy.LongObjPoint<String> point = Points.xy.LongObjPoint.of(1000000L, 2000000L, "marker"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * String value = point.v(); // "marker" * * // Very large grid with custom objects * record Region(String name, int population) {} * Region region = new Region("Zone-A", 1000000); * Points.xy.LongObjPoint<Region> gridRegion = Points.xy.LongObjPoint.of(999999999L, 888888888L, region); * * // Spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "city", "size", 500000); * Points.xy.LongObjPoint<Map<String, Object>> location = Points.xy.LongObjPoint.of(1L << 40, 1L << 41, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final T v) { return new LongObjPoint<>(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`long`)
  - `y` (`long`)
  - `v` (`T`)

### Record DoubleBytePoint (com.landawn.abacus.util.Points.xy.DoubleBytePoint)
Represents an immutable two-dimensional point with double-precision floating-point coordinates and a byte value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> DoubleBytePoint
- **Signature:** `public static DoubleBytePoint of(final double x, final double y, final byte v)`
- **Summary:** Creates a new DoubleBytePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with floating-point coordinate spaces but the associated value fits within a byte range, optimizing memory for the value component.
- **Parameters:**
  - `x` (`double`) — the x-coordinate of the point
  - `y` (`double`) — the y-coordinate of the point
  - `v` (`byte`) — the byte value associated with this point, must be in the range \[-128, 127\]
- **Returns:** a new DoubleBytePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record DoubleBytePoint(double x, double y, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and byte value * Points.xy.DoubleBytePoint point = Points.xy.DoubleBytePoint.of(10.5, 20.7, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * byte value = point.v(); // 3 * * // Useful for continuous coordinate spaces with small enumeration values * Points.xy.DoubleBytePoint region = Points.xy.DoubleBytePoint.of(3.14159, 2.71828, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final byte v) { return new DoubleBytePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`double`)
  - `y` (`double`)
  - `v` (`byte`)

### Record DoubleIntPoint (com.landawn.abacus.util.Points.xy.DoubleIntPoint)
Represents an immutable two-dimensional point with double-precision floating-point coordinates and an integer value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> DoubleIntPoint
- **Signature:** `public static DoubleIntPoint of(final double x, final double y, final int v)`
- **Summary:** Creates a new DoubleIntPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with floating-point coordinate spaces but the associated value fits within the integer range, such as counts or indices in continuous spaces.
- **Parameters:**
  - `x` (`double`) — the x-coordinate of the point
  - `y` (`double`) — the y-coordinate of the point
  - `v` (`int`) — the integer value associated with this point
- **Returns:** a new DoubleIntPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record DoubleIntPoint(double x, double y, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and integer value * Points.xy.DoubleIntPoint point = Points.xy.DoubleIntPoint.of(10.5, 20.7, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * int value = point.v(); // 100 * * // Useful for continuous coordinate spaces with counts * Points.xy.DoubleIntPoint sample = Points.xy.DoubleIntPoint.of(3.14159, 2.71828, 1000); * * // Geographic coordinates with elevation * Points.xy.DoubleIntPoint geoPoint = Points.xy.DoubleIntPoint.of(40.7128, -74.0060, 10); // elevation in meters * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final int v) { return new DoubleIntPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`double`)
  - `y` (`double`)
  - `v` (`int`)

### Record DoubleLongPoint (com.landawn.abacus.util.Points.xy.DoubleLongPoint)
Represents an immutable two-dimensional point with double-precision floating-point coordinates and a long value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> DoubleLongPoint
- **Signature:** `public static DoubleLongPoint of(final double x, final double y, final long v)`
- **Summary:** Creates a new DoubleLongPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with floating-point coordinate spaces and requiring long values for timestamps, large identifiers, or counts that exceed the integer range.
- **Parameters:**
  - `x` (`double`) — the x-coordinate of the point
  - `y` (`double`) — the y-coordinate of the point
  - `v` (`long`) — the long value associated with this point
- **Returns:** a new DoubleLongPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record DoubleLongPoint(double x, double y, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and long value * Points.xy.DoubleLongPoint point = Points.xy.DoubleLongPoint.of(10.5, 20.7, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * long value = point.v(); // 1000000000 * * // Useful for continuous coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xy.DoubleLongPoint sample = Points.xy.DoubleLongPoint.of(3.14159, 2.71828, timestamp); * * // Geographic coordinates with large identifiers * Points.xy.DoubleLongPoint location = Points.xy.DoubleLongPoint.of(40.7128, -74.0060, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final long v) { return new DoubleLongPoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`double`)
  - `y` (`double`)
  - `v` (`long`)

### Record DoubleDoublePoint (com.landawn.abacus.util.Points.xy.DoubleDoublePoint)
Represents an immutable two-dimensional point with double-precision floating-point coordinates and value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> DoubleDoublePoint
- **Signature:** `public static DoubleDoublePoint of(final double x, final double y, final double v)`
- **Summary:** Creates a new DoubleDoublePoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`double`) — the x-coordinate of the point
  - `y` (`double`) — the y-coordinate of the point
  - `v` (`double`) — the double value associated with this point
- **Returns:** a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record DoubleDoublePoint(double x, double y, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both coordinates * and the associated value, ideal for continuous mathematical and scientific applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and double value * Points.xy.DoubleDoublePoint point = Points.xy.DoubleDoublePoint.of(10.5, 20.7, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double value = point.v(); // 3.14159 * * // Useful for continuous spaces with probability or weight values * Points.xy.DoubleDoublePoint sample = Points.xy.DoubleDoublePoint.of(3.14159, 2.71828, 0.95); * * // Geographic coordinates with temperature * Points.xy.DoubleDoublePoint weather = Points.xy.DoubleDoublePoint.of(40.7128, -74.0060, 22.5); * * // Mathematical calculations * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7); * Points.xy.DoubleDoublePoint vector = Points.xy.DoubleDoublePoint.of(10.5, 20.7, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double v) { return new DoubleDoublePoint(x, y, v); } } /** * Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`double`)
  - `y` (`double`)
  - `v` (`double`)

### Record DoubleObjPoint (com.landawn.abacus.util.Points.xy.DoubleObjPoint)
Represents an immutable two-dimensional point with double-precision floating-point coordinates and a generic object value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> DoubleObjPoint<T>
- **Signature:** `public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v)`
- **Summary:** Creates a new DoubleObjPoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`double`) — the x-coordinate of the point
  - `y` (`double`) — the y-coordinate of the point
  - `v` (`T`) — the object value associated with this point, may be {@code null}
- **Returns:** a new DoubleObjPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record DoubleObjPoint<T>(double x, double y, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a point with double coordinates and a String value * Points.xy.DoubleObjPoint<String> point = Points.xy.DoubleObjPoint.of(10.5, 20.7, "location"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * String value = point.v(); // "location" * * // Geographic coordinates with custom objects * record Place(String name, int population, String country) {} * Place place = new Place("New York", 8000000, "USA"); * Points.xy.DoubleObjPoint<Place> geoPoint = Points.xy.DoubleObjPoint.of(40.7128, -74.0060, place); * * // Continuous space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "humidity", 65); * Points.xy.DoubleObjPoint<Map<String, Object>> sensor = Points.xy.DoubleObjPoint.of(3.14159, 2.71828, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final T v) { return new DoubleObjPoint<>(x, y, v); } } } /** * This class provides three-dimensional coordinate point implementations. * Each point stores x, y, and z coordinates of various primitive types * (byte, int, long, double) to optimize memory usage and performance for specific use cases. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a three-dimensional integer point with value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(10, 20, 30, 100); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * int value = point.v(); // 100 * }</pre> * * @see xy */ @SuppressFBWarnings("NM_CLASS_NAMING_CONVENTION") public static final class xyz { // NOSONAR /** * Instantiates a new xyz. */ private xyz() { // singleton. } /** * Represents an immutable three-dimensional point with byte coordinates and a byte value. * This class is optimized for memory-constrained scenarios where coordinates * and values fit within the byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`double`)
  - `y` (`double`)
  - `v` (`T`)

### Class xyz (com.landawn.abacus.util.Points.xyz)
This class provides three-dimensional coordinate point implementations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Record ByteBytePoint (com.landawn.abacus.util.Points.xyz.ByteBytePoint)
Represents an immutable three-dimensional point with byte coordinates and a byte value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ByteBytePoint
- **Signature:** `public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v)`
- **Summary:** Creates a new ByteBytePoint with the specified x, y, z coordinates and value.
- **Parameters:**
  - `x` (`byte`) — the x-coordinate of the point, must be in the range \[-128, 127\]
  - `y` (`byte`) — the y-coordinate of the point, must be in the range \[-128, 127\]
  - `z` (`byte`) — the z-coordinate of the point, must be in the range \[-128, 127\]
  - `v` (`byte`) — the value associated with this point, must be in the range \[-128, 127\]
- **Returns:** a new ByteBytePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record ByteBytePoint(byte x, byte y, byte z, byte v) { /** * Creates a new ByteBytePoint with the specified x, y, z coordinates and value. * This factory method provides a convenient way to construct three-dimensional points * with byte-range coordinates and values, optimized for maximum memory efficiency. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point at coordinates (10, 20, 30) with value 5 * Points.xyz.ByteBytePoint point = Points.xyz.ByteBytePoint.of((byte) 10, (byte) 20, (byte) 30, (byte) 5); * byte x = point.x(); // 10 * byte y = point.y(); // 20 * byte z = point.z(); // 30 * byte value = point.v(); // 5 * * // Useful for memory-efficient 3D grid representations * Points.xyz.ByteBytePoint voxel = Points.xyz.ByteBytePoint.of((byte) 0, (byte) 0, (byte) 0, (byte) 127); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the value associated with this point, must be in the range [-128, 127] * @return a new ByteBytePoint instance with the specified coordinates and value, never {@code null} */ public static ByteBytePoint of(final byte x, final byte y, final byte z, final byte v) { return new ByteBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and an integer value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`byte`)
  - `y` (`byte`)
  - `z` (`byte`)
  - `v` (`byte`)

### Record ByteIntPoint (com.landawn.abacus.util.Points.xyz.ByteIntPoint)
Represents an immutable three-dimensional point with byte coordinates and an integer value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ByteIntPoint
- **Signature:** `public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v)`
- **Summary:** Creates a new ByteIntPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with small-range 3D coordinates but requiring a full integer range for the associated value, such as counting or indexing in 3D space.
- **Parameters:**
  - `x` (`byte`) — the x-coordinate of the point, must be in the range \[-128, 127\]
  - `y` (`byte`) — the y-coordinate of the point, must be in the range \[-128, 127\]
  - `z` (`byte`) — the z-coordinate of the point, must be in the range \[-128, 127\]
  - `v` (`int`) — the integer value associated with this point
- **Returns:** a new ByteIntPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record ByteIntPoint(byte x, byte y, byte z, int v) { /** * Creates a new ByteIntPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full integer range for the associated value, such as counting or indexing in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and integer value * Points.xyz.ByteIntPoint point = Points.xyz.ByteIntPoint.of((byte) 5, (byte) 10, (byte) 15, 1000); * byte x = point.x(); // 5 * byte y = point.y(); // 10 * byte z = point.z(); // 15 * int value = point.v(); // 1000 * * // Useful for small 3D grids with large counts * Points.xyz.ByteIntPoint voxelCount = Points.xyz.ByteIntPoint.of((byte) 0, (byte) 0, (byte) 0, 1000000); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the integer value associated with this point * @return a new ByteIntPoint instance with the specified coordinates and value, never {@code null} */ public static ByteIntPoint of(final byte x, final byte y, final byte z, final int v) { return new ByteIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a long value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`byte`)
  - `y` (`byte`)
  - `z` (`byte`)
  - `v` (`int`)

### Record ByteLongPoint (com.landawn.abacus.util.Points.xyz.ByteLongPoint)
Represents an immutable three-dimensional point with byte coordinates and a long value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ByteLongPoint
- **Signature:** `public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v)`
- **Summary:** Creates a new ByteLongPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with small-range 3D coordinates but requiring a full long integer range for the associated value, such as timestamps or large identifiers in 3D space.
- **Parameters:**
  - `x` (`byte`) — the x-coordinate of the point, must be in the range \[-128, 127\]
  - `y` (`byte`) — the y-coordinate of the point, must be in the range \[-128, 127\]
  - `z` (`byte`) — the z-coordinate of the point, must be in the range \[-128, 127\]
  - `v` (`long`) — the long value associated with this point
- **Returns:** a new ByteLongPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record ByteLongPoint(byte x, byte y, byte z, long v) { /** * Creates a new ByteLongPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * a full long integer range for the associated value, such as timestamps or large identifiers in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and long value * Points.xyz.ByteLongPoint point = Points.xyz.ByteLongPoint.of((byte) 3, (byte) 7, (byte) 11, 1000000000L); * byte x = point.x(); // 3 * byte y = point.y(); // 7 * byte z = point.z(); // 11 * long value = point.v(); // 1000000000 * * // Useful for small 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.ByteLongPoint voxelTime = Points.xyz.ByteLongPoint.of((byte) 0, (byte) 0, (byte) 0, timestamp); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the long value associated with this point * @return a new ByteLongPoint instance with the specified coordinates and value, never {@code null} */ public static ByteLongPoint of(final byte x, final byte y, final byte z, final long v) { return new ByteLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`byte`)
  - `y` (`byte`)
  - `z` (`byte`)
  - `v` (`long`)

### Record ByteDoublePoint (com.landawn.abacus.util.Points.xyz.ByteDoublePoint)
Represents an immutable three-dimensional point with byte coordinates and a double-precision floating-point value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ByteDoublePoint
- **Signature:** `public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v)`
- **Summary:** Creates a new ByteDoublePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with small-range 3D coordinates but requiring floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space.
- **Parameters:**
  - `x` (`byte`) — the x-coordinate of the point, must be in the range \[-128, 127\]
  - `y` (`byte`) — the y-coordinate of the point, must be in the range \[-128, 127\]
  - `z` (`byte`) — the z-coordinate of the point, must be in the range \[-128, 127\]
  - `v` (`double`) — the double value associated with this point
- **Returns:** a new ByteDoublePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record ByteDoublePoint(byte x, byte y, byte z, double v) { /** * Creates a new ByteDoublePoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * floating-point precision for the associated value, such as densities, probabilities, or physical measurements in 3D space. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and double value * Points.xyz.ByteDoublePoint point = Points.xyz.ByteDoublePoint.of((byte) 2, (byte) 4, (byte) 6, 3.14159); * byte x = point.x(); // 2 * byte y = point.y(); // 4 * byte z = point.z(); // 6 * double value = point.v(); // 3.14159 * * // Useful for small 3D grids with density values * Points.xyz.ByteDoublePoint voxelDensity = Points.xyz.ByteDoublePoint.of((byte) 1, (byte) 1, (byte) 1, 0.85); * }</pre> * * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the double value associated with this point * @return a new ByteDoublePoint instance with the specified coordinates and value, never {@code null} */ public static ByteDoublePoint of(final byte x, final byte y, final byte z, final double v) { return new ByteDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with byte coordinates and a generic object value. * This class is useful when coordinates are constrained to byte range (-128 to 127) * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`byte`)
  - `y` (`byte`)
  - `z` (`byte`)
  - `v` (`double`)

### Record ByteObjPoint (com.landawn.abacus.util.Points.xyz.ByteObjPoint)
Represents an immutable three-dimensional point with byte coordinates and a generic object value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ByteObjPoint<T>
- **Signature:** `public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v)`
- **Summary:** Creates a new ByteObjPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with small-range 3D coordinates but requiring any object type for the associated value, providing maximum flexibility for storing complex data structures at specific 3D positions.
- **Parameters:**
  - `x` (`byte`) — the x-coordinate of the point, must be in the range \[-128, 127\]
  - `y` (`byte`) — the y-coordinate of the point, must be in the range \[-128, 127\]
  - `z` (`byte`) — the z-coordinate of the point, must be in the range \[-128, 127\]
  - `v` (`T`) — the object value associated with this point, may be {@code null}
- **Returns:** a new ByteObjPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record ByteObjPoint<T>(byte x, byte y, byte z, T v) { /** * Creates a new ByteObjPoint with the specified coordinates and value. * This factory method is ideal when working with small-range 3D coordinates but requiring * any object type for the associated value, providing maximum flexibility for storing * complex data structures at specific 3D positions. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with byte coordinates and a String value * Points.xyz.ByteObjPoint<String> point = Points.xyz.ByteObjPoint.of((byte) 1, (byte) 2, (byte) 3, "voxel"); * byte x = point.x(); // 1 * byte y = point.y(); // 2 * byte z = point.z(); // 3 * String value = point.v(); // "voxel" * * // Useful for small 3D grids with complex metadata * record Material(String type, double density) {} * Material material = new Material("iron", 7.87); * Points.xyz.ByteObjPoint<Material> voxelMaterial = Points.xyz.ByteObjPoint.of((byte) 0, (byte) 0, (byte) 0, material); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point, must be in the range [-128, 127] * @param y the y-coordinate of the point, must be in the range [-128, 127] * @param z the z-coordinate of the point, must be in the range [-128, 127] * @param v the object value associated with this point, may be {@code null} * @return a new ByteObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> ByteObjPoint<T> of(final byte x, final byte y, final byte z, final T v) { return new ByteObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a byte value. * This class is useful when coordinates require the full integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`byte`)
  - `y` (`byte`)
  - `z` (`byte`)
  - `v` (`T`)

### Record IntBytePoint (com.landawn.abacus.util.Points.xyz.IntBytePoint)
Represents an immutable three-dimensional point with integer coordinates and a byte value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> IntBytePoint
- **Signature:** `public static IntBytePoint of(final int x, final int y, final int z, final byte v)`
- **Summary:** Creates a new IntBytePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with standard integer 3D coordinates but the associated value fits within a byte range, providing memory efficiency for the value component.
- **Parameters:**
  - `x` (`int`) — the x-coordinate of the point
  - `y` (`int`) — the y-coordinate of the point
  - `z` (`int`) — the z-coordinate of the point
  - `v` (`byte`) — the byte value associated with this point, must be in the range \[-128, 127\]
- **Returns:** a new IntBytePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record IntBytePoint(int x, int y, int z, byte v) { /** * Creates a new IntBytePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but the * associated value fits within a byte range, providing memory efficiency for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and byte value * Points.xyz.IntBytePoint point = Points.xyz.IntBytePoint.of(100, 200, 300, (byte) 10); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * byte value = point.v(); // 10 * * // Useful for large 3D grids with small enumeration values * Points.xyz.IntBytePoint voxelType = Points.xyz.IntBytePoint.of(1000, 2000, 3000, (byte) 3); // type = 3 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new IntBytePoint instance with the specified coordinates and value, never {@code null} */ public static IntBytePoint of(final int x, final int y, final int z, final byte v) { return new IntBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and an integer value. * This class is the most commonly used point type for general-purpose integer-based * coordinate systems and grid operations. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`int`)
  - `y` (`int`)
  - `z` (`int`)
  - `v` (`byte`)

### Record IntIntPoint (com.landawn.abacus.util.Points.xyz.IntIntPoint)
Represents an immutable three-dimensional point with integer coordinates and an integer value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> IntIntPoint
- **Signature:** `public static IntIntPoint of(final int x, final int y, final int z, final int v)`
- **Summary:** Creates a new IntIntPoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`int`) — the x-coordinate of the point
  - `y` (`int`) — the y-coordinate of the point
  - `z` (`int`) — the z-coordinate of the point
  - `v` (`int`) — the integer value associated with this point
- **Returns:** a new IntIntPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record IntIntPoint(int x, int y, int z, int v) { /** * Creates a new IntIntPoint with the specified coordinates and value. * This is the most commonly used 3D point type for general-purpose integer-based * coordinate systems, providing a balanced approach with full integer range for * all three coordinates and the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and integer value * Points.xyz.IntIntPoint point = Points.xyz.IntIntPoint.of(100, 200, 300, 400); * int x = point.x(); // 100 * int y = point.y(); // 200 * int z = point.z(); // 300 * int value = point.v(); // 400 * * // Common use case: 3D voxel grids with counts * Points.xyz.IntIntPoint voxel = Points.xyz.IntIntPoint.of(10, 20, 30, 5000); * * // 3D pathfinding with cost values * Points.xyz.IntIntPoint pathNode = Points.xyz.IntIntPoint.of(5, 8, 12, 25); // cost = 25 * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new IntIntPoint instance with the specified coordinates and value, never {@code null} */ public static IntIntPoint of(final int x, final int y, final int z, final int v) { return new IntIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a long value. * This class is useful when coordinates fit within the integer range * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`int`)
  - `y` (`int`)
  - `z` (`int`)
  - `v` (`int`)

### Record IntLongPoint (com.landawn.abacus.util.Points.xyz.IntLongPoint)
Represents an immutable three-dimensional point with integer coordinates and a long value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> IntLongPoint
- **Signature:** `public static IntLongPoint of(final int x, final int y, final int z, final long v)`
- **Summary:** Creates a new IntLongPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with standard integer 3D coordinates but requiring a long value for timestamps, large counts, or identifiers that exceed the integer range.
- **Parameters:**
  - `x` (`int`) — the x-coordinate of the point
  - `y` (`int`) — the y-coordinate of the point
  - `z` (`int`) — the z-coordinate of the point
  - `v` (`long`) — the long value associated with this point
- **Returns:** a new IntLongPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record IntLongPoint(int x, int y, int z, long v) { /** * Creates a new IntLongPoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D coordinates but requiring * a long value for timestamps, large counts, or identifiers that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and long value * Points.xyz.IntLongPoint point = Points.xyz.IntLongPoint.of(50, 75, 100, 10000000000L); * int x = point.x(); // 50 * int y = point.y(); // 75 * int z = point.z(); // 100 * long value = point.v(); // 10000000000 * * // Useful for 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.IntLongPoint voxelTime = Points.xyz.IntLongPoint.of(10, 20, 30, timestamp); * * // Track large identifiers in a 3D grid * Points.xyz.IntLongPoint voxelId = Points.xyz.IntLongPoint.of(5, 8, 12, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new IntLongPoint instance with the specified coordinates and value, never {@code null} */ public static IntLongPoint of(final int x, final int y, final int z, final long v) { return new IntLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value. * This class is useful when coordinates fit within the integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`int`)
  - `y` (`int`)
  - `z` (`int`)
  - `v` (`long`)

### Record IntDoublePoint (com.landawn.abacus.util.Points.xyz.IntDoublePoint)
Represents an immutable three-dimensional point with integer coordinates and a double-precision floating-point value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> IntDoublePoint
- **Signature:** `public static IntDoublePoint of(final int x, final int y, final int z, final double v)`
- **Summary:** Creates a new IntDoublePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with standard integer 3D grid coordinates but requiring floating-point precision for the associated value, such as densities, distances, or probabilities.
- **Parameters:**
  - `x` (`int`) — the x-coordinate of the point
  - `y` (`int`) — the y-coordinate of the point
  - `z` (`int`) — the z-coordinate of the point
  - `v` (`double`) — the double value associated with this point
- **Returns:** a new IntDoublePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record IntDoublePoint(int x, int y, int z, double v) { /** * Creates a new IntDoublePoint with the specified coordinates and value. * This factory method is ideal when working with standard integer 3D grid coordinates but requiring * floating-point precision for the associated value, such as densities, distances, or probabilities. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and double value * Points.xyz.IntDoublePoint point = Points.xyz.IntDoublePoint.of(10, 20, 30, 3.14159); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * double value = point.v(); // 3.14159 * * // Useful for 3D grids with density values * Points.xyz.IntDoublePoint voxelDensity = Points.xyz.IntDoublePoint.of(5, 8, 12, 0.85); * * // 3D distance-based calculations * double distance = Math.sqrt(10 * 10 + 20 * 20 + 30 * 30); * Points.xyz.IntDoublePoint nodeDistance = Points.xyz.IntDoublePoint.of(10, 20, 30, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new IntDoublePoint instance with the specified coordinates and value, never {@code null} */ public static IntDoublePoint of(final int x, final int y, final int z, final double v) { return new IntDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with integer coordinates and a generic object value. * This class is useful when coordinates fit within the integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`int`)
  - `y` (`int`)
  - `z` (`int`)
  - `v` (`double`)

### Record IntObjPoint (com.landawn.abacus.util.Points.xyz.IntObjPoint)
Represents an immutable three-dimensional point with integer coordinates and a generic object value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> IntObjPoint<T>
- **Signature:** `public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v)`
- **Summary:** Creates a new IntObjPoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`int`) — the x-coordinate of the point
  - `y` (`int`) — the y-coordinate of the point
  - `z` (`int`) — the z-coordinate of the point
  - `v` (`T`) — the object value associated with this point, may be {@code null}
- **Returns:** a new IntObjPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record IntObjPoint<T>(int x, int y, int z, T v) { /** * Creates a new IntObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using standard integer 3D coordinates, making it suitable for complex voxel-based data structures. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with integer coordinates and a String value * Points.xyz.IntObjPoint<String> point = Points.xyz.IntObjPoint.of(10, 20, 30, "block"); * int x = point.x(); // 10 * int y = point.y(); // 20 * int z = point.z(); // 30 * String value = point.v(); // "block" * * // 3D voxel grid with custom objects * record Voxel(String material, double density, boolean solid) {} * Voxel voxel = new Voxel("stone", 2.5, true); * Points.xyz.IntObjPoint<Voxel> gridVoxel = Points.xyz.IntObjPoint.of(5, 8, 12, voxel); * * // Store collections at 3D positions * List<String> items = List.of("chest", "gold"); * Points.xyz.IntObjPoint<List<String>> voxelItems = Points.xyz.IntObjPoint.of(3, 7, 10, items); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new IntObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> IntObjPoint<T> of(final int x, final int y, final int z, final T v) { return new IntObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a byte value. * This class is useful when coordinates require the full long integer range * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`int`)
  - `y` (`int`)
  - `z` (`int`)
  - `v` (`T`)

### Record LongBytePoint (com.landawn.abacus.util.Points.xyz.LongBytePoint)
Represents an immutable three-dimensional point with long coordinates and a byte value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> LongBytePoint
- **Signature:** `public static LongBytePoint of(final long x, final long y, final long z, final byte v)`
- **Summary:** Creates a new LongBytePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with very large 3D coordinate spaces requiring long values but the associated value fits within a byte range, optimizing memory for the value component.
- **Parameters:**
  - `x` (`long`) — the x-coordinate of the point
  - `y` (`long`) — the y-coordinate of the point
  - `z` (`long`) — the z-coordinate of the point
  - `v` (`byte`) — the byte value associated with this point, must be in the range \[-128, 127\]
- **Returns:** a new LongBytePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record LongBytePoint(long x, long y, long z, byte v) { /** * Creates a new LongBytePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and byte value * Points.xyz.LongBytePoint point = Points.xyz.LongBytePoint.of(1000000L, 2000000L, 3000000L, (byte) 5); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * byte value = point.v(); // 5 * * // Useful for very large 3D grids with small enumeration values * Points.xyz.LongBytePoint voxelType = Points.xyz.LongBytePoint.of(999999999L, 888888888L, 777777777L, (byte) 2); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new LongBytePoint instance with the specified coordinates and value, never {@code null} */ public static LongBytePoint of(final long x, final long y, final long z, final byte v) { return new LongBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and an integer value. * This class is useful when coordinates require the full long integer range * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`long`)
  - `y` (`long`)
  - `z` (`long`)
  - `v` (`byte`)

### Record LongIntPoint (com.landawn.abacus.util.Points.xyz.LongIntPoint)
Represents an immutable three-dimensional point with long coordinates and an integer value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> LongIntPoint
- **Signature:** `public static LongIntPoint of(final long x, final long y, final long z, final int v)`
- **Summary:** Creates a new LongIntPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with very large 3D coordinate spaces requiring long values but the associated value fits within the integer range.
- **Parameters:**
  - `x` (`long`) — the x-coordinate of the point
  - `y` (`long`) — the y-coordinate of the point
  - `z` (`long`) — the z-coordinate of the point
  - `v` (`int`) — the integer value associated with this point
- **Returns:** a new LongIntPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record LongIntPoint(long x, long y, long z, int v) { /** * Creates a new LongIntPoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but the associated value fits within the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and integer value * Points.xyz.LongIntPoint point = Points.xyz.LongIntPoint.of(1000000L, 2000000L, 3000000L, 500); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * int value = point.v(); // 500 * * // Useful for very large 3D grids with counts or indices * Points.xyz.LongIntPoint voxelCount = Points.xyz.LongIntPoint.of(999999999L, 888888888L, 777777777L, 1000000); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new LongIntPoint instance with the specified coordinates and value, never {@code null} */ public static LongIntPoint of(final long x, final long y, final long z, final int v) { return new LongIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a long value. * This class provides full long integer range for both coordinates and associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`long`)
  - `y` (`long`)
  - `z` (`long`)
  - `v` (`int`)

### Record LongLongPoint (com.landawn.abacus.util.Points.xyz.LongLongPoint)
Represents an immutable three-dimensional point with long coordinates and a long value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> LongLongPoint
- **Signature:** `public static LongLongPoint of(final long x, final long y, final long z, final long v)`
- **Summary:** Creates a new LongLongPoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`long`) — the x-coordinate of the point
  - `y` (`long`) — the y-coordinate of the point
  - `z` (`long`) — the z-coordinate of the point
  - `v` (`long`) — the long value associated with this point
- **Returns:** a new LongLongPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record LongLongPoint(long x, long y, long z, long v) { /** * Creates a new LongLongPoint with the specified coordinates and value. * This factory method provides the maximum integer range for both 3D coordinates and the * associated value, suitable for very large coordinate spaces with large identifiers or timestamps. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and long value * Points.xyz.LongLongPoint point = Points.xyz.LongLongPoint.of(1000000L, 2000000L, 3000000L, 4000000000L); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * long value = point.v(); // 4000000000 * * // Useful for very large 3D grids with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.LongLongPoint voxelTime = Points.xyz.LongLongPoint.of(999999999L, 888888888L, 777777777L, timestamp); * * // Large 3D coordinate space with large identifiers * Points.xyz.LongLongPoint voxelId = Points.xyz.LongLongPoint.of(1L << 40, 1L << 41, 1L << 42, 1L << 50); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new LongLongPoint instance with the specified coordinates and value, never {@code null} */ public static LongLongPoint of(final long x, final long y, final long z, final long v) { return new LongLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value. * This class is useful when coordinates require the full long integer range * but the associated value requires floating-point precision. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`long`)
  - `y` (`long`)
  - `z` (`long`)
  - `v` (`long`)

### Record LongDoublePoint (com.landawn.abacus.util.Points.xyz.LongDoublePoint)
Represents an immutable three-dimensional point with long coordinates and a double-precision floating-point value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> LongDoublePoint
- **Signature:** `public static LongDoublePoint of(final long x, final long y, final long z, final double v)`
- **Summary:** Creates a new LongDoublePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with very large 3D coordinate spaces requiring long values but needing floating-point precision for the associated value.
- **Parameters:**
  - `x` (`long`) — the x-coordinate of the point
  - `y` (`long`) — the y-coordinate of the point
  - `z` (`long`) — the z-coordinate of the point
  - `v` (`double`) — the double value associated with this point
- **Returns:** a new LongDoublePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record LongDoublePoint(long x, long y, long z, double v) { /** * Creates a new LongDoublePoint with the specified coordinates and value. * This factory method is ideal when working with very large 3D coordinate spaces requiring * long values but needing floating-point precision for the associated value. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and double value * Points.xyz.LongDoublePoint point = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, 3.14159); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * double value = point.v(); // 3.14159 * * // Useful for very large 3D grids with density or probability values * Points.xyz.LongDoublePoint voxelDensity = Points.xyz.LongDoublePoint.of(999999999L, 888888888L, 777777777L, 0.85); * * // Large 3D coordinate space with distance calculations * double distance = Math.sqrt(1000000.0 * 1000000.0 + 2000000.0 * 2000000.0 + 3000000.0 * 3000000.0); * Points.xyz.LongDoublePoint voxelDistance = Points.xyz.LongDoublePoint.of(1000000L, 2000000L, 3000000L, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new LongDoublePoint instance with the specified coordinates and value, never {@code null} */ public static LongDoublePoint of(final long x, final long y, final long z, final double v) { return new LongDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with long coordinates and a generic object value. * This class is useful when coordinates require the full long integer range * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`long`)
  - `y` (`long`)
  - `z` (`long`)
  - `v` (`double`)

### Record LongObjPoint (com.landawn.abacus.util.Points.xyz.LongObjPoint)
Represents an immutable three-dimensional point with long coordinates and a generic object value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> LongObjPoint<T>
- **Signature:** `public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v)`
- **Summary:** Creates a new LongObjPoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`long`) — the x-coordinate of the point
  - `y` (`long`) — the y-coordinate of the point
  - `z` (`long`) — the z-coordinate of the point
  - `v` (`T`) — the object value associated with this point, may be {@code null}
- **Returns:** a new LongObjPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record LongObjPoint<T>(long x, long y, long z, T v) { /** * Creates a new LongObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using long integer 3D coordinates, suitable for very large coordinate spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with long coordinates and a String value * Points.xyz.LongObjPoint<String> point = Points.xyz.LongObjPoint.of(1000000L, 2000000L, 3000000L, "region"); * long x = point.x(); // 1000000 * long y = point.y(); // 2000000 * long z = point.z(); // 3000000 * String value = point.v(); // "region" * * // Very large 3D grid with custom objects * record Chunk(String biome, int height, boolean generated) {} * Chunk chunk = new Chunk("plains", 64, true); * Points.xyz.LongObjPoint<Chunk> gridChunk = Points.xyz.LongObjPoint.of(999999999L, 888888888L, 777777777L, chunk); * * // 3D spatial indexing with metadata * Map<String, Object> metadata = Map.of("type", "structure", "volume", 1000); * Points.xyz.LongObjPoint<Map<String, Object>> voxel = Points.xyz.LongObjPoint.of(1L << 40, 1L << 41, 1L << 42, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new LongObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> LongObjPoint<T> of(final long x, final long y, final long z, final T v) { return new LongObjPoint<>(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value. * This class is useful when coordinates require floating-point precision * but the associated value is constrained to byte range (-128 to 127). * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`long`)
  - `y` (`long`)
  - `z` (`long`)
  - `v` (`T`)

### Record DoubleBytePoint (com.landawn.abacus.util.Points.xyz.DoubleBytePoint)
Represents an immutable three-dimensional point with double-precision floating-point coordinates and a byte value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> DoubleBytePoint
- **Signature:** `public static DoubleBytePoint of(final double x, final double y, final double z, final byte v)`
- **Summary:** Creates a new DoubleBytePoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with floating-point 3D coordinate spaces but the associated value fits within a byte range, optimizing memory for the value component.
- **Parameters:**
  - `x` (`double`) — the x-coordinate of the point
  - `y` (`double`) — the y-coordinate of the point
  - `z` (`double`) — the z-coordinate of the point
  - `v` (`byte`) — the byte value associated with this point, must be in the range \[-128, 127\]
- **Returns:** a new DoubleBytePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record DoubleBytePoint(double x, double y, double z, byte v) { /** * Creates a new DoubleBytePoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within a byte range, optimizing memory for the value component. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and byte value * Points.xyz.DoubleBytePoint point = Points.xyz.DoubleBytePoint.of(10.5, 20.7, 30.9, (byte) 3); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * byte value = point.v(); // 3 * * // Useful for continuous 3D coordinate spaces with small enumeration values * Points.xyz.DoubleBytePoint region = Points.xyz.DoubleBytePoint.of(3.14159, 2.71828, 1.41421, (byte) 1); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the byte value associated with this point, must be in the range [-128, 127] * @return a new DoubleBytePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleBytePoint of(final double x, final double y, final double z, final byte v) { return new DoubleBytePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value. * This class is useful when coordinates require floating-point precision * but the associated value fits within the integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`double`)
  - `y` (`double`)
  - `z` (`double`)
  - `v` (`byte`)

### Record DoubleIntPoint (com.landawn.abacus.util.Points.xyz.DoubleIntPoint)
Represents an immutable three-dimensional point with double-precision floating-point coordinates and an integer value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> DoubleIntPoint
- **Signature:** `public static DoubleIntPoint of(final double x, final double y, final double z, final int v)`
- **Summary:** Creates a new DoubleIntPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with floating-point 3D coordinate spaces but the associated value fits within the integer range, such as counts or indices in continuous 3D spaces.
- **Parameters:**
  - `x` (`double`) — the x-coordinate of the point
  - `y` (`double`) — the y-coordinate of the point
  - `z` (`double`) — the z-coordinate of the point
  - `v` (`int`) — the integer value associated with this point
- **Returns:** a new DoubleIntPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record DoubleIntPoint(double x, double y, double z, int v) { /** * Creates a new DoubleIntPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces but the * associated value fits within the integer range, such as counts or indices in continuous 3D spaces. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and integer value * Points.xyz.DoubleIntPoint point = Points.xyz.DoubleIntPoint.of(10.5, 20.7, 30.9, 100); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * int value = point.v(); // 100 * * // Useful for continuous 3D coordinate spaces with counts * Points.xyz.DoubleIntPoint sample = Points.xyz.DoubleIntPoint.of(3.14159, 2.71828, 1.41421, 1000); * * // 3D physical coordinates with count values * Points.xyz.DoubleIntPoint position = Points.xyz.DoubleIntPoint.of(1.5, 2.7, 3.9, 42); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the integer value associated with this point * @return a new DoubleIntPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleIntPoint of(final double x, final double y, final double z, final int v) { return new DoubleIntPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value. * This class is useful when coordinates require floating-point precision * but the associated value requires the full long integer range. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`double`)
  - `y` (`double`)
  - `z` (`double`)
  - `v` (`int`)

### Record DoubleLongPoint (com.landawn.abacus.util.Points.xyz.DoubleLongPoint)
Represents an immutable three-dimensional point with double-precision floating-point coordinates and a long value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> DoubleLongPoint
- **Signature:** `public static DoubleLongPoint of(final double x, final double y, final double z, final long v)`
- **Summary:** Creates a new DoubleLongPoint with the specified coordinates and value.
- **Contract:**
  - This factory method is ideal when working with floating-point 3D coordinate spaces and requiring long values for timestamps, large identifiers, or counts that exceed the integer range.
- **Parameters:**
  - `x` (`double`) — the x-coordinate of the point
  - `y` (`double`) — the y-coordinate of the point
  - `z` (`double`) — the z-coordinate of the point
  - `v` (`long`) — the long value associated with this point
- **Returns:** a new DoubleLongPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record DoubleLongPoint(double x, double y, double z, long v) { /** * Creates a new DoubleLongPoint with the specified coordinates and value. * This factory method is ideal when working with floating-point 3D coordinate spaces and requiring * long values for timestamps, large identifiers, or counts that exceed the integer range. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and long value * Points.xyz.DoubleLongPoint point = Points.xyz.DoubleLongPoint.of(10.5, 20.7, 30.9, 1000000000L); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * long value = point.v(); // 1000000000 * * // Useful for continuous 3D coordinate spaces with timestamps * long timestamp = System.currentTimeMillis(); * Points.xyz.DoubleLongPoint sample = Points.xyz.DoubleLongPoint.of(3.14159, 2.71828, 1.41421, timestamp); * * // 3D physical coordinates with large identifiers * Points.xyz.DoubleLongPoint position = Points.xyz.DoubleLongPoint.of(1.5, 2.7, 3.9, 9876543210L); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the long value associated with this point * @return a new DoubleLongPoint instance with the specified coordinates and value, never {@code null} */ public static DoubleLongPoint of(final double x, final double y, final double z, final long v) { return new DoubleLongPoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and value. * This class provides full double-precision floating-point support for both coordinates and the associated value. * * <p>All instances are immutable and thread-safe.</p> * * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`double`)
  - `y` (`double`)
  - `z` (`double`)
  - `v` (`long`)

### Record DoubleDoublePoint (com.landawn.abacus.util.Points.xyz.DoubleDoublePoint)
Represents an immutable three-dimensional point with double-precision floating-point coordinates and value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> DoubleDoublePoint
- **Signature:** `public static DoubleDoublePoint of(final double x, final double y, final double z, final double v)`
- **Summary:** Creates a new DoubleDoublePoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`double`) — the x-coordinate of the point
  - `y` (`double`) — the y-coordinate of the point
  - `z` (`double`) — the z-coordinate of the point
  - `v` (`double`) — the double value associated with this point
- **Returns:** a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record DoubleDoublePoint(double x, double y, double z, double v) { /** * Creates a new DoubleDoublePoint with the specified coordinates and value. * This factory method provides full double-precision floating-point support for both 3D coordinates * and the associated value, ideal for continuous mathematical, physical, and scientific 3D applications. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and double value * Points.xyz.DoubleDoublePoint point = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, 3.14159); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * double value = point.v(); // 3.14159 * * // Useful for continuous 3D spaces with density or probability values * Points.xyz.DoubleDoublePoint sample = Points.xyz.DoubleDoublePoint.of(3.14159, 2.71828, 1.41421, 0.95); * * // 3D physical coordinates with measurements * Points.xyz.DoubleDoublePoint position = Points.xyz.DoubleDoublePoint.of(1.5, 2.7, 3.9, 22.5); * * // Mathematical calculations in 3D space * double distance = Math.sqrt(10.5 * 10.5 + 20.7 * 20.7 + 30.9 * 30.9); * Points.xyz.DoubleDoublePoint vector = Points.xyz.DoubleDoublePoint.of(10.5, 20.7, 30.9, distance); * }</pre> * * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the double value associated with this point * @return a new DoubleDoublePoint instance with the specified coordinates and value, never {@code null} */ public static DoubleDoublePoint of(final double x, final double y, final double z, final double v) { return new DoubleDoublePoint(x, y, z, v); } } /** * Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value. * This class is useful when coordinates require floating-point precision * but the associated value can be any object type. * * <p>All instances are immutable and thread-safe.</p> * * @param <T> the type of the value object associated with this point * @param x the x-coordinate of this point * @param y the y-coordinate of this point * @param z the z-coordinate of this point * @param v the value associated with this point */ public record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`double`)
  - `y` (`double`)
  - `z` (`double`)
  - `v` (`double`)

### Record DoubleObjPoint (com.landawn.abacus.util.Points.xyz.DoubleObjPoint)
Represents an immutable three-dimensional point with double-precision floating-point coordinates and a generic object value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> DoubleObjPoint<T>
- **Signature:** `public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v)`
- **Summary:** Creates a new DoubleObjPoint with the specified coordinates and value.
- **Parameters:**
  - `x` (`double`) — the x-coordinate of the point
  - `y` (`double`) — the y-coordinate of the point
  - `z` (`double`) — the z-coordinate of the point
  - `v` (`T`) — the object value associated with this point, may be {@code null}
- **Returns:** a new DoubleObjPoint instance with the specified coordinates and value, never {@code null}

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record DoubleObjPoint<T>(double x, double y, double z, T v) { /** * Creates a new DoubleObjPoint with the specified coordinates and value. * This factory method provides maximum flexibility by allowing any object type as the value * while using double-precision floating-point 3D coordinates, suitable for continuous spaces with complex data. * * <p><b>Usage Examples:</b></p> * <pre>{@code * // Create a 3D point with double coordinates and a String value * Points.xyz.DoubleObjPoint<String> point = Points.xyz.DoubleObjPoint.of(10.5, 20.7, 30.9, "marker"); * double x = point.x(); // 10.5 * double y = point.y(); // 20.7 * double z = point.z(); // 30.9 * String value = point.v(); // "marker" * * // 3D physical space with custom objects * record Particle(String type, double mass, double charge) {} * Particle particle = new Particle("electron", 9.109e-31, -1.602e-19); * Points.xyz.DoubleObjPoint<Particle> position = Points.xyz.DoubleObjPoint.of(1.5, 2.7, 3.9, particle); * * // Continuous 3D space with metadata * Map<String, Object> metadata = Map.of("temperature", 22.5, "pressure", 101.3, "humidity", 65); * Points.xyz.DoubleObjPoint<Map<String, Object>> sensor = Points.xyz.DoubleObjPoint.of(3.14159, 2.71828, 1.41421, metadata); * }</pre> * * @param <T> the type of the value associated with this point * @param x the x-coordinate of the point * @param y the y-coordinate of the point * @param z the z-coordinate of the point * @param v the object value associated with this point, may be {@code null} * @return a new DoubleObjPoint instance with the specified coordinates and value, never {@code null} */ public static <T> DoubleObjPoint<T> of(final double x, final double y, final double z, final T v) { return new DoubleObjPoint<>(x, y, z, v); } } } }`
- **Parameters:**
  - `x` (`double`)
  - `y` (`double`)
  - `z` (`double`)
  - `v` (`T`)

### Class ShortMatrix (com.landawn.abacus.util.ShortMatrix)
A matrix implementation for short primitive values, providing efficient storage and operations for two-dimensional short arrays.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### empty(...) -> ShortMatrix
- **Signature:** `public static ShortMatrix empty()`
- **Summary:** Creates an empty matrix with zero rows and zero columns.
- **Parameters:**
  - (none)
- **Returns:** an empty short matrix
##### of(...) -> ShortMatrix
- **Signature:** `public static ShortMatrix of(final short[]... a)`
- **Summary:** Creates a ShortMatrix from a two-dimensional short array.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional short array to create the matrix from, or null/empty for an empty matrix
- **Returns:** a new ShortMatrix containing the provided data, or an empty ShortMatrix if input is null or empty
##### random(...) -> ShortMatrix
- **Signature:** `public static ShortMatrix random(final int size)`
- **Summary:** Creates a new 1xsize matrix filled with random short values.
- **Parameters:**
  - `size` (`int`) — the number of columns in the new matrix
- **Returns:** a new ShortMatrix of dimensions 1 x size filled with random values
- **Signature:** `public static ShortMatrix random(final int rowCount, final int columnCount)`
- **Summary:** Creates a new matrix of the specified dimensions filled with random short values.
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
- **Returns:** a new ShortMatrix of dimensions rowCount x columnCount filled with random values
##### repeat(...) -> ShortMatrix
- **Signature:** `public static ShortMatrix repeat(final int rowCount, final int columnCount, final short element)`
- **Summary:** Creates a new matrix of the specified dimensions where every element is the provided {@code element} .
- **Parameters:**
  - `rowCount` (`int`) — the number of rows in the new matrix
  - `columnCount` (`int`) — the number of columns in the new matrix
  - `element` (`short`) — the short value to fill the matrix with
- **Returns:** a new ShortMatrix of dimensions rowCount x columnCount filled with the specified element
##### range(...) -> ShortMatrix
- **Signature:** `public static ShortMatrix range(final short startInclusive, final short endExclusive)`
- **Summary:** Creates a 1-row ShortMatrix with values from startInclusive to endExclusive.
- **Contract:**
  - If {@code startInclusive >= endExclusive} , an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`short`) — the starting value (inclusive)
  - `endExclusive` (`short`) — the ending value (exclusive)
- **Returns:** a new 1×n ShortMatrix where n = max(0, endExclusive - startInclusive)
- **Signature:** `public static ShortMatrix range(final short startInclusive, final short endExclusive, final short by)`
- **Summary:** Creates a 1-row ShortMatrix with values from startInclusive to endExclusive with the specified step.
- **Contract:**
  - If the step would not reach endExclusive from startInclusive, an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`short`) — the starting value (inclusive)
  - `endExclusive` (`short`) — the ending value (exclusive)
  - `by` (`short`) — the step size (must not be zero; can be positive or negative)
- **Returns:** a new 1×n ShortMatrix with values incremented by the step size
##### rangeClosed(...) -> ShortMatrix
- **Signature:** `public static ShortMatrix rangeClosed(final short startInclusive, final short endInclusive)`
- **Summary:** Creates a 1-row ShortMatrix with values from startInclusive to endInclusive.
- **Contract:**
  - If {@code startInclusive > endInclusive} , an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`short`) — the starting value (inclusive)
  - `endInclusive` (`short`) — the ending value (inclusive)
- **Returns:** a new 1×n ShortMatrix where n = max(0, endInclusive - startInclusive + 1)
- **Signature:** `public static ShortMatrix rangeClosed(final short startInclusive, final short endInclusive, final short by)`
- **Summary:** Creates a 1-row ShortMatrix with values from startInclusive to endInclusive with the specified step.
- **Contract:**
  - The end value is included only if it is reachable by stepping from start.
  - If the step would not reach endInclusive from startInclusive, an empty matrix is returned.
- **Parameters:**
  - `startInclusive` (`short`) — the starting value (inclusive)
  - `endInclusive` (`short`) — the ending value (inclusive, if reachable by stepping)
  - `by` (`short`) — the step size (must not be zero; can be positive or negative)
- **Returns:** a new 1×n ShortMatrix with values incremented by the step size
##### diagonalLU2RD(...) -> ShortMatrix
- **Signature:** `public static ShortMatrix diagonalLU2RD(final short[] leftUp2RightDownDiagonal)`
- **Summary:** Creates a square matrix from the specified main diagonal elements (left-upper to right-down).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`short[]`) — the array of main diagonal elements (from top-left to bottom-right)
- **Returns:** a square n×n matrix with the specified main diagonal, where n is the array length
##### diagonalRU2LD(...) -> ShortMatrix
- **Signature:** `public static ShortMatrix diagonalRU2LD(final short[] rightUp2LeftDownDiagonal)`
- **Summary:** Creates a square matrix from the specified anti-diagonal elements (right-upper to left-down).
- **Parameters:**
  - `rightUp2LeftDownDiagonal` (`short[]`) — the array of anti-diagonal elements (from top-right to bottom-left)
- **Returns:** a square n×n matrix with the specified anti-diagonal, where n is the array length
##### diagonal(...) -> ShortMatrix
- **Signature:** `public static ShortMatrix diagonal(final short[] leftUp2RightDownDiagonal, final short[] rightUp2LeftDownDiagonal) throws IllegalArgumentException`
- **Summary:** Creates a square matrix from the specified main diagonal and anti-diagonal elements.
- **Contract:**
  - If both arrays are provided, they must have the same length.
  - The resulting matrix has dimensions n×n where n is the length of the non-null/non-empty array (or the maximum length if both are provided).
- **Parameters:**
  - `leftUp2RightDownDiagonal` (`short[]`) — the array of main diagonal elements (can be null or empty)
  - `rightUp2LeftDownDiagonal` (`short[]`) — the array of anti-diagonal elements (can be null or empty)
- **Returns:** a square matrix with the specified diagonals, or an empty matrix if both inputs are null or empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — if both arrays are non-empty and have different lengths
##### unbox(...) -> ShortMatrix
- **Signature:** `public static ShortMatrix unbox(final Matrix<Short> matrix)`
- **Summary:** Converts a boxed {@code Matrix<Short>} to a primitive {@code ShortMatrix} .
- **Contract:**
  - This is particularly beneficial when working with large matrices, as primitive arrays have less memory overhead and better cache locality than arrays of wrapper objects.
- **Parameters:**
  - `matrix` (`Matrix<Short>`) — the boxed Short matrix to convert
- **Returns:** a new ShortMatrix with unboxed primitive values

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public ShortMatrix(final short[][] a)`
- **Summary:** Constructs a ShortMatrix from a two-dimensional short array.
- **Contract:**
  - If the input array is null, an empty matrix (0x0) is created.
- **Parameters:**
  - `a` (`short[][]`) — the two-dimensional short array to wrap as a matrix. Can be null.
##### componentType(...) -> Class
- **Signature:** `@SuppressWarnings("rawtypes") @Override public Class componentType()`
- **Summary:** Returns the component type of the matrix elements.
- **Parameters:**
  - (none)
- **Returns:** {@code short.class} , the component type of the matrix elements
##### get(...) -> short
- **Signature:** `public short get(final int i, final int j)`
- **Summary:** Returns the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** the element at position (rowIndex, columnIndex)
- **Signature:** `public short get(final Point point)`
- **Summary:** Returns the element at the specified point.
- **Parameters:**
  - `point` (`Point`) — the point containing row and column indices (must not be null)
- **Returns:** the short element at the specified point
- **See also:** #get(int, int)
##### set(...) -> void
- **Signature:** `public void set(final int i, final int j, final short val)`
- **Summary:** Sets the element at the specified row and column indices.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
  - `val` (`short`) — the value to set
- **Signature:** `public void set(final Point point, final short val)`
- **Summary:** Sets the element at the specified point to the given value.
- **Parameters:**
  - `point` (`Point`) — the point containing row and column indices (must not be null)
  - `val` (`short`) — the new short value to set at the specified point
- **See also:** #set(int, int, short)
##### upOf(...) -> OptionalShort
- **Signature:** `public OptionalShort upOf(final int i, final int j)`
- **Summary:** Returns the element above the specified position, if it exists.
- **Contract:**
  - Returns the element above the specified position, if it exists.
  - This method provides safe access to the element directly above the given position without throwing an exception when at the top edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalShort containing the element at position (rowIndex - 1, columnIndex), or empty if rowIndex == 0
##### downOf(...) -> OptionalShort
- **Signature:** `public OptionalShort downOf(final int i, final int j)`
- **Summary:** Returns the element below the specified position, if it exists.
- **Contract:**
  - Returns the element below the specified position, if it exists.
  - This method provides safe access to the element directly below the given position without throwing an exception when at the bottom edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalShort containing the element at position (rowIndex + 1, columnIndex), or empty if rowIndex == rowCount - 1
##### leftOf(...) -> OptionalShort
- **Signature:** `public OptionalShort leftOf(final int i, final int j)`
- **Summary:** Returns the element to the left of the specified position, if it exists.
- **Contract:**
  - Returns the element to the left of the specified position, if it exists.
  - This method provides safe access to the element directly to the left of the given position without throwing an exception when at the leftmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalShort containing the element at position (rowIndex, columnIndex - 1), or empty if columnIndex == 0
##### rightOf(...) -> OptionalShort
- **Signature:** `public OptionalShort rightOf(final int i, final int j)`
- **Summary:** Returns the element to the right of the specified position, if it exists.
- **Contract:**
  - Returns the element to the right of the specified position, if it exists.
  - This method provides safe access to the element directly to the right of the given position without throwing an exception when at the rightmost edge of the matrix.
- **Parameters:**
  - `i` (`int`) — the row index (0-based)
  - `j` (`int`) — the column index (0-based)
- **Returns:** an OptionalShort containing the element at position (rowIndex, columnIndex + 1), or empty if columnIndex == columnCount - 1
##### row(...) -> short\[\]
- **Signature:** `public short[] row(final int rowIndex) throws IllegalArgumentException`
- **Summary:** Returns the specified row as a short array.
- **Contract:**
  - If you need an independent copy, use {@code Arrays.copyOf(matrix.row(i), matrix.columnCount())} .
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to retrieve (0-based)
- **Returns:** the specified row array (direct reference to internal storage)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex &lt; 0 or rowIndex &gt; = rows
##### column(...) -> short\[\]
- **Signature:** `public short[] column(final int columnIndex) throws IllegalArgumentException`
- **Summary:** Returns a copy of the specified column as a new short array.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to retrieve (0-based)
- **Returns:** a new array containing the values from the specified column
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex &lt; 0 or columnIndex &gt; = columnCount
##### setRow(...) -> void
- **Signature:** `public void setRow(final int rowIndex, final short[] row) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified row by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of columns in the matrix.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to set (0-based)
  - `row` (`short[]`) — the array of values to copy into the row; must have length equal to the number of columns
- **Throws:**
  - `java.lang.IllegalArgumentException` — if rowIndex is out of bounds or row length does not match column count
##### setColumn(...) -> void
- **Signature:** `public void setColumn(final int columnIndex, final short[] column) throws IllegalArgumentException`
- **Summary:** Sets the values of the specified column by copying from the provided array.
- **Contract:**
  - The source array must have exactly the same length as the number of rows in the matrix.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to set (0-based)
  - `column` (`short[]`) — the array of values to copy into the column; must have length equal to the number of rows
- **Throws:**
  - `java.lang.IllegalArgumentException` — if columnIndex is out of bounds or column length does not match row count
##### updateRow(...) -> void
- **Signature:** `public <E extends Exception> void updateRow(final int rowIndex, final Throwables.ShortUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the specified row by applying the given operator to each element.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to update (0-based)
  - `operator` (`Throwables.ShortUnaryOperator<E>`) — the unary operator to apply to each element in the row, taking a short and returning a short
- **Throws:**
  - `E` — if the operator throws an exception
##### updateColumn(...) -> void
- **Signature:** `public <E extends Exception> void updateColumn(final int columnIndex, final Throwables.ShortUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the specified column by applying the given operator to each element.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to update (0-based)
  - `operator` (`Throwables.ShortUnaryOperator<E>`) — the unary operator to apply to each element in the column, taking a short and returning a short
- **Throws:**
  - `E` — if the operator throws an exception
##### getLU2RD(...) -> short\[\]
- **Signature:** `public short[] getLU2RD() throws IllegalStateException`
- **Summary:** Returns the elements on the main diagonal from left-upper to right-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new short array containing the main diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setLU2RD(...) -> void
- **Signature:** `public void setLU2RD(final short[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the main diagonal from left-upper to right-down (main diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array must have exactly as many elements as the matrix has rows.
  - The diagonal array length must exactly match the number of rows (and columns) in the matrix.
- **Parameters:**
  - `diagonal` (`short[]`) — the new values for the main diagonal; must have length == rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length does not equal to rows
##### updateLU2RD(...) -> void
- **Signature:** `public <E extends Exception> void updateLU2RD(final Throwables.ShortUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements on the main diagonal (left-up to right-down) by applying the given operator.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - `operator` (`Throwables.ShortUnaryOperator<E>`) — the operator to apply to each diagonal element
- **Throws:**
  - `E` — if the operator throws an exception
##### getRU2LD(...) -> short\[\]
- **Signature:** `public short[] getRU2LD() throws IllegalStateException`
- **Summary:** Returns the elements on the anti-diagonal from right-upper to left-down.
- **Contract:**
  - The matrix must be square (rows == columns) for this operation.
- **Parameters:**
  - (none)
- **Returns:** a new short array containing the anti-diagonal elements
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
##### setRU2LD(...) -> void
- **Signature:** `public void setRU2LD(final short[] diagonal) throws IllegalStateException, IllegalArgumentException`
- **Summary:** Sets the elements on the anti-diagonal from right-upper to left-down (anti-diagonal).
- **Contract:**
  - The matrix must be square (rows == columns), and the diagonal array must have exactly as many elements as the matrix has rows.
- **Parameters:**
  - `diagonal` (`short[]`) — the new values for the anti-diagonal; must have length equal to rows
- **Throws:**
  - `java.lang.IllegalStateException` — if the matrix is not square (rows != columns)
  - `java.lang.IllegalArgumentException` — if diagonal array length != rows
##### updateRU2LD(...) -> void
- **Signature:** `public <E extends Exception> void updateRU2LD(final Throwables.ShortUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements on the anti-diagonal (right-up to left-down) by applying the given operator.
- **Contract:**
  - The matrix must be square (same number of rows and columns).
- **Parameters:**
  - `operator` (`Throwables.ShortUnaryOperator<E>`) — the operator to apply to each anti-diagonal element
- **Throws:**
  - `E` — if the operator throws an exception
##### updateAll(...) -> void
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.ShortUnaryOperator<E> operator) throws E`
- **Summary:** Updates all elements in the matrix by applying the given operator to each element.
- **Parameters:**
  - `operator` (`Throwables.ShortUnaryOperator<E>`) — the unary operator to apply to each element, taking a short and returning a short
- **Throws:**
  - `E` — if the operator throws an exception
- **Signature:** `public <E extends Exception> void updateAll(final Throwables.IntBiFunction<Short, E> operator) throws E`
- **Summary:** Updates all elements in the matrix based on their position by applying the given operator.
- **Parameters:**
  - `operator` (`Throwables.IntBiFunction<Short, E>`) — the bi-function that takes (rowIndex, columnIndex) and returns the new short value
- **Throws:**
  - `E` — if the operator throws an exception
##### replaceIf(...) -> void
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.ShortPredicate<E> predicate, final short newValue) throws E`
- **Summary:** Conditionally replaces elements in the matrix based on a predicate.
- **Parameters:**
  - `predicate` (`Throwables.ShortPredicate<E>`) — the condition to test each element; returns {@code true} if the element should be replaced
  - `newValue` (`short`) — the value to replace matching elements with
- **Throws:**
  - `E` — if the predicate throws an exception
- **Signature:** `public <E extends Exception> void replaceIf(final Throwables.IntBiPredicate<E> predicate, final short newValue) throws E`
- **Summary:** Conditionally replaces elements in the matrix based on their position.
- **Contract:**
  - The predicate receives the row and column indices (0-based) and returns {@code true} if the element at that position should be replaced with the new value.
- **Parameters:**
  - `predicate` (`Throwables.IntBiPredicate<E>`) — the bi-predicate that takes (rowIndex, columnIndex) and returns {@code true} if element should be replaced
  - `newValue` (`short`) — the value to replace matching elements with
- **Throws:**
  - `E` — if the predicate throws an exception
##### map(...) -> ShortMatrix
- **Signature:** `public <E extends Exception> ShortMatrix map(final Throwables.ShortUnaryOperator<E> mapper) throws E`
- **Summary:** Creates a new matrix by applying the given function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.ShortUnaryOperator<E>`) — the unary operator to apply to each element, taking a short and returning a short
- **Returns:** a new ShortMatrix with the transformed values; the original matrix is unchanged
- **Throws:**
  - `E` — if the function throws an exception
##### mapToObj(...) -> Matrix<T>
- **Signature:** `public <T, E extends Exception> Matrix<T> mapToObj(final Throwables.ShortFunction<? extends T, E> mapper, final Class<T> targetElementType) throws E`
- **Summary:** Creates a new object matrix by applying the given function to each element of this matrix.
- **Parameters:**
  - `mapper` (`Throwables.ShortFunction<? extends T, E>`) — the function to transform each short to an object of type T
  - `targetElementType` (`Class<T>`) — the class of the target element type (used for array creation)
- **Returns:** a new Matrix &lt; T &gt; with the transformed object values; the original matrix is unchanged
- **Throws:**
  - `E` — if the function throws an exception
##### fill(...) -> void
- **Signature:** `public void fill(final short val)`
- **Summary:** Fills all elements of the matrix with the specified value.
- **Parameters:**
  - `val` (`short`) — the value to fill the matrix with
- **Signature:** `public void fill(final short[][] b)`
- **Summary:** Fills the matrix with values from another two-dimensional array, starting at position (0, 0).
- **Contract:**
  - If the source array is larger, only the portion that fits is copied.
- **Parameters:**
  - `b` (`short[][]`) — the two-dimensional array to copy values from
- **Signature:** `public void fill(final int fromRowIndex, final int fromColumnIndex, final short[][] b) throws IllegalArgumentException`
- **Summary:** Fills a region of the matrix with values from another two-dimensional array, starting at the specified position.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index in this matrix (0-based, must be 0 &lt; = fromRowIndex &lt; = rows)
  - `fromColumnIndex` (`int`) — the starting column index in this matrix (0-based, must be 0 &lt; = fromColumnIndex &lt; = columnCount)
  - `b` (`short[][]`) — the source array to copy values from
- **Throws:**
  - `java.lang.IllegalArgumentException` — if fromRowIndex &lt; 0 or &gt; rows, or if fromColumnIndex &lt; 0 or &gt; columnCount
##### copy(...) -> ShortMatrix
- **Signature:** `@Override public ShortMatrix copy()`
- **Summary:** Creates a deep copy of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a new ShortMatrix that is an independent deep copy of this matrix
- **Signature:** `@Override public ShortMatrix copy(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a subset of rows from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a new ShortMatrix containing an independent copy of the specified rows
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if fromRowIndex &lt; 0, toRowIndex &gt; rows, or fromRowIndex &gt; toRowIndex
- **Signature:** `@Override public ShortMatrix copy(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a copy of a rectangular sub-region from this matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a new ShortMatrix containing an independent copy of the specified rectangular region
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is out of bounds or fromIndex &gt; toIndex
##### extend(...) -> ShortMatrix
- **Signature:** `public ShortMatrix extend(final int newRowCount, final int newColumnCount)`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with 0.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
- **Returns:** a new ShortMatrix with the specified dimensions
- **Signature:** `public ShortMatrix extend(final int newRowCount, final int newColumnCount, final short defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending or truncating this matrix to the specified dimensions.
- **Contract:**
  - <p> If the new dimensions are smaller than the current dimensions, the matrix is truncated from the top-left corner.
  - If larger, the existing content is preserved in the top-left corner and new cells are filled with the specified default value.
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the new matrix. It can be smaller than the row number of the current matrix but must be non-negative
  - `newColumnCount` (`int`) — the number of columns in the new matrix. It can be smaller than the column number of the current matrix but must be non-negative
  - `defaultValueForNewCell` (`short`) — the short value to fill new cells with during extension
- **Returns:** a new ShortMatrix with the specified dimensions
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code newRowCount} or {@code newColumnCount} is negative, or if the resulting matrix would be too large (dimensions exceeding Integer.MAX_VALUE elements)
- **Signature:** `public ShortMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight)`
- **Summary:** Creates a new matrix by extending this matrix in all four directions.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
- **Returns:** a new extended ShortMatrix with dimensions ((toUp+rows+toDown) x (toLeft+columnCount+toRight))
- **Signature:** `public ShortMatrix extend(final int toUp, final int toDown, final int toLeft, final int toRight, final short defaultValueForNewCell) throws IllegalArgumentException`
- **Summary:** Creates a new matrix by extending this matrix in all four directions with padding.
- **Parameters:**
  - `toUp` (`int`) — number of rows to add above; must be non-negative
  - `toDown` (`int`) — number of rows to add below; must be non-negative
  - `toLeft` (`int`) — number of columns to add to the left; must be non-negative
  - `toRight` (`int`) — number of columns to add to the right; must be non-negative
  - `defaultValueForNewCell` (`short`) — the short value to fill all new cells with
- **Returns:** a new extended ShortMatrix with dimensions ((toUp+rows+toDown) x (toLeft+columnCount+toRight))
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any padding parameter is negative, or if the resulting dimensions would exceed Integer.MAX_VALUE
##### reverseH(...) -> void
- **Signature:** `public void reverseH()`
- **Summary:** Reverses the order of elements in each row (horizontal flip in-place).
- **Parameters:**
  - (none)
- **See also:** #flipH()
##### reverseV(...) -> void
- **Signature:** `public void reverseV()`
- **Summary:** Reverses the order of rows in the matrix (vertical flip in-place).
- **Parameters:**
  - (none)
- **See also:** #flipV()
##### flipH(...) -> ShortMatrix
- **Signature:** `public ShortMatrix flipH()`
- **Summary:** Creates a new matrix that is horizontally flipped (each row reversed).
- **Parameters:**
  - (none)
- **Returns:** a new matrix with each row reversed
- **See also:** #flipV(), IntMatrix#flipH(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1,</a>
##### flipV(...) -> ShortMatrix
- **Signature:** `public ShortMatrix flipV()`
- **Summary:** Creates a new matrix that is vertically flipped (each column reversed).
- **Parameters:**
  - (none)
- **Returns:** a new matrix with rows in reversed order
- **See also:** #flipH(), IntMatrix#flipV(), <a href="https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1">,https://www.mathworks.com/help/matlab/ref/flip.html#btz149s-1,</a>
##### rotate90(...) -> ShortMatrix
- **Signature:** `@Override public ShortMatrix rotate90()`
- **Summary:** Creates a new matrix rotated 90 degrees clockwise.
- **Parameters:**
  - (none)
- **Returns:** a new ShortMatrix rotated 90 degrees clockwise with dimensions columnCount × rows
##### rotate180(...) -> ShortMatrix
- **Signature:** `@Override public ShortMatrix rotate180()`
- **Summary:** Creates a new matrix rotated 180 degrees.
- **Parameters:**
  - (none)
- **Returns:** a new ShortMatrix rotated 180 degrees with the same dimensions
##### rotate270(...) -> ShortMatrix
- **Signature:** `@Override public ShortMatrix rotate270()`
- **Summary:** Creates a new matrix rotated 270 degrees clockwise (or 90 degrees counter-clockwise).
- **Parameters:**
  - (none)
- **Returns:** a new ShortMatrix rotated 270 degrees clockwise with dimensions columnCount × rows
##### transpose(...) -> ShortMatrix
- **Signature:** `@Override public ShortMatrix transpose()`
- **Summary:** Creates the transpose of this matrix by swapping rows and columns.
- **Parameters:**
  - (none)
- **Returns:** a new ShortMatrix that is the transpose with dimensions columnCount × rows
##### reshape(...) -> ShortMatrix
- **Signature:** `@SuppressFBWarnings("ICAST_INTEGER_MULTIPLY_CAST_TO_LONG") @Override public ShortMatrix reshape(final int newRowCount, final int newColumnCount)`
- **Summary:** Reshapes the matrix to new dimensions while preserving element order in row-major layout.
- **Contract:**
  - If the new shape has fewer total elements than the original, excess elements are truncated.
  - If the new shape has more total elements, the additional positions are filled with zeros (default value for short).
- **Parameters:**
  - `newRowCount` (`int`) — the number of rows in the reshaped matrix (must be non-negative)
  - `newColumnCount` (`int`) — the number of columns in the reshaped matrix (must be non-negative)
- **Returns:** a new ShortMatrix with the specified shape containing this matrix's elements in row-major order
##### repelem(...) -> ShortMatrix
- **Signature:** `@Override public ShortMatrix repelem(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats each element in the matrix by the specified factors.
- **Parameters:**
  - `rowRepeats` (`int`) — the number of times to repeat each element in the row direction (must be positive)
  - `colRepeats` (`int`) — the number of times to repeat each element in the column direction (must be positive)
- **Returns:** a new ShortMatrix with dimensions (rows * rowRepeats) × (columnCount * colRepeats)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rowRepeats} or {@code colRepeats} is less than or equal to 0
- **See also:** IntMatrix#repelem(int, int)
##### repmat(...) -> ShortMatrix
- **Signature:** `@Override public ShortMatrix repmat(final int rowRepeats, final int colRepeats) throws IllegalArgumentException`
- **Summary:** Repeats the entire matrix as a tile pattern.
- **Parameters:**
  - `rowRepeats` (`int`) — the number of times to repeat the matrix in the row direction (must be positive)
  - `colRepeats` (`int`) — the number of times to repeat the matrix in the column direction (must be positive)
- **Returns:** a new ShortMatrix with dimensions (rows * rowRepeats) × (columnCount * colRepeats) containing the tiled pattern
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rowRepeats} or {@code colRepeats} is less than or equal to 0
- **See also:** IntMatrix#repmat(int, int), #repelem(int, int)
##### flatten(...) -> ShortList
- **Signature:** `@Override public ShortList flatten()`
- **Summary:** Flattens the matrix into a one-dimensional list in row-major order.
- **Parameters:**
  - (none)
- **Returns:** a new ShortList containing all elements in row-major order
##### flatOp(...) -> void
- **Signature:** `@Override public <E extends Exception> void flatOp(final Throwables.Consumer<? super short[], E> op) throws E`
- **Summary:** Applies an operation to each row array of the underlying two-dimensional array.
- **Parameters:**
  - `op` (`Throwables.Consumer<? super short[], E>`) — the operation to apply to each row array
- **Throws:**
  - `E` — if the operation throws an exception
- **See also:** Arrays#flatOp(short\[\]\[\], Throwables.Consumer)
##### vstack(...) -> ShortMatrix
- **Signature:** `public ShortMatrix vstack(final ShortMatrix other) throws IllegalArgumentException`
- **Summary:** Vertically stacks this matrix with another matrix.
- **Contract:**
  - The two matrices must have the same number of columns.
- **Parameters:**
  - `other` (`ShortMatrix`) — the matrix to stack below this matrix
- **Returns:** a new matrix with rows from both matrices stacked vertically
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same number of columns
- **See also:** IntMatrix#vstack(IntMatrix)
##### hstack(...) -> ShortMatrix
- **Signature:** `public ShortMatrix hstack(final ShortMatrix other) throws IllegalArgumentException`
- **Summary:** Horizontally stacks this matrix with another matrix.
- **Contract:**
  - The two matrices must have the same number of rows.
- **Parameters:**
  - `other` (`ShortMatrix`) — the matrix to stack to the right of this matrix
- **Returns:** a new matrix with columns from both matrices stacked horizontally
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same number of rows
- **See also:** IntMatrix#hstack(IntMatrix)
##### add(...) -> ShortMatrix
- **Signature:** `public ShortMatrix add(final ShortMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise addition of this matrix with another matrix.
- **Contract:**
  - The two matrices must have the same dimensions (same number of rows and columns).
- **Parameters:**
  - `other` (`ShortMatrix`) — the matrix to add to this matrix (must have same dimensions)
- **Returns:** a new matrix containing the element-wise sum
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same shape (same rows and columns)
##### subtract(...) -> ShortMatrix
- **Signature:** `public ShortMatrix subtract(final ShortMatrix other) throws IllegalArgumentException`
- **Summary:** Performs element-wise subtraction of another matrix from this matrix.
- **Contract:**
  - The two matrices must have the same dimensions (same number of rows and columns).
- **Parameters:**
  - `other` (`ShortMatrix`) — the matrix to subtract from this matrix (must have same dimensions)
- **Returns:** a new matrix containing the element-wise difference (this - other)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same shape (same rows and columns)
##### multiply(...) -> ShortMatrix
- **Signature:** `public ShortMatrix multiply(final ShortMatrix other) throws IllegalArgumentException`
- **Summary:** Performs standard matrix multiplication with another matrix.
- **Contract:**
  - The number of columns in this matrix must equal the number of rows in the specified matrix.
- **Parameters:**
  - `other` (`ShortMatrix`) — the matrix to multiply with this matrix (this.columnCount must equal other.rowCount)
- **Returns:** a new matrix of dimension (this.rowCount × other.columnCount) containing the matrix product
- **Throws:**
  - `java.lang.IllegalArgumentException` — if this.columnCount != other.rowCount (incompatible dimensions for multiplication)
##### boxed(...) -> Matrix<Short>
- **Signature:** `public Matrix<Short> boxed()`
- **Summary:** Converts this primitive short matrix to a boxed {@code Matrix<Short>} .
- **Contract:**
  - Use this method only when you need to work with generic Matrix API or when null values are required.
- **Parameters:**
  - (none)
- **Returns:** a new {@code Matrix<Short>} containing boxed values
##### toIntMatrix(...) -> IntMatrix
- **Signature:** `public IntMatrix toIntMatrix()`
- **Summary:** Converts this short matrix to an int matrix.
- **Parameters:**
  - (none)
- **Returns:** a new {@code IntMatrix} with values converted from short to int
##### toLongMatrix(...) -> LongMatrix
- **Signature:** `public LongMatrix toLongMatrix()`
- **Summary:** Converts this short matrix to a long matrix.
- **Parameters:**
  - (none)
- **Returns:** a new {@code LongMatrix} with values converted from short to long
##### toFloatMatrix(...) -> FloatMatrix
- **Signature:** `public FloatMatrix toFloatMatrix()`
- **Summary:** Converts this short matrix to a float matrix.
- **Parameters:**
  - (none)
- **Returns:** a new {@code FloatMatrix} with values converted from short to float
##### toDoubleMatrix(...) -> DoubleMatrix
- **Signature:** `public DoubleMatrix toDoubleMatrix()`
- **Summary:** Converts this short matrix to a double matrix.
- **Parameters:**
  - (none)
- **Returns:** a new {@code DoubleMatrix} with values converted from short to double
##### zipWith(...) -> ShortMatrix
- **Signature:** `public <E extends Exception> ShortMatrix zipWith(final ShortMatrix matrixB, final Throwables.ShortBinaryOperator<E> zipFunction) throws IllegalArgumentException, E`
- **Summary:** Applies a binary operation element-wise to this matrix and another matrix.
- **Contract:**
  - The two matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`ShortMatrix`) — the second matrix to zip with this matrix
  - `zipFunction` (`Throwables.ShortBinaryOperator<E>`) — the binary operation to apply to corresponding elements
- **Returns:** a new matrix with the results of the zip operation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the matrices don't have the same shape
  - `E` — if the zip function throws an exception
- **Signature:** `public <E extends Exception> ShortMatrix zipWith(final ShortMatrix matrixB, final ShortMatrix matrixC, final Throwables.ShortTernaryOperator<E> zipFunction) throws E`
- **Summary:** Applies a ternary operation element-wise to this matrix and two other matrices.
- **Contract:**
  - All three matrices must have the same dimensions.
- **Parameters:**
  - `matrixB` (`ShortMatrix`) — the second matrix to zip with
  - `matrixC` (`ShortMatrix`) — the third matrix to zip with
  - `zipFunction` (`Throwables.ShortTernaryOperator<E>`) — the ternary operation to apply to corresponding elements from all three matrices
- **Returns:** a new matrix with the results of the zip operation
- **Throws:**
  - `E` — if the zip function throws an exception
##### streamLU2RD(...) -> ShortStream
- **Signature:** `@Override public ShortStream streamLU2RD()`
- **Summary:** Creates a stream of elements on the main diagonal from left-upper to right-down.
- **Contract:**
  - <p> The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a ShortStream of diagonal elements from left-upper to right-down
##### streamRU2LD(...) -> ShortStream
- **Signature:** `@Override public ShortStream streamRU2LD()`
- **Summary:** Creates a stream of elements on the anti-diagonal from right-upper to left-down.
- **Contract:**
  - <p> The matrix must be square (same number of rows and columns).
- **Parameters:**
  - (none)
- **Returns:** a ShortStream of anti-diagonal elements from right-upper to left-down
##### streamH(...) -> ShortStream
- **Signature:** `@Override public ShortStream streamH()`
- **Summary:** Creates a stream of all elements in the matrix in row-major order (horizontally).
- **Parameters:**
  - (none)
- **Returns:** a ShortStream of all matrix elements in row-major order
- **Signature:** `@Override public ShortStream streamH(final int rowIndex)`
- **Summary:** Creates a stream of elements from a specific row.
- **Parameters:**
  - `rowIndex` (`int`) — the index of the row to stream (0-based)
- **Returns:** a ShortStream of elements from the specified row
- **Signature:** `@Override public ShortStream streamH(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of elements from a range of rows in row-major order.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a ShortStream of elements from the specified row range in row-major order
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the row indices are out of bounds or fromRowIndex &gt; toRowIndex
##### streamV(...) -> ShortStream
- **Signature:** `@Override @Beta public ShortStream streamV()`
- **Summary:** Creates a stream of all elements in the matrix in column-major order (vertically).
- **Parameters:**
  - (none)
- **Returns:** a ShortStream of all matrix elements in column-major order
- **Signature:** `@Override public ShortStream streamV(final int columnIndex)`
- **Summary:** Creates a stream of elements from a specific column.
- **Parameters:**
  - `columnIndex` (`int`) — the index of the column to stream (0-based)
- **Returns:** a ShortStream of elements from the specified column
- **Signature:** `@Override @Beta public ShortStream streamV(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of elements from a range of columns in column-major order.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a ShortStream of elements from the specified column range in column-major order
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the column indices are out of bounds or fromColumnIndex &gt; toColumnIndex
##### streamR(...) -> Stream<ShortStream>
- **Signature:** `@Override public Stream<ShortStream> streamR()`
- **Summary:** Creates a stream of row streams, where each element is a stream representing a complete row.
- **Parameters:**
  - (none)
- **Returns:** a Stream of ShortStream objects, one for each row
- **Signature:** `@Override public Stream<ShortStream> streamR(final int fromRowIndex, final int toRowIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of row streams from a range of rows.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
- **Returns:** a Stream of ShortStream objects for rows in the specified range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the row indices are out of bounds or fromRowIndex &gt; toRowIndex
##### streamC(...) -> Stream<ShortStream>
- **Signature:** `@Override @Beta public Stream<ShortStream> streamC()`
- **Summary:** Creates a stream of column streams, where each element is a stream representing a complete column.
- **Parameters:**
  - (none)
- **Returns:** a Stream of ShortStream objects, one for each column
- **Signature:** `@Override @Beta public Stream<ShortStream> streamC(final int fromColumnIndex, final int toColumnIndex) throws IndexOutOfBoundsException`
- **Summary:** Creates a stream of column streams from a range of columns.
- **Parameters:**
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
- **Returns:** a Stream of ShortStream objects for columns in the specified range
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if the column indices are out of bounds or fromColumnIndex &gt; toColumnIndex
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.ShortConsumer<E> action) throws E`
- **Summary:** Applies the specified action to each element in the matrix.
- **Parameters:**
  - `action` (`Throwables.ShortConsumer<E>`) — the consumer to apply to each element
- **Throws:**
  - `E` — if the action throws an exception
- **Signature:** `public <E extends Exception> void forEach(final int fromRowIndex, final int toRowIndex, final int fromColumnIndex, final int toColumnIndex, final Throwables.ShortConsumer<E> action) throws IndexOutOfBoundsException, E`
- **Summary:** Applies the specified action to each element in a rectangular sub-region of the matrix.
- **Parameters:**
  - `fromRowIndex` (`int`) — the starting row index (inclusive, 0-based)
  - `toRowIndex` (`int`) — the ending row index (exclusive)
  - `fromColumnIndex` (`int`) — the starting column index (inclusive, 0-based)
  - `toColumnIndex` (`int`) — the ending column index (exclusive)
  - `action` (`Throwables.ShortConsumer<E>`) — the consumer to apply to each element in the region
- **Throws:**
  - `java.lang.IndexOutOfBoundsException` — if any index is out of bounds or fromIndex &gt; toIndex
  - `E` — if the action throws an exception
##### println(...) -> String
- **Signature:** `@Override public String println()`
- **Summary:** Prints the matrix to the standard output.
- **Parameters:**
  - (none)
- **Returns:** the formatted string representation of the matrix
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this matrix.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this matrix
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this matrix to the specified object for equality.
- **Contract:**
  - Returns {@code true} if the given object is also a ShortMatrix with the same dimensions and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the objects are equal, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this matrix.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this matrix

### Class ShortTuple (com.landawn.abacus.util.ShortTuple)
Abstract base class for immutable tuples containing short primitive values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> ShortTuple1
- **Signature:** `public static ShortTuple1 of(final short _1)`
- **Summary:** Creates a ShortTuple.ShortTuple1 containing a single short value.
- **Parameters:**
  - `_1` (`short`) — the short value to store in the tuple
- **Returns:** a new ShortTuple.ShortTuple1 containing the provided value
- **Signature:** `public static ShortTuple2 of(final short _1, final short _2)`
- **Summary:** Creates a ShortTuple.ShortTuple2 containing two short values.
- **Parameters:**
  - `_1` (`short`) — the first short value
  - `_2` (`short`) — the second short value
- **Returns:** a new ShortTuple.ShortTuple2 containing the provided values
- **Signature:** `public static ShortTuple3 of(final short _1, final short _2, final short _3)`
- **Summary:** Creates a ShortTuple.ShortTuple3 containing three short values.
- **Parameters:**
  - `_1` (`short`) — the first short value
  - `_2` (`short`) — the second short value
  - `_3` (`short`) — the third short value
- **Returns:** a new ShortTuple.ShortTuple3 containing the provided values
- **Signature:** `public static ShortTuple4 of(final short _1, final short _2, final short _3, final short _4)`
- **Summary:** Creates a ShortTuple.ShortTuple4 containing four short values.
- **Parameters:**
  - `_1` (`short`) — the first short value
  - `_2` (`short`) — the second short value
  - `_3` (`short`) — the third short value
  - `_4` (`short`) — the fourth short value
- **Returns:** a new ShortTuple.ShortTuple4 containing the provided values
- **Signature:** `public static ShortTuple5 of(final short _1, final short _2, final short _3, final short _4, final short _5)`
- **Summary:** Creates a ShortTuple.ShortTuple5 containing five short values.
- **Parameters:**
  - `_1` (`short`) — the first short value
  - `_2` (`short`) — the second short value
  - `_3` (`short`) — the third short value
  - `_4` (`short`) — the fourth short value
  - `_5` (`short`) — the fifth short value
- **Returns:** a new ShortTuple.ShortTuple5 containing the provided values
- **Signature:** `public static ShortTuple6 of(final short _1, final short _2, final short _3, final short _4, final short _5, final short _6)`
- **Summary:** Creates a ShortTuple.ShortTuple6 containing six short values.
- **Parameters:**
  - `_1` (`short`) — the first short value
  - `_2` (`short`) — the second short value
  - `_3` (`short`) — the third short value
  - `_4` (`short`) — the fourth short value
  - `_5` (`short`) — the fifth short value
  - `_6` (`short`) — the sixth short value
- **Returns:** a new ShortTuple.ShortTuple6 containing the provided values
- **Signature:** `public static ShortTuple7 of(final short _1, final short _2, final short _3, final short _4, final short _5, final short _6, final short _7)`
- **Summary:** Creates a ShortTuple.ShortTuple7 containing seven short values.
- **Parameters:**
  - `_1` (`short`) — the first short value
  - `_2` (`short`) — the second short value
  - `_3` (`short`) — the third short value
  - `_4` (`short`) — the fourth short value
  - `_5` (`short`) — the fifth short value
  - `_6` (`short`) — the sixth short value
  - `_7` (`short`) — the seventh short value
- **Returns:** a new ShortTuple.ShortTuple7 containing the provided values
- **Signature:** `@Deprecated public static ShortTuple8 of(final short _1, final short _2, final short _3, final short _4, final short _5, final short _6, final short _7, final short _8)`
- **Summary:** Creates a ShortTuple.ShortTuple8 containing eight short values.
- **Parameters:**
  - `_1` (`short`) — the first short value
  - `_2` (`short`) — the second short value
  - `_3` (`short`) — the third short value
  - `_4` (`short`) — the fourth short value
  - `_5` (`short`) — the fifth short value
  - `_6` (`short`) — the sixth short value
  - `_7` (`short`) — the seventh short value
  - `_8` (`short`) — the eighth short value
- **Returns:** a new ShortTuple.ShortTuple8 containing the provided values
- **Signature:** `@Deprecated public static ShortTuple9 of(final short _1, final short _2, final short _3, final short _4, final short _5, final short _6, final short _7, final short _8, final short _9)`
- **Summary:** Creates a ShortTuple.ShortTuple9 containing nine short values.
- **Parameters:**
  - `_1` (`short`) — the first short value
  - `_2` (`short`) — the second short value
  - `_3` (`short`) — the third short value
  - `_4` (`short`) — the fourth short value
  - `_5` (`short`) — the fifth short value
  - `_6` (`short`) — the sixth short value
  - `_7` (`short`) — the seventh short value
  - `_8` (`short`) — the eighth short value
  - `_9` (`short`) — the ninth short value
- **Returns:** a new ShortTuple.ShortTuple9 containing the provided values
##### create(...) -> TP
- **Signature:** `@SuppressWarnings("deprecation") public static <TP extends ShortTuple<TP>> TP create(final short[] values)`
- **Summary:** Creates a ShortTuple from an array of short values.
- **Parameters:**
  - `values` (`short[]`) — the array of short values (must have length 0-9), may be {@code null}
- **Returns:** a ShortTuple of appropriate size containing the array values, or an empty ShortTuple if the array is null or empty

#### Public Instance Methods
##### min(...) -> short
- **Signature:** `public short min()`
- **Summary:** Returns the minimum short value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the minimum short value in this tuple
##### max(...) -> short
- **Signature:** `public short max()`
- **Summary:** Returns the maximum short value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the maximum short value in this tuple
##### median(...) -> short
- **Signature:** `public short median()`
- **Summary:** Returns the median short value in this tuple.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code ShortTuple.ShortTuple3 tuple = ShortTuple.of((short)1, (short)3, (short)2); short median = tuple.median(); // 2 (middle value when sorted: 1, 2, 3) ShortTuple.ShortTuple4 evenTuple = ShortTuple.of((short)1, (short)2, (short)3, (short)4); short evenMedian = evenTuple.median(); // 2 (lower middle when sorted: 1, \[2\], 3, 4) } </pre>
- **Parameters:**
  - (none)
- **Returns:** the median short value in this tuple
##### sum(...) -> int
- **Signature:** `public int sum()`
- **Summary:** Returns the sum of all elements in this tuple as an int.
- **Contract:**
  - <p> Note: While this tuple stores short values, the sum is returned as an int to prevent overflow when adding multiple short values together.
- **Parameters:**
  - (none)
- **Returns:** the sum of all short values in this tuple as an int
##### average(...) -> double
- **Signature:** `public double average()`
- **Summary:** Returns the average of all short values in this tuple as a double.
- **Parameters:**
  - (none)
- **Returns:** the average of all short values in this tuple as a double
##### reverse(...) -> TP
- **Signature:** `public abstract TP reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new tuple with the elements in reverse order
##### contains(...) -> boolean
- **Signature:** `public abstract boolean contains(short valueToFind)`
- **Summary:** Checks if this tuple contains the specified short value.
- **Contract:**
  - Checks if this tuple contains the specified short value.
- **Parameters:**
  - `valueToFind` (`short`) — the short value to search for
- **Returns:** {@code true} if the value is found in this tuple, {@code false} otherwise
##### toArray(...) -> short\[\]
- **Signature:** `public short[] toArray()`
- **Summary:** Returns a new array containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new short array containing all tuple elements
##### toList(...) -> ShortList
- **Signature:** `public ShortList toList()`
- **Summary:** Returns a new ShortList containing all elements of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a new ShortList containing all tuple elements
##### forEach(...) -> void
- **Signature:** `public <E extends Exception> void forEach(final Throwables.ShortConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in this tuple.
- **Parameters:**
  - `consumer` (`Throwables.ShortConsumer<E>`) — the action to perform for each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### stream(...) -> ShortStream
- **Signature:** `public ShortStream stream()`
- **Summary:** Returns a ShortStream of all elements in this tuple.
- **Parameters:**
  - (none)
- **Returns:** a ShortStream containing all tuple elements
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code value for this tuple
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are of the same class and contain equal elements in the same order.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the objects are equal, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this tuple

### Class ShortTuple1 (com.landawn.abacus.util.ShortTuple.ShortTuple1)
A tuple containing exactly one short value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 1.
- **Parameters:**
  - (none)
- **Returns:** 1
##### min(...) -> short
- **Signature:** `@Override public short min()`
- **Summary:** Returns the minimum value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single element value
##### max(...) -> short
- **Signature:** `@Override public short max()`
- **Summary:** Returns the maximum value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single element value
##### median(...) -> short
- **Signature:** `@Override public short median()`
- **Summary:** Returns the median value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single element value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all values in this tuple as an int.
- **Parameters:**
  - (none)
- **Returns:** the single element value as an int
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all values in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the single element value as a double
##### reverse(...) -> ShortTuple1
- **Signature:** `@Override public ShortTuple1 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ShortTuple.ShortTuple1 with the same value
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final short valueToFind)`
- **Summary:** Checks if this tuple contains the specified value.
- **Contract:**
  - Checks if this tuple contains the specified value.
- **Parameters:**
  - `valueToFind` (`short`) — the short value to search for
- **Returns:** {@code true} if the value equals _1, {@code false} otherwise
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** the hash code of the single element
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the object is a ShortTuple.ShortTuple1 with the same value
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string in the format "(value)"

### Class ShortTuple2 (com.landawn.abacus.util.ShortTuple.ShortTuple2)
A tuple containing exactly two short values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 2.
- **Parameters:**
  - (none)
- **Returns:** 2
##### min(...) -> short
- **Signature:** `@Override public short min()`
- **Summary:** Returns the minimum value among the two elements.
- **Parameters:**
  - (none)
- **Returns:** the smaller of _1 and _2
##### max(...) -> short
- **Signature:** `@Override public short max()`
- **Summary:** Returns the maximum value among the two elements.
- **Parameters:**
  - (none)
- **Returns:** the larger of _1 and _2
##### median(...) -> short
- **Signature:** `@Override public short median()`
- **Summary:** Returns the median short value in this tuple.
- **Parameters:**
  - (none)
- **Returns:** the median (lower) short value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of the two elements as an int.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 as an int
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of the two elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2) / 2.0 as a double
##### reverse(...) -> ShortTuple2
- **Signature:** `@Override public ShortTuple2 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ShortTuple.ShortTuple2 with values (_2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final short valueToFind)`
- **Summary:** Checks if either element equals the specified value.
- **Contract:**
  - Checks if either element equals the specified value.
- **Parameters:**
  - `valueToFind` (`short`) — the short value to search for
- **Returns:** {@code true} if valueToFind equals _1 or _2
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ShortConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.ShortConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.ShortBiConsumer<E> action) throws E`
- **Summary:** Performs the given bi-consumer on the two elements.
- **Parameters:**
  - `action` (`Throwables.ShortBiConsumer<E>`) — the bi-consumer to perform on the two elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `@MayReturnNull public <U, E extends Exception> U map(final Throwables.ShortBiFunction<U, E> mapper) throws E`
- **Summary:** Applies the given bi-function to the two elements and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.ShortBiFunction<U, E>`) — the bi-function to apply to the two elements
- **Returns:** the result of applying the mapper function
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<ShortTuple2>
- **Signature:** `public <E extends Exception> Optional<ShortTuple2> filter(final Throwables.ShortBiPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Contract:**
  - Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Parameters:**
  - `predicate` (`Throwables.ShortBiPredicate<E>`) — the bi-predicate to test the two elements
- **Returns:** an Optional containing this tuple if the predicate returns true, empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** 31 * _1 + _2
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the object is a ShortTuple.ShortTuple2 with the same values
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string in the format "(_1, _2)"

### Class ShortTuple3 (com.landawn.abacus.util.ShortTuple.ShortTuple3)
A tuple containing exactly three short values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 3.
- **Parameters:**
  - (none)
- **Returns:** 3
##### min(...) -> short
- **Signature:** `@Override public short min()`
- **Summary:** Returns the minimum value among the three elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, and _3
##### max(...) -> short
- **Signature:** `@Override public short max()`
- **Summary:** Returns the maximum value among the three elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, and _3
##### median(...) -> short
- **Signature:** `@Override public short median()`
- **Summary:** Returns the median value of the three elements.
- **Parameters:**
  - (none)
- **Returns:** the middle short value when sorted
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all three elements as an int.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 as an int
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all three elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3) / 3.0 as a double
##### reverse(...) -> ShortTuple3
- **Signature:** `@Override public ShortTuple3 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ShortTuple.ShortTuple3 with values (_3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final short valueToFind)`
- **Summary:** Checks if any element equals the specified value.
- **Contract:**
  - Checks if any element equals the specified value.
- **Parameters:**
  - `valueToFind` (`short`) — the short value to search for
- **Returns:** {@code true} if valueToFind equals _1, _2, or _3
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ShortConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.ShortConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### accept(...) -> void
- **Signature:** `public <E extends Exception> void accept(final Throwables.ShortTriConsumer<E> action) throws E`
- **Summary:** Performs the given tri-consumer on the three elements.
- **Parameters:**
  - `action` (`Throwables.ShortTriConsumer<E>`) — the tri-consumer to perform on the three elements
- **Throws:**
  - `E` — if the action throws an exception
##### map(...) -> U
- **Signature:** `@MayReturnNull public <U, E extends Exception> U map(final Throwables.ShortTriFunction<U, E> mapper) throws E`
- **Summary:** Applies the given tri-function to the three elements and returns the result.
- **Parameters:**
  - `mapper` (`Throwables.ShortTriFunction<U, E>`) — the tri-function to apply to the three elements
- **Returns:** the result of applying the mapper function
- **Throws:**
  - `E` — if the mapper throws an exception
##### filter(...) -> Optional<ShortTuple3>
- **Signature:** `public <E extends Exception> Optional<ShortTuple3> filter(final Throwables.ShortTriPredicate<E> predicate) throws E`
- **Summary:** Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Contract:**
  - Returns an Optional containing this tuple if the predicate is satisfied, or an empty Optional otherwise.
- **Parameters:**
  - `predicate` (`Throwables.ShortTriPredicate<E>`) — the tri-predicate to test the three elements
- **Returns:** an Optional containing this tuple if the predicate returns true, empty otherwise
- **Throws:**
  - `E` — if the predicate throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** (31 * (31 * _1 + _2)) + _3
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to the specified object for equality.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if the object is a ShortTuple.ShortTuple3 with the same values
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string in the format "(_1, _2, _3)"

### Class ShortTuple4 (com.landawn.abacus.util.ShortTuple.ShortTuple4)
A tuple containing exactly four short values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 4.
- **Parameters:**
  - (none)
- **Returns:** 4
##### min(...) -> short
- **Signature:** `@Override public short min()`
- **Summary:** Returns the minimum value among the four elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, and _4
##### max(...) -> short
- **Signature:** `@Override public short max()`
- **Summary:** Returns the maximum value among the four elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, and _4
##### median(...) -> short
- **Signature:** `@Override public short median()`
- **Summary:** Returns the median value of the four elements.
- **Parameters:**
  - (none)
- **Returns:** the median (lower middle) short value when sorted
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all four elements as an int.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 as an int
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all four elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4) / 4.0 as a double
##### reverse(...) -> ShortTuple4
- **Signature:** `@Override public ShortTuple4 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ShortTuple.ShortTuple4 with values (_4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final short valueToFind)`
- **Summary:** Checks if any element equals the specified value.
- **Contract:**
  - Checks if any element equals the specified value.
- **Parameters:**
  - `valueToFind` (`short`) — the short value to search for
- **Returns:** {@code true} if valueToFind equals any of the four elements
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ShortConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.ShortConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all four elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ShortTuple.ShortTuple4 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ShortTuple.ShortTuple4 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4)"

### Class ShortTuple5 (com.landawn.abacus.util.ShortTuple.ShortTuple5)
A tuple containing exactly five short values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 5.
- **Parameters:**
  - (none)
- **Returns:** 5
##### min(...) -> short
- **Signature:** `@Override public short min()`
- **Summary:** Returns the minimum value among the five elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, and _5
##### max(...) -> short
- **Signature:** `@Override public short max()`
- **Summary:** Returns the maximum value among the five elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, and _5
##### median(...) -> short
- **Signature:** `@Override public short median()`
- **Summary:** Returns the median value of the five elements.
- **Contract:**
  - For tuples with an odd number of elements, returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the median short value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all five elements as an int.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 as an int
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all five elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5) / 5.0 as a double
##### reverse(...) -> ShortTuple5
- **Signature:** `@Override public ShortTuple5 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ShortTuple.ShortTuple5 with values (_5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final short valueToFind)`
- **Summary:** Checks if any element equals the specified value.
- **Contract:**
  - Checks if any element equals the specified value.
- **Parameters:**
  - `valueToFind` (`short`) — the short value to search for
- **Returns:** {@code true} if valueToFind equals any of the five elements
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ShortConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.ShortConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all five elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ShortTuple.ShortTuple5 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ShortTuple.ShortTuple5 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5)"

### Class ShortTuple6 (com.landawn.abacus.util.ShortTuple.ShortTuple6)
A tuple containing exactly six short values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 6.
- **Parameters:**
  - (none)
- **Returns:** 6
##### min(...) -> short
- **Signature:** `@Override public short min()`
- **Summary:** Returns the minimum value among the six elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, and _6
##### max(...) -> short
- **Signature:** `@Override public short max()`
- **Summary:** Returns the maximum value among the six elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, and _6
##### median(...) -> short
- **Signature:** `@Override public short median()`
- **Summary:** Returns the median value of the six elements.
- **Parameters:**
  - (none)
- **Returns:** the median (lower middle) short value when sorted
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all six elements as an int.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 as an int
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all six elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6) / 6.0 as a double
##### reverse(...) -> ShortTuple6
- **Signature:** `@Override public ShortTuple6 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ShortTuple.ShortTuple6 with values (_6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final short valueToFind)`
- **Summary:** Checks if any element equals the specified value.
- **Contract:**
  - Checks if any element equals the specified value.
- **Parameters:**
  - `valueToFind` (`short`) — the short value to search for
- **Returns:** {@code true} if valueToFind equals any of the six elements
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ShortConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.ShortConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all six elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ShortTuple.ShortTuple6 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ShortTuple.ShortTuple6 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6)"

### Class ShortTuple7 (com.landawn.abacus.util.ShortTuple.ShortTuple7)
A tuple containing exactly seven short values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 7.
- **Parameters:**
  - (none)
- **Returns:** 7
##### min(...) -> short
- **Signature:** `@Override public short min()`
- **Summary:** Returns the minimum value among the seven elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, _6, and _7
##### max(...) -> short
- **Signature:** `@Override public short max()`
- **Summary:** Returns the maximum value among the seven elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, _6, and _7
##### median(...) -> short
- **Signature:** `@Override public short median()`
- **Summary:** Returns the median value of the seven elements.
- **Contract:**
  - For tuples with an odd number of elements, returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the median short value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all seven elements as an int.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7 as an int
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all seven elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7) / 7.0 as a double
##### reverse(...) -> ShortTuple7
- **Signature:** `@Override public ShortTuple7 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ShortTuple.ShortTuple7 with values (_7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final short valueToFind)`
- **Summary:** Checks if any element equals the specified value.
- **Contract:**
  - Checks if any element equals the specified value.
- **Parameters:**
  - `valueToFind` (`short`) — the short value to search for
- **Returns:** {@code true} if valueToFind equals any of the seven elements
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ShortConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.ShortConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all seven elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ShortTuple.ShortTuple7 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ShortTuple.ShortTuple7 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7)"

### Class ShortTuple8 (com.landawn.abacus.util.ShortTuple.ShortTuple8)
A tuple containing exactly eight short values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 8.
- **Parameters:**
  - (none)
- **Returns:** 8
##### min(...) -> short
- **Signature:** `@Override public short min()`
- **Summary:** Returns the minimum value among the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, _6, _7, and _8
##### max(...) -> short
- **Signature:** `@Override public short max()`
- **Summary:** Returns the maximum value among the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, _6, _7, and _8
##### median(...) -> short
- **Signature:** `@Override public short median()`
- **Summary:** Returns the median value of the eight elements.
- **Parameters:**
  - (none)
- **Returns:** the median (lower middle) short value when sorted
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all eight elements as an int.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 as an int
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all eight elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7 + _8) / 8.0 as a double
##### reverse(...) -> ShortTuple8
- **Signature:** `@Override public ShortTuple8 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ShortTuple.ShortTuple8 with values (_8, _7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final short valueToFind)`
- **Summary:** Checks if any element equals the specified value.
- **Contract:**
  - Checks if any element equals the specified value.
- **Parameters:**
  - `valueToFind` (`short`) — the short value to search for
- **Returns:** {@code true} if valueToFind equals any of the eight elements
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ShortConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.ShortConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all eight elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ShortTuple.ShortTuple8 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ShortTuple.ShortTuple8 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7, _8)"

### Class ShortTuple9 (com.landawn.abacus.util.ShortTuple.ShortTuple9)
A tuple containing exactly nine short values.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### arity(...) -> int
- **Signature:** `@Override public int arity()`
- **Summary:** Returns the number of elements in this tuple, which is always 9.
- **Parameters:**
  - (none)
- **Returns:** 9
##### min(...) -> short
- **Signature:** `@Override public short min()`
- **Summary:** Returns the minimum value among the nine elements.
- **Parameters:**
  - (none)
- **Returns:** the smallest of _1, _2, _3, _4, _5, _6, _7, _8, and _9
##### max(...) -> short
- **Signature:** `@Override public short max()`
- **Summary:** Returns the maximum value among the nine elements.
- **Parameters:**
  - (none)
- **Returns:** the largest of _1, _2, _3, _4, _5, _6, _7, _8, and _9
##### median(...) -> short
- **Signature:** `@Override public short median()`
- **Summary:** Returns the median value of the nine elements.
- **Contract:**
  - For tuples with an odd number of elements, returns the middle value when sorted.
- **Parameters:**
  - (none)
- **Returns:** the median short value
##### sum(...) -> int
- **Signature:** `@Override public int sum()`
- **Summary:** Returns the sum of all nine elements as an int.
- **Parameters:**
  - (none)
- **Returns:** _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 + _9 as an int
##### average(...) -> double
- **Signature:** `@Override public double average()`
- **Summary:** Returns the average of all nine elements.
- **Parameters:**
  - (none)
- **Returns:** (_1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 + _9) / 9.0 as a double
##### reverse(...) -> ShortTuple9
- **Signature:** `@Override public ShortTuple9 reverse()`
- **Summary:** Returns a new tuple with the elements in reverse order.
- **Parameters:**
  - (none)
- **Returns:** a new ShortTuple.ShortTuple9 with values (_9, _8, _7, _6, _5, _4, _3, _2, _1)
##### contains(...) -> boolean
- **Signature:** `@Override public boolean contains(final short valueToFind)`
- **Summary:** Checks if any element equals the specified value.
- **Contract:**
  - Checks if any element equals the specified value.
- **Parameters:**
  - `valueToFind` (`short`) — the short value to search for
- **Returns:** {@code true} if valueToFind equals any of the nine elements
##### forEach(...) -> void
- **Signature:** `@Override public <E extends Exception> void forEach(final Throwables.ShortConsumer<E> consumer) throws E`
- **Summary:** Performs the given action for each element in order.
- **Parameters:**
  - `consumer` (`Throwables.ShortConsumer<E>`) — the action to perform on each element
- **Throws:**
  - `E` — if the consumer throws an exception
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns a hash code value for this tuple.
- **Parameters:**
  - (none)
- **Returns:** a hash code based on all nine elements
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Compares this tuple to another object for equality.
- **Contract:**
  - Two tuples are equal if they are both ShortTuple.ShortTuple9 instances and all corresponding elements are equal.
- **Parameters:**
  - `obj` (`Object`) — the object to compare with
- **Returns:** {@code true} if obj is a ShortTuple.ShortTuple9 with equal elements, {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this tuple.
- **Parameters:**
  - (none)
- **Returns:** a string representation in the format "(_1, _2, _3, _4, _5, _6, _7, _8, _9)"

